"use strict";

globalThis.i18n = {
	'matrix.method.gauss': "Метод Гауса",
	'matrix.method.montante': "Метод Гауса-Монтанте (алгоритм Барейса)",
	'matrix.rule.sarrus': "Правило Саррюса",
	'matrix.rule.triangle': "Правило трикутників",
	'matrix.error.sarrusOnly3x3': "Правило Саррюса застосовується виключно до матриць розміру 3×3",
	'matrix.determinant.explanation': "Приведемо матрицю до ступінчастого вигляду. Слід зазначити, що операція додавання до одного рядка матриці іншого рядка, помноженого на певне число, не змінює визначник. Отже, визначник перетвореної матриці дорівнює визначнику вихідної.",
	'matrix.method.montante.header': "Обчислення визначника матриці методом Монтанте (Барейсса)",
	'matrix.method.montante.explanation': "Визначник матриці відповідає елементу, розташованому в останньому рядку після приведення матриці до ступінчастого вигляду, згідно з формулою ${a_(i,j)=(a_(r,c)*a_(i,j)-a_(i,c)*a_(r,j))/p}, де ${r} і ${c} - номери рядка і стовпця опорного елемента, а ${p} - значення опорного елемента на попередньому кроці. Зауваження: ${someDetails3}.",
	'matrix.inverse.explanation': "Знайдемо обернену матрицю за допомогою елементарних перетворень. Для цього допишемо справа одиничну матрицю такого ж розміру:",
	'matrix.identity': "Одинична матриця",
	'matrix.row.notation': "<msub><mi>R</mi><mn>${i}</mn></msub>",
	'matrix.identity.notation': "I",
	'eigen.vectors.forMatrixA': "Власні вектори для матриці A:",
	'eigen.definition': "За визначенням, власний вектор, що відповідає власному значенню ${λ}, задовольняє рівняння: ${A*v=λ*v}",
	'eigen.nonZeroSolutionCondition': "Рівняння матиме ненульовий розв'язок тоді і тільки тоді, коли виконується умова ${|(А-λI)|=0}",
	'eigen.homogeneousSystem': "Розв'яжемо отриману однорідну систему лінійних рівнянь методом Гаусса:",
	'eigen.findForEachValue': "Для кожного власного значення λ знайдемо відповідні власні вектори:",
	'eigen.noRationalSolutions': "Раціональних розв'язків не існує.",
	'eigen.letAssumption': "Припустимо, що",
	'eigen.valuesOfA': "власні значення матриці A",
	'system.noSolutions': "Розв'язків не існує.",
	'system.findVariableFromEquation': "З рівняння ${i} системи визначимо змінну ${x}:",
	'system.answer': "Отримана відповідь:",
	'system.generalSolution': "Загальний розв'язок:",
	'system.fundamentalSolution': "Фундаментальна система розв'язань:",
	'elimination.pivotElement': "Опорний елемент:",
	'elimination.rowSwapNegate': "Поміняємо місцями рядок ${i} та рядок ${j}, при цьому помноживши рядок ${i} на ${-1}:",
	'elimination.rowSwap': "Поміняємо місцями рядок ${i} та рядок ${j}:",
	'elimination.rowDivision': "Рядок ${j} ділимо на ${a}:",
	'elimination.rowSubtraction': "Віднімаємо від рядка ${j} рядок ${i}, помножений на ${a}, щоб отримати нулі під головним елементом:",
	'math.exponential.then': "Отже:",
	'ui.details': "Подробиці",
};

BigIntWrapper();
NthRoot();
GCD();
IsPrime64();
Prime();
PollardsRho();
BitSetSparseSolver();
TonelliShanks();
QuadraticSieve();
ECM();
ModularCRT();
FactorizationAlgos();
BigDecimal();
BigDecimalMath();
NewtonInterpolation();
SymbolicAlgebra();
IntervalArithmetic();
GF2();
Trigonometry();
ComplexNumbers();
NonSimplifiedExpression();
ExpressionParser();
BinaryHeap();
Polynomial();
MatrixClass();
Combinations();
BinaryPacking();
IntegerPolynomial();
LLL();
FastLLL();
PolynomialFactorization();
SeedRandom();
RealAlgebraicNumbers();
SomePolynomialRoot();
PolynomialRootMath();
PolynomialWasm();
Eigenvalues();
ConditionClass();
MathMLRendering();
QuadraticInteger();
MatrixExpressions();
LinearSystems();

function BigIntWrapper() {
	function BigIntWrapper() {
	}

	BigIntWrapper.BigInt = function (x) {
		return BigInt(x);
	};
	BigIntWrapper.asIntN = function (bits, bigint) {
		return BigInt.asIntN(bits, bigint);
	};
	BigIntWrapper.asUintN = function (bits, bigint) {
		return BigInt.asUintN(bits, bigint);
	};
	BigIntWrapper.toNumber = function (bigint) {
		return Number(bigint);
	};
	BigIntWrapper.add = function (a, b) {
		return a + b;
	};
	BigIntWrapper.subtract = function (a, b) {
		return a - b;
	};
	BigIntWrapper.multiply = function (a, b) {
		return a * b;
	};
	BigIntWrapper.divide = function (a, b) {
		return a / b;
	};
	BigIntWrapper.remainder = function (a, b) {
		return a % b;
	};
	BigIntWrapper.unaryMinus = function (a) {
		return -a;
	};
	BigIntWrapper.equal = function (a, b) {
		return a === b;
	};
	BigIntWrapper.lessThan = function (a, b) {
		return a < b;
	};
	BigIntWrapper.greaterThan = function (a, b) {
		return a > b;
	};
	BigIntWrapper.notEqual = function (a, b) {
		return a !== b;
	};
	BigIntWrapper.lessThanOrEqual = function (a, b) {
		return a <= b;
	};
	BigIntWrapper.greaterThanOrEqual = function (a, b) {
		return a >= b;
	};
	BigIntWrapper.exponentiate = function (a, b) {
		if (typeof a !== "bigint" || typeof b !== "bigint") {
			throw new TypeError();
		}
		var n = Number(b);
		if (n < 0) {
			throw new RangeError();
		}
		if (n > Number.MAX_SAFE_INTEGER) {
			var y = Number(a);
			if (y === 0 || y === -1 || y === +1) {
				return y === -1 && Number(b % BigInt(2)) === 0 ? -a : a;
			}
			throw new RangeError();
		}
		if (a === BigInt(2)) {
			return BigInt(1) << b;
		}
		if (n === 0) {
			return BigInt(1);
		}
		var x = a;
		while (n % 2 === 0) {
			n = Math.floor(n / 2);
			x *= x;
		}
		var accumulator = x;
		n -= 1;
		if (n >= 2) {
			while (n >= 2) {
				var t = Math.floor(n / 2);
				if (t * 2 !== n) {
					accumulator *= x;
				}
				n = t;
				x *= x;
			}
			accumulator *= x;
		}
		return accumulator;
	};
	BigIntWrapper.signedRightShift = function (a, n) {
		return a >> n;
	};
	BigIntWrapper.leftShift = function (a, n) {
		return a << n;
	};
	if (Symbol.hasInstance != undefined) {
		Object.defineProperty(BigIntWrapper, Symbol.hasInstance, {
			value: function (a) {
				return typeof a === 'bigint';
			}
		});
	}

	var supportsBigInt = Symbol.hasInstance != undefined && typeof BigInt !== "undefined" && BigInt(Number.MAX_SAFE_INTEGER) + BigInt(2) - BigInt(2) === BigInt(Number.MAX_SAFE_INTEGER);

	if (supportsBigInt) {
		if (((-BigInt('0xffffffffffffffffffffffffffffffff')) >> BigInt(0x40)).toString() !== '-18446744073709551616') {
			BigIntWrapper.signedRightShift = function (a, n) {
				var b = BigInt(1) << n;
				return a >= BigInt(0) ? a / b : (a - b + BigInt(1)) / b;
			};
		}
	}
	if (supportsBigInt) {
		try {
			BigInt(Number.MAX_SAFE_INTEGER + 1);
		} catch (error) {

			BigIntWrapper.BigInt = function (x) {
				if (typeof x === "number") {
					var e = 0;
					var f = x;
					while (f >= Number.MAX_SAFE_INTEGER + 1) {
						f /= (Number.MAX_SAFE_INTEGER + 1);
						e += Math.round(Math.log2(Number.MAX_SAFE_INTEGER + 1));
					}
					if (e !== 0) {
						return BigInt(f) << BigInt(e);
					}
				}
				return BigInt(x);
			};
		}
	}

	var Internal = BigIntWrapper;

	var n = function (f) {
		return function (x, y) {
			return f(x, y);
		};
	};

	var cache = new Array(16 * 2 + 1);
	for (var i = 0; i < cache.length; i += 1) {
		cache[i] = undefined;
	}

	function LastTwoMap() {
		this.a = undefined;
		this.aKey = 0;
		this.b = undefined;
		this.bKey = 0;
		this.last = 0;
	}

	LastTwoMap.prototype.get = function (key) {
		if (this.aKey === key) {
			this.last = 0;
			return this.a;
		}
		if (this.bKey === key) {
			this.last = 1;
			return this.b;
		}
		return undefined;
	};
	LastTwoMap.prototype.set = function (key, value) {
		if (this.last === 0) {
			this.bKey = key;
			this.b = value;
			this.last = 1;
		} else {
			this.aKey = key;
			this.a = value;
			this.last = 0;
		}
	};
	var map = new LastTwoMap();
	var toNumber = n(function (a) {
		return Internal.toNumber(a);
	});
	var valueOf = function (x) {
		if (typeof x === "number") {
			if (x >= -16 && x <= +16) {
				var value = cache[x + 16];
				if (value == undefined) {
					value = Internal.BigInt(x);
					cache[x + 16] = value;
				}
				return value;
			}
			var value = map.get(x);
			if (value == undefined) {
				value = Internal.BigInt(x);
				map.set(x, value);
			}
			return value;
		}
		return x;
	};
	var B1 = undefined;
	var B2 = undefined;
	var initB1B2 = function () {
		B1 = Internal.BigInt(-9007199254740991);
		B2 = Internal.BigInt(9007199254740991);
	};
	var toResult = function (x) {
		if (!Internal.lessThan(x, B1) && !Internal.greaterThan(x, B2)) {
			return Internal.toNumber(x);
		}
		return x;
	};
	var add = n(function (x, y) {
		if (typeof x === "string" || typeof y === "string") {
			return x + y;
		}
		if (typeof x === "number" && x === 0) {
			return y;
		}
		if (typeof y === "number" && y === 0) {
			return x;
		}
		var a = valueOf(x);
		var b = valueOf(y);
		var sum = Internal.add(a, b);
		return typeof x === "number" && typeof y === "number" ? sum : toResult(sum);
	});
	var subtract = n(function (x, y) {
		if (typeof x === "number" && x === 0) {
			return unaryMinus(y);
		}

		if (typeof y === "number" && y === 0) {
			return x;
		}
		var a = valueOf(x);
		var b = valueOf(y);
		var difference = Internal.subtract(a, b);
		return typeof x === "number" && typeof y === "number" ? difference : toResult(difference);
	});
	var multiply = n(function (x, y) {
		if (typeof x === "number" && x === 0) {
			return 0;
		}
		if (typeof x === "number" && x === 1) {
			return y;
		}
		if (typeof x === "number" && x === -1) {
			return Internal.unaryMinus(y);
		}
		if (typeof y === "number" && y === 0) {
			return 0;
		}
		if (typeof y === "number" && y === 1) {
			return x;
		}
		if (typeof y === "number" && y === -1) {
			return Internal.unaryMinus(x);
		}
		var a = valueOf(x);
		var b = valueOf(y);
		return Internal.multiply(a, b);
	});
	var divide = n(function (x, y) {
		if (typeof x === "number" && typeof y !== "number") {
			return 0;
		}
		if (typeof y === "number" && y === 1) {
			return x;
		}
		if (typeof y === "number" && y === -1) {
			return Internal.unaryMinus(x);
		}
		var a = valueOf(x);
		var b = valueOf(y);
		return toResult(Internal.divide(a, b));
	});
	var remainder = n(function (x, y) {
		if (typeof x === "number" && typeof y !== "number") {
			return x;
		}
		if (typeof y === "number" && y === 1) {
			return 0;
		}
		if (typeof y === "number" && y === -1) {
			return 0;
		}
		var a = valueOf(x);
		var b = valueOf(y);
		return toResult(Internal.remainder(a, b));
	});
	var exponentiate = n(function (x, y) {
		if (typeof y === "number") {
			if (y === 0) {
				return 1;
			}
			if (y === 1) {
				return x;
			}
			if (y === 2) {
				return multiply(x, x);
			}
			if (typeof x === "number" && Math.abs(x) > 2 && y >= 0) {
				if (y > 42 && x % 2 === 0) {
					return multiply(exponentiate(2, y), exponentiate(x / 2, y));
				}
				var k = Math.floor(Math.log(9007199254740991) / Math.log(Math.abs(x) + 0.5));
				if (k >= 2) {
					return multiply(Math.pow(x, y % k), exponentiate(Math.pow(x, k), Math.floor(y / k)));
				}
			}
		}
		var a = valueOf(x);
		var b = valueOf(y);
		var power = Internal.exponentiate(a, b);
		return typeof x === "number" && Math.abs(x) <= 1 ? toResult(power) : power;
	});
	var unaryMinus = n(function (x) {
		var a = valueOf(x);
		return Internal.unaryMinus(a);
	});
	var equal = n(function (x, y) {
		if (typeof x === "number") {
			return false;
		}
		if (typeof y === "number") {
			return false;
		}
		return Internal.equal(x, y);
	});
	var lessThan = n(function (x, y) {
		if (typeof x === "number") {
			return x < Internal.toNumber(y);
		}
		if (typeof y === "number") {
			return Internal.toNumber(x) < y;
		}
		return Internal.lessThan(x, y);
	});
	var greaterThan = n(function (x, y) {
		if (typeof x === "number") {
			return x > Internal.toNumber(y);
		}
		if (typeof y === "number") {
			return Internal.toNumber(x) > y;
		}
		return Internal.greaterThan(x, y);
	});

	function SmallBigInt() {
	}

	SmallBigInt.BigInt = function (x) {
		if (typeof x === "number" || typeof x === "string") {
			var value = 0 + (typeof x === "number" ? x : Number(x));
			if (value >= -9007199254740991 && value <= 9007199254740991) {
				return value;
			}
		}
		if (typeof x === "bigint") {
			return toResult(x);
		}
		return toResult(Internal.BigInt(x));
	};
	SmallBigInt.asIntN = function (n, x) {
		return toResult(Internal.asIntN(n, Internal.BigInt(x)));
	};
	SmallBigInt.asUintN = function (n, x) {
		if (typeof x === "number" && x >= 0 && n >= 0 && n <= 53) {
			var m = Math.pow(2, n);
			return x - Math.floor(x / m) * m;
		}
		return toResult(Internal.asUintN(n, Internal.BigInt(x)));
	};

	SmallBigInt.toNumber = function (x) {
		if (typeof x === "number") {
			return x;
		}
		return toNumber(x);
	};

	SmallBigInt.add = function (x, y) {
		if (typeof x === "number" && typeof y === "number") {
			var value = x + y;
			if (value >= -9007199254740991 && value <= 9007199254740991) {
				return value;
			}
		}
		return add(x, y);
	};
	SmallBigInt.subtract = function (x, y) {
		if (typeof x === "number" && typeof y === "number") {
			var value = x - y;
			if (value >= -9007199254740991 && value <= 9007199254740991) {
				return value;
			}
		}
		return subtract(x, y);
	};
	SmallBigInt.multiply = function (x, y) {
		if (typeof x === "number" && typeof y === "number") {
			var value = 0 + x * y;
			if (value >= -9007199254740991 && value <= 9007199254740991) {
				return value;
			}
		}
		return multiply(x, y);
	};
	SmallBigInt.divide = function (x, y) {
		if (typeof x === "number" && typeof y === "number") {
			if (y !== 0) {
				return x === 0 ? 0 : (x > 0 && y > 0) || (x < 0 && y < 0) ? 0 + Math.floor(x / y) : 0 - Math.floor((0 - x) / y);
			}
		}
		return divide(x, y);
	};
	SmallBigInt.remainder = function (x, y) {
		if (typeof x === "number" && typeof y === "number") {
			if (y !== 0) {
				return 0 + x % y;
			}
		}
		return remainder(x, y);
	};
	SmallBigInt.unaryMinus = function (x) {
		if (typeof x === "number") {
			return 0 - x;
		}
		return unaryMinus(x);
	};

	SmallBigInt.equal = function (x, y) {
		if (typeof x === "number" && typeof y === "number") {
			return x === y;
		}
		return equal(x, y);
	};
	SmallBigInt.lessThan = function (x, y) {
		if (typeof x === "number" && typeof y === "number") {
			return x < y;
		}
		return lessThan(x, y);
	};
	SmallBigInt.greaterThan = function (x, y) {
		if (typeof x === "number" && typeof y === "number") {
			return x > y;
		}
		return greaterThan(x, y);
	};
	SmallBigInt.notEqual = function (x, y) {
		return !SmallBigInt.equal(x, y);
	};
	SmallBigInt.lessThanOrEqual = function (x, y) {
		return !SmallBigInt.greaterThan(x, y);
	};
	SmallBigInt.greaterThanOrEqual = function (x, y) {
		return !SmallBigInt.lessThan(x, y);
	};

	SmallBigInt.exponentiate = function (x, y) {
		if (typeof x === "number" && typeof y === "number") {
			if (y >= 0 && (y < 53 || x >= -1 && x <= 1)) {
				var value = 0 + Math.pow(x, y);
				if (value >= -9007199254740991 && value <= 9007199254740991) {
					return value;
				}
			}
		}
		return exponentiate(x, y);
	};
	SmallBigInt.signedRightShift = function (x, n) {
		return toResult(Internal.signedRightShift(valueOf(x), valueOf(n)));
	};
	SmallBigInt.leftShift = function (x, n) {
		if (typeof n === "number" && n >= 0) {
			if (typeof x === "number") {
				var value = n === 0 ? x : x * Math.pow(2, n);
				if (value >= -9007199254740991 && value <= 9007199254740991) {
					return value;
				}
			}
			return Internal.leftShift(valueOf(x), valueOf(n));
		}
		return toResult(Internal.leftShift(valueOf(x), valueOf(n)));
	};
	if (Symbol.hasInstance != undefined) {
		Object.defineProperty(SmallBigInt, Symbol.hasInstance, {
			value: function (a) {
				return typeof a === 'number' || a instanceof Internal;
			}
		});
	}

	globalThis.SmallBigInt = SmallBigInt;

	globalThis.JSBI = supportsBigInt ? BigIntWrapper : (globalThis.JSBI || globalThis.BigInteger);
	Internal = globalThis.JSBI;
	initB1B2();
}

function NthRoot() {
	function nthRoot(S, n) {
		if (!(S instanceof JSBI) || typeof n !== 'number' || Math.floor(n) !== n || n < 1 || n > Number.MAX_SAFE_INTEGER) {
			throw new RangeError();
		}
		if (n === 1) {
			return S;
		}
		var s = JSBI.toNumber(JSBI.add(S, JSBI.BigInt(0)));
		if (s === 0) {
			return JSBI.BigInt(0);
		}
		if (s < 0) {
			if (n % 2 === 0) {
				throw new RangeError();
			}
			return JSBI.unaryMinus(JSBI.BigInt(nthRoot(JSBI.unaryMinus(S), n)));
		}
		var B = Number.MAX_SAFE_INTEGER + 1;
		var E = Math.floor(B / (n === 2 ? 2 : Math.pow(2, 1 + Math.ceil(Math.log2(Math.log2(B))))));
		if (s < E) {

			var g = n === 2 ? Math.floor(Math.sqrt(s + 0.5)) : Math.floor(Math.exp(Math.log(s + 0.5) / n));
			return JSBI.BigInt(g);
		}
		var g = n === 2 ? Math.sqrt(s) : Math.exp(Math.log(s) / n);
		if (g < E) {
			if (Math.floor(g - g / E) === Math.floor(g + g / E)) {
				return JSBI.BigInt(Math.floor(g));
			}
			var y = JSBI.BigInt(Math.floor(g + 0.5));
			return JSBI.lessThan(S, JSBI.exponentiate(y, JSBI.BigInt(n))) ? JSBI.subtract(y, JSBI.BigInt(1)) : y;
		}
		var size = S.toString(16).length * 4;
		if (size <= n) {
			return JSBI.BigInt(1);
		}
		var half = Math.floor((Math.floor(size / n) + 1) / 2);
		var x = JSBI.leftShift(JSBI.add(JSBI.BigInt(nthRoot(JSBI.signedRightShift(S, JSBI.BigInt(half * n)), n)), JSBI.BigInt(1)), JSBI.BigInt(half));
		var xprev = JSBI.unaryMinus(JSBI.BigInt(1));
		do {
			xprev = x;
			if (n === 2) {
				x = JSBI.signedRightShift(JSBI.add(x, JSBI.divide(S, x)), JSBI.BigInt(1));
			} else {
				x = JSBI.divide(JSBI.add(JSBI.multiply(JSBI.BigInt(n - 1), x), JSBI.divide(S, JSBI.exponentiate(x, JSBI.BigInt(n - 1)))), JSBI.BigInt(n));
			}
		} while (JSBI.lessThan(x, xprev));
		return xprev;
	}

	self.nthRoot = nthRoot;
}

function GCD() {
	var SUBQUADRATIC_GCD_THRESHOLD = 32 * 1024;
	var SUBQUADRATIC_HALFGCD_THRESHOLD = 4096;
	var DOUBLE_DIGIT_METHOD = true;
	var USE_HALF_EXTENDED = true;
	var SMALL_GCD_MAX = JSBI.BigInt(0);
	var DIGITSIZE = 0;
	var smallgcd = null;
	var smallgcdext = null;
	var wasmHelper = null;
	var jsHelper = null;
	if (true && typeof WebAssembly !== 'undefined') {
		var wasmCode = new Uint8Array([0, 97, 115, 109, 1, 0, 0, 0, 1, 20, 3, 96, 0, 1, 126, 96, 2, 126, 126, 1, 126, 96, 5, 126, 126, 126, 126, 127, 1, 127, 3, 8, 7, 1, 1, 2, 0, 0, 0, 0, 6, 21, 4, 126, 1, 66, 0, 11, 126, 1, 66, 0, 11, 126, 1, 66, 0, 11, 126, 1, 66, 0, 11, 7, 47, 7, 6, 117, 54, 52, 103, 99, 100, 0, 0, 9, 117, 54, 52, 103, 99, 100, 101, 120, 116, 0, 1, 6, 104, 101, 108, 112, 101, 114, 0, 2, 1, 65, 0, 3, 1, 66, 0, 4, 1, 67, 0, 5, 1, 68, 0, 6, 10, 141, 4, 7, 37, 1, 1, 126, 32, 1, 66, 0, 82, 4, 64, 3, 64, 32, 0, 32, 1, 130, 33, 2, 32, 1, 33, 0, 32, 2, 34, 1, 66, 0, 82, 13, 0, 11, 11, 32, 0, 11, 97, 1, 6, 126, 66, 1, 33, 6, 66, 1, 33, 3, 32, 1, 66, 0, 82, 4, 64, 3, 64, 32, 0, 32, 0, 32, 1, 128, 34, 7, 32, 1, 126, 125, 33, 4, 32, 1, 33, 0, 32, 6, 32, 2, 32, 7, 126, 125, 33, 1, 32, 5, 32, 3, 32, 7, 126, 125, 33, 7, 32, 2, 33, 6, 32, 3, 33, 5, 32, 1, 33, 2, 32, 7, 33, 3, 32, 4, 34, 1, 66, 0, 82, 13, 0, 11, 11, 32, 6, 36, 0, 32, 5, 36, 1, 32, 0, 11, 238, 2, 2, 7, 126, 2, 127, 66, 1, 33, 9, 66, 1, 33, 7, 32, 0, 66, 127, 82, 32, 2, 66, 127, 82, 113, 4, 64, 3, 64, 32, 0, 32, 6, 124, 33, 8, 32, 0, 32, 9, 124, 33, 6, 32, 2, 32, 5, 124, 33, 5, 32, 2, 32, 7, 124, 33, 7, 32, 12, 65, 1, 113, 4, 64, 32, 8, 33, 9, 32, 6, 33, 8, 32, 9, 33, 6, 32, 5, 33, 9, 32, 7, 33, 5, 32, 9, 33, 7, 11, 3, 64, 32, 5, 32, 6, 32, 8, 32, 7, 128, 34, 11, 32, 5, 126, 125, 34, 9, 86, 4, 64, 32, 12, 65, 1, 106, 33, 12, 32, 8, 32, 7, 32, 11, 126, 125, 33, 10, 32, 0, 32, 2, 32, 11, 126, 125, 33, 11, 32, 5, 33, 8, 32, 7, 33, 6, 32, 2, 33, 0, 32, 10, 33, 5, 32, 9, 33, 7, 32, 11, 33, 2, 12, 1, 11, 11, 32, 6, 32, 0, 125, 33, 9, 32, 8, 32, 0, 125, 33, 6, 32, 5, 32, 2, 125, 33, 5, 32, 7, 32, 2, 125, 33, 7, 32, 12, 65, 1, 113, 4, 64, 32, 9, 33, 8, 32, 6, 33, 9, 32, 8, 33, 6, 32, 5, 33, 8, 32, 7, 33, 5, 32, 8, 33, 7, 11, 32, 4, 32, 0, 32, 9, 124, 34, 8, 32, 0, 32, 6, 124, 34, 10, 32, 8, 32, 10, 86, 27, 121, 167, 34, 13, 32, 4, 32, 13, 72, 27, 34, 13, 4, 64, 32, 1, 32, 1, 32, 4, 32, 13, 107, 34, 4, 172, 34, 8, 136, 34, 10, 32, 8, 134, 125, 33, 1, 32, 3, 32, 3, 32, 8, 136, 34, 11, 32, 8, 134, 125, 33, 3, 32, 9, 32, 10, 126, 32, 6, 32, 11, 126, 124, 32, 0, 32, 13, 172, 34, 8, 134, 124, 33, 0, 32, 5, 32, 10, 126, 32, 7, 32, 11, 126, 124, 32, 2, 32, 8, 134, 124, 33, 2, 11, 32, 13, 13, 0, 11, 11, 32, 9, 36, 0, 32, 6, 36, 1, 32, 5, 36, 2, 32, 7, 36, 3, 65, 0, 11, 4, 0, 35, 0, 11, 4, 0, 35, 1, 11, 4, 0, 35, 2, 11, 4, 0, 35, 3, 11]);
		try {
			var exports = new WebAssembly.Instance(new WebAssembly.Module(wasmCode)).exports;
			if (exports.helper(JSBI.BigInt(1), JSBI.BigInt(0), JSBI.BigInt(1), JSBI.BigInt(0)) != null) {
				wasmHelper = function (x, xlo, y, ylo, lobits) {
					exports.helper(x, xlo, y, ylo, lobits);
					return [exports.A(), exports.B(), exports.C(), exports.D()];
				};
				DIGITSIZE = 64;
				SMALL_GCD_MAX = JSBI.asUintN(64, JSBI.unaryMinus(JSBI.BigInt(1)));
			}
			if (JSBI.equal(exports.u64gcd(JSBI.BigInt(0), JSBI.BigInt(0)), JSBI.BigInt(0))) {
				smallgcd = exports.u64gcd;
			}
			if (JSBI.equal(exports.u64gcdext(JSBI.BigInt(0), JSBI.BigInt(0)), JSBI.BigInt(0))) {
				smallgcdext = function (a, b) {
					var g = exports.u64gcdext(a, b);
					return [exports.A(), exports.B(), g];
				};
			}
		} catch (error) {
			console.log(error);
		}
	}

	function AsmModule(stdlib) {
		"use asm";

		var floor = stdlib.Math.floor;
		var max = stdlib.Math.max;
		var clz32 = stdlib.Math.clz32;
		var gA = -0.0;
		var gB = -0.0;
		var gC = -0.0;
		var gD = -0.0;

		function f64gcd(a, b) {
			a = +a;
			b = +b;
			var b1 = -0.0;
			var q = -0.0;
			while (b > -0.0) {
				q = +floor(a / b);
				b1 = a - q * b;
				a = b;
				b = b1;
			}
			return +a;
		}

		function f64gcdext(a, b) {
			a = +a;
			b = +b;
			var b1 = -0.0;
			var q = -0.0;
			var A = 1.0;
			var B = -0.0;
			var C = -0.0;
			var D = 1.0;
			var C1 = -0.0;
			var D1 = -0.0;
			while (b > -0.0) {
				q = +floor(a / b);
				b1 = a - q * b;
				a = b;
				b = b1;
				C1 = A - q * C;
				D1 = B - q * D;
				A = C;
				B = D;
				C = C1;
				D = D1;
			}
			gA = A;
			gB = B;
			return +a;
		}

		function log2(x) {
			x = +x;
			var e = 0;
			while (x >= 4294967296.0) {
				x = x * 2.3283064365386963e-10;
				e = e + 32 | 0;
			}
			e = e + (32 - (clz32(~~x) | 0)) | 0;
			return e | 0;
		}

		function exp2(n) {
			n = n | 0;
			var result = 1.0;
			while ((n | 0) < 0) {
				n = n + 32 | 0;
				result = result * 2.3283064365386963e-10;
			}

			while ((n | 0) >= 32) {
				n = n - 32 | 0;
				result = result * 4294967296.0;
			}

			result = result * +(1 << n >>> 0);
			return +result;
		}

		function jsHelper(x, xlo, y, ylo, lobits) {
			x = +x;
			xlo = +xlo;
			y = +y;
			ylo = +ylo;
			lobits = lobits | 0;
			var A = 1.0;
			var B = -0.0;
			var C = -0.0;
			var D = 1.0;
			var bits = 0;
			var sameQuotient = 0;
			var q = -0.0;
			var y1 = -0.0;
			var A1 = -0.0;
			var B1 = -0.0;
			var C1 = -0.0;
			var D1 = -0.0;
			var b = 0;
			var d = -0.0;
			var dInv = -0.0;
			var xlo1 = -0.0;
			var ylo1 = -0.0;
			var p = -0.0;
			if (y != -0.0) {
				do {
					do {
						q = floor(x / y);
						y1 = x - q * y;
						A1 = C;
						B1 = D;
						C1 = A - q * C;
						D1 = B - q * D;

						sameQuotient = -0.0 <= y1 + C1 & y1 + C1 < y + C & -0.0 <= y1 + D1 & y1 + D1 < y + D;
						if (sameQuotient) {
							x = y;
							y = y1;
							A = A1;
							B = B1;
							C = C1;
							D = D1;
						}
					} while (sameQuotient);
					b = 53 - (log2(x + max(A, B)) | 0) | 0;
					bits = (b | 0) < 0 ? b : (b | 0) > (lobits | 0) ? lobits : b;
					if ((b | 0) != 0) {
						d = +exp2(lobits - bits | 0);
						dInv = +exp2(bits - lobits | 0);
						xlo1 = +floor(xlo * dInv);
						ylo1 = +floor(ylo * dInv);
						xlo = xlo - xlo1 * d;
						ylo = ylo - ylo1 * d;
						lobits = lobits - bits | 0;
						p = +exp2(bits);
						x = A * xlo1 + B * ylo1 + x * p;
						y = C * xlo1 + D * ylo1 + y * p;
					}
				} while ((bits | 0) != 0);
			}
			gA = A;
			gB = B;
			gC = C;
			gD = D;
			return 0;
		}

		function A() {
			return gA;
		}

		function B() {
			return gB;
		}

		function C() {
			return gC;
		}

		function D() {
			return gD;
		}

		return {
			f64gcdext: f64gcdext,
			f64gcd: f64gcd,
			helper: jsHelper,
			A: A,
			B: B,
			C: C,
			D: D
		};
	}

	if (DIGITSIZE === 0) {
		var asmExports = AsmModule(globalThis);
		jsHelper = function (x, xlo, y, ylo, lobits) {
			asmExports.helper(x, xlo, y, ylo, lobits);
			return [JSBI.BigInt(asmExports.A()), JSBI.BigInt(asmExports.B()), JSBI.BigInt(asmExports.C()), JSBI.BigInt(asmExports.D())];
		};
		DIGITSIZE = 53;
		SMALL_GCD_MAX = JSBI.asUintN(53, JSBI.unaryMinus(JSBI.BigInt(1)));
		smallgcd = function (a, b) {
			return JSBI.BigInt(asmExports.f64gcd(JSBI.toNumber(JSBI.BigInt(a)), JSBI.toNumber(JSBI.BigInt(b))));
		};
		smallgcdext = function (a, b) {
			var g = asmExports.f64gcdext(JSBI.toNumber(JSBI.BigInt(a)), JSBI.toNumber(JSBI.BigInt(b)));
			return [JSBI.BigInt(asmExports.A()), JSBI.BigInt(asmExports.B()), JSBI.BigInt(g)];
		};
	}

	function bitLength(a) {
		var s = a.toString(16);
		var c = s.charCodeAt(0) - 0 - '0'.charCodeAt(0);
		if (c <= 0) {
			throw new RangeError();
		}
		return (s.length - 1) * 4 + (32 - Math.clz32(Math.min(c, 8)));
	}

	var frexpf64 = typeof Float64Array !== 'undefined' ? new Float64Array(1) : null;
	var frexpi32 = typeof Float64Array !== 'undefined' ? new Int32Array(frexpf64.buffer) : null;
	var previousValue = 0;

	function bitLength2(a) {
		if (previousValue <= 1024) {
			var n = -0.0 + JSBI.toNumber(JSBI.BigInt(a));
			if (frexpf64 != null) {
				frexpf64[0] = n;
				var e = (frexpi32[1] >> 20) - 1023;
				if (e < 1024 && frexpi32[0] !== 0 || (frexpi32[1] & 0xFFFFF) !== 0) {
					previousValue = e + 1;
					return previousValue;
				}
			}
			var x = Math.log2(n) + 1024 * 4 - 1024 * 4;
			var y = Math.ceil(x);
			if (x !== y) {
				previousValue = y;
				return previousValue;
			}
		}
		if (previousValue < DIGITSIZE) {
			previousValue = DIGITSIZE;
		}
		var n = -0.0 + JSBI.toNumber(JSBI.signedRightShift(a, JSBI.BigInt(previousValue - DIGITSIZE)));
		if (n >= 1 && n <= 9007199254740992) {

			var x = +n;
			var e = 0;
			while (x > +(1 << 30)) {
				x = Math.floor(x / +(1 << 30));
				e += 30;
			}
			e += 32 - Math.clz32(x);
			previousValue = previousValue - DIGITSIZE + e;
			return previousValue;
		}
		previousValue = bitLength(a);
		return previousValue;
	}

	function helper(X, Y) {
		if (!(X instanceof JSBI) || !(Y instanceof JSBI)) {
			throw new TypeError();
		}
		if (wasmHelper != null) {
			if (DIGITSIZE !== 64) {
				throw new RangeError();
			}
			if (!DOUBLE_DIGIT_METHOD) {
				return wasmHelper(X, JSBI.BigInt(0), Y, JSBI.BigInt(0), 0);
			}
			var x = JSBI.asUintN(64, JSBI.signedRightShift(X, JSBI.BigInt(64)));
			var xlo = JSBI.asUintN(64, X);
			var y = JSBI.asUintN(64, JSBI.signedRightShift(Y, JSBI.BigInt(64)));
			var ylo = JSBI.asUintN(64, Y);
			return wasmHelper(x, xlo, y, ylo, 64);
		} else {
			if (DIGITSIZE !== 53) {
				throw new RangeError();
			}
			if (!DOUBLE_DIGIT_METHOD) {
				return jsHelper(-0.0 + JSBI.toNumber(X), 0, -0.0 + JSBI.toNumber(Y), 0, 0);
			}
			var x = -0.0 + JSBI.toNumber(JSBI.signedRightShift(X, JSBI.BigInt(53)));
			var xlo = -0.0 + JSBI.toNumber(JSBI.asUintN(53, X));
			var y = -0.0 + JSBI.toNumber(JSBI.signedRightShift(Y, JSBI.BigInt(53)));
			var ylo = -0.0 + JSBI.toNumber(JSBI.asUintN(53, Y));
			return jsHelper(x, xlo, y, ylo, 53);
		}
	}

	function abs(a) {
		if (!(a instanceof JSBI)) {
			throw new TypeError();
		}
		return JSBI.lessThan(a, JSBI.BigInt(0)) ? JSBI.unaryMinus(a) : a;
	}

	function max(a, b) {
		if (!(a instanceof JSBI) || !(b instanceof JSBI)) {
			throw new TypeError();
		}
		return JSBI.lessThan(a, b) ? b : a;
	}

	function halfgcd(a, b, extended, reallyhalfgcd, wrapper) {
		extended = extended == undefined ? true : extended;
		reallyhalfgcd = reallyhalfgcd == undefined ? true : reallyhalfgcd;
		wrapper = wrapper == undefined ? false : wrapper;
		if (!(a instanceof JSBI) || !(b instanceof JSBI)) {
			throw new TypeError();
		}
		extended = extended || reallyhalfgcd;

		var A = JSBI.BigInt(1);
		var B = JSBI.BigInt(0);
		var C = JSBI.BigInt(0);
		var D = JSBI.BigInt(1);
		var step = 0;

		if (JSBI.lessThan(a, JSBI.BigInt(0))) {
			a = JSBI.unaryMinus(a);
			if (extended) {
				A = JSBI.unaryMinus(A);
				B = JSBI.unaryMinus(B);
				step += 1;
			}
		}

		if (JSBI.lessThan(b, JSBI.BigInt(0))) {
			b = JSBI.unaryMinus(b);
			if (extended) {
				C = JSBI.unaryMinus(C);
				D = JSBI.unaryMinus(D);
				step += 1;
			}
		}
		if (JSBI.lessThan(a, b)) {
			var tmp = a;
			a = b;
			b = tmp;
			if (extended) {
				var C1 = A;
				A = C;
				C = C1;
				var D1 = B;
				B = D;
				D = D1;
				step += 1;
			}
		}

		var isSmall = false;
		if (reallyhalfgcd) {
			if (JSBI.equal(JSBI.asUintN(SUBQUADRATIC_HALFGCD_THRESHOLD, a), a)) {
				isSmall = true;
			}
		}
		var isVerySmall = false;
		var sizea0 = 0;
		while ((reallyhalfgcd || JSBI.greaterThan(a, SMALL_GCD_MAX)) && JSBI.notEqual(b, JSBI.BigInt(0))) {

			if (!isSmall) {

				if (!reallyhalfgcd) {
					if (JSBI.equal(JSBI.asUintN(SUBQUADRATIC_GCD_THRESHOLD * (extended ? 1 / 16 : 1), b), b)) {
						isSmall = true;
						continue;
					}
				}
			}
			step += 1;
			if (!isSmall) {
				if (reallyhalfgcd && step === 1) {
					sizea0 = bitLength(a);
				}
				var s1 = reallyhalfgcd ? bitLength(max(abs(C), abs(D))) : 0;
				var m = reallyhalfgcd ? Math.max(0, Math.ceil((sizea0 - s1 - s1) * (1 / 2))) : extended ? 0 : Math.floor(bitLength(a) * 2 / 3);
				var M = JSBI.BigInt(m);
				if (step !== 1 && reallyhalfgcd) {
					if (m < 256) {

						isSmall = true;
						continue;
					}

					var k = 8;
					while (JSBI.notEqual(JSBI.signedRightShift(JSBI.add(a, A), M), JSBI.signedRightShift(JSBI.add(a, B), M)) || JSBI.notEqual(JSBI.signedRightShift(JSBI.add(b, C), M), JSBI.signedRightShift(JSBI.add(b, D), M))) {

						m += k;
						M = JSBI.BigInt(m);
						k += k;
					}
				}
				var $tmp$A1_$B1_$C1_$D1_$ahi1_$bhi1 = halfgcd(JSBI.signedRightShift(a, M), JSBI.signedRightShift(b, M));
				var $A1 = $tmp$A1_$B1_$C1_$D1_$ahi1_$bhi1[0];
				var $B1 = $tmp$A1_$B1_$C1_$D1_$ahi1_$bhi1[1];
				var $C1 = $tmp$A1_$B1_$C1_$D1_$ahi1_$bhi1[2];
				var $D1 = $tmp$A1_$B1_$C1_$D1_$ahi1_$bhi1[3];
				var $ahi1 = $tmp$A1_$B1_$C1_$D1_$ahi1_$bhi1[4];
				var $bhi1 = $tmp$A1_$B1_$C1_$D1_$ahi1_$bhi1[5];
				var $newA1 = JSBI.BigInt($A1);
				var $newB1 = JSBI.BigInt($B1);
				var $newC1 = JSBI.BigInt($C1);
				var $newD1 = JSBI.BigInt($D1);
				var $newahi1 = JSBI.BigInt($ahi1);
				var $newbhi1 = JSBI.BigInt($bhi1);
				var A1 = $newA1;
				var B1 = $newB1;
				var C1 = $newC1;
				var D1 = $newD1;
				var ahi1 = $newahi1;
				var bhi1 = $newbhi1;

				if (JSBI.notEqual(B1, JSBI.BigInt(0))) {
					if (extended) {

						if (step === 1) {
							A = A1;
							B = B1;
							C = C1;
							D = D1;
						} else {
							var B2 = JSBI.add(JSBI.multiply(A1, B), JSBI.multiply(B1, D));
							var D2 = JSBI.add(JSBI.multiply(C1, B), JSBI.multiply(D1, D));
							B = B2;
							D = D2;
							if (!USE_HALF_EXTENDED || reallyhalfgcd) {
								var A2 = JSBI.add(JSBI.multiply(A1, A), JSBI.multiply(B1, C));
								var C2 = JSBI.add(JSBI.multiply(C1, A), JSBI.multiply(D1, C));
								A = A2;
								C = C2;
							}
						}
					}
					var alo = JSBI.asUintN(m, a);
					var blo = JSBI.asUintN(m, b);

					var a1 = JSBI.add(JSBI.add(JSBI.multiply(A1, alo), JSBI.multiply(B1, blo)), JSBI.leftShift(ahi1, M));
					var b1 = JSBI.add(JSBI.add(JSBI.multiply(C1, alo), JSBI.multiply(D1, blo)), JSBI.leftShift(bhi1, M));
					a = a1;
					b = b1;
					if (JSBI.lessThan(a, JSBI.BigInt(0)) || JSBI.lessThan(b, JSBI.BigInt(0))) {
						throw new TypeError("assertion");
					}
					continue;
				} else {

				}
			}
			if (isSmall && !isVerySmall) {

				var m = Math.max(0, bitLength2(a) - DIGITSIZE * (DOUBLE_DIGIT_METHOD ? 2 : 1));
				var M = m === 0 ? JSBI.BigInt(0) : JSBI.BigInt(m);
				if (step !== 1 && reallyhalfgcd) {
					if (JSBI.notEqual(JSBI.signedRightShift(JSBI.add(a, A), M), JSBI.signedRightShift(JSBI.add(a, B), M)) || JSBI.notEqual(JSBI.signedRightShift(JSBI.add(b, C), M), JSBI.signedRightShift(JSBI.add(b, D), M))) {

						if (!wrapper) {
							break;
						}
						do {
							m += 8;
							M = JSBI.BigInt(m);
						} while (JSBI.notEqual(JSBI.signedRightShift(JSBI.add(a, A), M), JSBI.signedRightShift(JSBI.add(a, B), M)) || JSBI.notEqual(JSBI.signedRightShift(JSBI.add(b, C), M), JSBI.signedRightShift(JSBI.add(b, D), M)));
						if (JSBI.equal(JSBI.signedRightShift(b, M), JSBI.BigInt(0))) {
							isVerySmall = true;
							continue;
						}
					}
				}
				var $tmp$A1_$B1_$C1_$D1 = helper(m === 0 ? a : JSBI.signedRightShift(a, M), m === 0 ? b : JSBI.signedRightShift(b, M));
				var $A1 = $tmp$A1_$B1_$C1_$D1[0];
				var $B1 = $tmp$A1_$B1_$C1_$D1[1];
				var $C1 = $tmp$A1_$B1_$C1_$D1[2];
				var $D1 = $tmp$A1_$B1_$C1_$D1[3];
				var $newA1 = JSBI.BigInt($A1);
				var $newB1 = JSBI.BigInt($B1);
				var $newC1 = JSBI.BigInt($C1);
				var $newD1 = JSBI.BigInt($D1);
				var A1 = $newA1;
				var B1 = $newB1;
				var C1 = $newC1;
				var D1 = $newD1;

				if (JSBI.notEqual(B1, JSBI.BigInt(0))) {
					if (extended) {

						if (step === 1) {
							A = A1;
							B = B1;
							C = C1;
							D = D1;
						} else {
							var B2 = JSBI.add(JSBI.multiply(A1, B), JSBI.multiply(B1, D));
							var D2 = JSBI.add(JSBI.multiply(C1, B), JSBI.multiply(D1, D));
							B = B2;
							D = D2;
							if (!USE_HALF_EXTENDED || reallyhalfgcd) {
								var A2 = JSBI.add(JSBI.multiply(A1, A), JSBI.multiply(B1, C));
								var C2 = JSBI.add(JSBI.multiply(C1, A), JSBI.multiply(D1, C));
								A = A2;
								C = C2;
							}
						}
					}

					var a1 = JSBI.add(JSBI.multiply(A1, a), JSBI.multiply(B1, b));
					var b1 = JSBI.add(JSBI.multiply(C1, a), JSBI.multiply(D1, b));
					a = a1;
					b = b1;
					if (JSBI.lessThan(a, JSBI.BigInt(0)) || JSBI.lessThan(b, JSBI.BigInt(0))) {
						throw new TypeError("assertion");
					}
					continue;
				} else {

				}
			}

			var q = JSBI.divide(a, b);
			var b1 = JSBI.subtract(a, JSBI.multiply(q, b));
			if (extended) {
				var C1 = JSBI.subtract(A, JSBI.multiply(q, C));
				var D1 = JSBI.subtract(B, JSBI.multiply(q, D));
				if (reallyhalfgcd) {
					var sameQuotient = JSBI.lessThanOrEqual(JSBI.BigInt(0), JSBI.add(b1, C1)) && JSBI.lessThan(JSBI.add(b1, C1), JSBI.add(b, C)) && JSBI.lessThanOrEqual(JSBI.BigInt(0), JSBI.add(b1, D1)) && JSBI.lessThan(JSBI.add(b1, D1), JSBI.add(b, D));
					if (!sameQuotient) {
						break;
					}
				}

				A = C;
				B = D;
				C = C1;
				D = D1;
			}

			a = b;
			b = b1;

		}

		return [A, B, C, D, a, b];
	}

	function LehmersGCD(a, b) {
		var $tmpA1_B1_C1_D1_a1_b1 = halfgcd(a, b, false, false);
		var A1 = $tmpA1_B1_C1_D1_a1_b1[0];
		var B1 = $tmpA1_B1_C1_D1_a1_b1[1];
		var C1 = $tmpA1_B1_C1_D1_a1_b1[2];
		var D1 = $tmpA1_B1_C1_D1_a1_b1[3];
		var a1 = $tmpA1_B1_C1_D1_a1_b1[4];
		var b1 = $tmpA1_B1_C1_D1_a1_b1[5];
		a = JSBI.BigInt(a1);
		b = JSBI.BigInt(b1);
		if (JSBI.notEqual(b, JSBI.BigInt(0))) {
			a = JSBI.asUintN(64, smallgcd(a, b));
		}
		return a;
	}

	function LehmersGCDExt(a, b) {
		var $tmpA1_B1_C1_D1_a1_b1 = halfgcd(a, b, true, false);
		var A1 = $tmpA1_B1_C1_D1_a1_b1[0];
		var B1 = $tmpA1_B1_C1_D1_a1_b1[1];
		var C1 = $tmpA1_B1_C1_D1_a1_b1[2];
		var D1 = $tmpA1_B1_C1_D1_a1_b1[3];
		var a1 = $tmpA1_B1_C1_D1_a1_b1[4];
		var b1 = $tmpA1_B1_C1_D1_a1_b1[5];
		var a0 = a;
		var b0 = b;
		var A = JSBI.BigInt(A1);
		var B = JSBI.BigInt(B1);
		var C = JSBI.BigInt(C1);
		var D = JSBI.BigInt(D1);
		a = JSBI.BigInt(a1);
		b = JSBI.BigInt(b1);
		if (JSBI.notEqual(b1, JSBI.BigInt(0))) {
			var $tmpA1_B1_g = smallgcdext(a, b);
			var A1 = $tmpA1_B1_g[0];
			var B1 = $tmpA1_B1_g[1];
			var g = $tmpA1_B1_g[2];
			a = JSBI.asUintN(64, g);
			b = JSBI.BigInt(0);
			B = JSBI.add(JSBI.multiply(A1, B), JSBI.multiply(B1, D));
			if (!USE_HALF_EXTENDED) {
				A = JSBI.add(JSBI.multiply(A1, A), JSBI.multiply(B1, C));
			}
		}
		if (USE_HALF_EXTENDED) {

			A = JSBI.equal(a0, JSBI.BigInt(0)) ? JSBI.BigInt(0) : JSBI.divide(JSBI.subtract(a, JSBI.multiply(B, b0)), a0);
		}

		return [A, B, a];
	}

	function gcd(a, b) {
		return LehmersGCD(JSBI.BigInt(a), JSBI.BigInt(b));
	}

	function gcdext(a, b) {
		return LehmersGCDExt(JSBI.BigInt(a), JSBI.BigInt(b));
	}

	function invmod(a, m) {
		var $tmpA_B_C_D_a1_b1 = halfgcd(m, a, true, false);
		var A = $tmpA_B_C_D_a1_b1[0];
		var B = $tmpA_B_C_D_a1_b1[1];
		var C = $tmpA_B_C_D_a1_b1[2];
		var D = $tmpA_B_C_D_a1_b1[3];
		var a1 = $tmpA_B_C_D_a1_b1[4];
		var b1 = $tmpA_B_C_D_a1_b1[5];
		if (JSBI.notEqual(JSBI.BigInt(b1), JSBI.BigInt(0))) {
			var $tmpA1_B1_g = smallgcdext(a1, b1);
			var A1 = $tmpA1_B1_g[0];
			var B1 = $tmpA1_B1_g[1];
			var g = $tmpA1_B1_g[2];
			if (JSBI.notEqual(JSBI.asUintN(64, g), JSBI.BigInt(1))) {
				return JSBI.BigInt(0);
			}
			var B2 = JSBI.add(JSBI.multiply(A1, JSBI.BigInt(B)), JSBI.multiply(B1, JSBI.BigInt(D)));
			if (JSBI.lessThan(B2, JSBI.BigInt(0))) {
				return JSBI.add(B2, m);
			}
			return B2;
		}
		if (JSBI.notEqual(JSBI.BigInt(a1), JSBI.BigInt(1))) {
			return JSBI.BigInt(0);
		}
		var B1 = JSBI.BigInt(B);
		if (JSBI.lessThan(B1, JSBI.BigInt(0))) {
			return JSBI.add(B1, m);
		}
		return B1;
	}

	function halfgcdWrapper(a, b) {

		return halfgcd(a, b, true, true, true);
	}

	self.gcd = gcd;
	gcd.halfgcd = halfgcdWrapper;
	gcd.gcdext = gcdext;
	gcd.invmod = invmod;
}

function IsPrime64() {
	var isPrime64 = typeof WebAssembly !== 'undefined' ? new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([0, 97, 115, 109, 1, 0, 0, 0, 1, 14, 2, 96, 4, 126, 126, 126, 126, 1, 126, 96, 1, 126, 1, 127, 3, 3, 2, 0, 1, 7, 13, 1, 9, 105, 115, 80, 114, 105, 109, 101, 54, 52, 0, 1, 10, 129, 8, 2, 174, 1, 1, 4, 126, 32, 0, 66, 32, 136, 34, 5, 32, 1, 66, 255, 255, 255, 255, 15, 131, 34, 4, 126, 32, 0, 66, 255, 255, 255, 255, 15, 131, 34, 6, 32, 4, 126, 66, 32, 136, 124, 33, 7, 32, 1, 66, 32, 136, 34, 4, 32, 5, 126, 32, 7, 66, 32, 136, 124, 32, 4, 32, 6, 126, 32, 7, 66, 255, 255, 255, 255, 15, 131, 124, 66, 32, 136, 124, 34, 4, 32, 0, 32, 1, 126, 32, 3, 126, 34, 0, 66, 32, 136, 34, 1, 32, 2, 66, 32, 136, 34, 3, 126, 32, 2, 66, 255, 255, 255, 255, 15, 131, 34, 5, 32, 1, 126, 32, 0, 66, 255, 255, 255, 255, 15, 131, 34, 0, 32, 5, 126, 66, 32, 136, 124, 34, 1, 66, 32, 136, 124, 32, 0, 32, 3, 126, 32, 1, 66, 255, 255, 255, 255, 15, 131, 124, 66, 32, 136, 124, 34, 0, 125, 32, 2, 66, 0, 32, 0, 32, 4, 86, 27, 124, 11, 206, 6, 2, 11, 126, 1, 127, 32, 0, 66, 2, 84, 4, 64, 65, 0, 15, 11, 32, 0, 66, 1, 131, 80, 4, 64, 32, 0, 66, 2, 81, 15, 11, 32, 0, 66, 3, 130, 80, 4, 64, 32, 0, 66, 3, 81, 15, 11, 32, 0, 66, 5, 130, 80, 4, 64, 32, 0, 66, 5, 81, 15, 11, 32, 0, 66, 7, 130, 80, 4, 64, 32, 0, 66, 7, 81, 15, 11, 32, 0, 66, 11, 130, 80, 4, 64, 32, 0, 66, 11, 81, 15, 11, 32, 0, 66, 13, 130, 80, 4, 64, 32, 0, 66, 13, 81, 15, 11, 32, 0, 66, 17, 130, 80, 4, 64, 32, 0, 66, 17, 81, 15, 11, 32, 0, 66, 19, 130, 80, 4, 64, 32, 0, 66, 19, 81, 15, 11, 32, 0, 66, 23, 130, 80, 4, 64, 32, 0, 66, 23, 81, 15, 11, 32, 0, 66, 29, 130, 80, 4, 64, 32, 0, 66, 29, 81, 15, 11, 32, 0, 66, 31, 130, 80, 4, 64, 32, 0, 66, 31, 81, 15, 11, 32, 0, 66, 217, 10, 84, 4, 64, 65, 1, 15, 11, 32, 0, 66, 1, 125, 34, 1, 122, 33, 7, 32, 1, 32, 7, 136, 33, 4, 32, 0, 33, 1, 65, 2, 33, 12, 3, 64, 32, 12, 65, 192, 0, 72, 4, 64, 32, 1, 66, 2, 32, 0, 32, 1, 126, 125, 126, 33, 1, 32, 12, 32, 12, 106, 33, 12, 12, 1, 11, 11, 32, 1, 33, 5, 66, 1, 33, 3, 66, 127, 32, 0, 130, 66, 1, 124, 33, 1, 3, 64, 32, 3, 66, 0, 82, 4, 64, 32, 3, 66, 1, 131, 167, 4, 64, 32, 2, 32, 0, 32, 1, 125, 34, 6, 125, 32, 0, 66, 0, 32, 2, 32, 6, 84, 27, 124, 33, 2, 11, 32, 1, 32, 0, 32, 1, 125, 34, 6, 125, 32, 0, 66, 0, 32, 1, 32, 6, 84, 27, 124, 33, 1, 32, 3, 66, 1, 136, 33, 3, 12, 1, 11, 11, 2, 126, 66, 4, 32, 0, 66, 255, 15, 84, 13, 0, 26, 66, 12, 32, 0, 66, 213, 235, 211, 0, 84, 13, 0, 26, 66, 44, 32, 0, 66, 177, 227, 137, 12, 84, 13, 0, 26, 66, 172, 1, 32, 0, 66, 199, 251, 133, 253, 11, 84, 13, 0, 26, 66, 172, 17, 32, 0, 66, 187, 220, 255, 249, 209, 62, 84, 13, 0, 26, 66, 172, 209, 0, 32, 0, 66, 223, 185, 224, 185, 144, 229, 0, 84, 13, 0, 26, 66, 172, 209, 8, 32, 0, 66, 193, 145, 203, 149, 181, 212, 205, 0, 84, 34, 12, 13, 0, 26, 66, 172, 209, 40, 32, 12, 13, 0, 26, 66, 172, 209, 168, 4, 32, 0, 66, 251, 243, 235, 252, 244, 164, 228, 138, 53, 84, 13, 0, 26, 66, 172, 209, 168, 132, 138, 4, 11, 33, 9, 3, 64, 32, 9, 66, 0, 82, 4, 64, 32, 9, 66, 1, 32, 9, 122, 34, 3, 134, 133, 33, 9, 66, 0, 33, 1, 66, 127, 32, 0, 130, 66, 1, 124, 33, 6, 3, 64, 32, 3, 66, 0, 82, 4, 64, 32, 3, 66, 1, 131, 167, 4, 64, 32, 1, 32, 0, 32, 6, 125, 34, 8, 125, 32, 0, 66, 0, 32, 1, 32, 8, 84, 27, 124, 33, 1, 11, 32, 6, 32, 0, 32, 6, 125, 34, 8, 125, 32, 0, 66, 0, 32, 6, 32, 8, 84, 27, 124, 33, 6, 32, 3, 66, 1, 136, 33, 3, 12, 1, 11, 11, 32, 1, 33, 3, 32, 4, 33, 6, 66, 0, 33, 1, 66, 1, 33, 8, 66, 127, 32, 0, 130, 66, 1, 124, 33, 10, 3, 64, 32, 8, 66, 0, 82, 4, 64, 32, 8, 66, 1, 131, 167, 4, 64, 32, 1, 32, 0, 32, 10, 125, 34, 11, 125, 32, 0, 66, 0, 32, 1, 32, 11, 84, 27, 124, 33, 1, 11, 32, 10, 32, 0, 32, 10, 125, 34, 11, 125, 32, 0, 66, 0, 32, 10, 32, 11, 84, 27, 124, 33, 10, 32, 8, 66, 1, 136, 33, 8, 12, 1, 11, 11, 3, 64, 32, 6, 66, 0, 82, 4, 64, 32, 6, 66, 1, 131, 167, 4, 64, 32, 1, 32, 3, 32, 0, 32, 5, 16, 0, 33, 1, 11, 32, 6, 66, 1, 136, 33, 6, 32, 3, 32, 3, 32, 0, 32, 5, 16, 0, 33, 3, 12, 1, 11, 11, 66, 0, 33, 3, 65, 0, 33, 12, 3, 64, 32, 12, 172, 32, 7, 83, 4, 64, 32, 1, 32, 1, 32, 0, 32, 5, 16, 0, 34, 3, 32, 2, 81, 32, 1, 32, 2, 82, 113, 32, 1, 32, 0, 32, 2, 125, 82, 113, 4, 64, 65, 0, 15, 11, 32, 3, 33, 1, 32, 12, 65, 1, 106, 33, 12, 12, 1, 11, 11, 32, 2, 32, 3, 82, 4, 64, 65, 0, 15, 11, 12, 1, 11, 11, 65, 1, 11]))).exports.isPrime64 : null;
	self.isPrime64 = isPrime64;
}

function Prime() {
	function log2(x) {
		return JSBI.BigInt(x.toString(16).length * 4);
	}

	function modPow(base, exponent, modulus) {

		var e = exponent.toString(2);
		var accumulator = JSBI.BigInt(1);
		for (var i = 0; i < e.length; i += 1) {
			accumulator = JSBI.remainder(JSBI.multiply(accumulator, accumulator), modulus);
			if (+e.charCodeAt(i) !== +'0'.charCodeAt(0)) {
				accumulator = JSBI.remainder(JSBI.multiply(accumulator, base), modulus);
			}
		}
		return accumulator;
	}

	function primes(MAX) {
		var sieve = new Array(MAX + 1).fill(true);
		var result = [];
		result.push(2);
		for (var i = 3; i <= MAX; i += 2) {
			if (sieve[i]) {
				result.push(i);
				if (i <= Math.floor(MAX / i)) {
					for (var j = i * i; j <= MAX; j += 2 * i) {
						sieve[j] = false;
					}
				}
			}
		}
		return result;
	}

	function getBases(n) {

		if (!(n instanceof JSBI)) {
			throw new TypeError();
		}
		if (JSBI.lessThan(n, JSBI.BigInt(2047))) {
			return [2];
		}
		if (JSBI.lessThan(n, JSBI.BigInt(1373653))) {
			return [2, 3];
		}
		if (JSBI.lessThan(n, JSBI.BigInt(25326001))) {
			return [2, 3, 5];
		}
		if (JSBI.lessThan(n, JSBI.BigInt(3215031751))) {
			return [2, 3, 5, 7];
		}
		if (JSBI.lessThan(n, JSBI.BigInt(2152302898747))) {
			return [2, 3, 5, 7, 11];
		}
		if (JSBI.lessThan(n, JSBI.BigInt(3474749660383))) {
			return [2, 3, 5, 7, 11, 13];
		}
		if (JSBI.lessThan(n, JSBI.BigInt(341550071728321))) {
			return [2, 3, 5, 7, 11, 13, 17];
		}
		if (JSBI.lessThan(n, JSBI.BigInt("3825123056546413051"))) {
			return [2, 3, 5, 7, 11, 13, 17, 19, 23];
		}
		if (JSBI.lessThan(n, JSBI.BigInt("318665857834031151167461"))) {
			return [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37];
		}
		if (JSBI.lessThan(n, JSBI.BigInt("3317044064679887385961981"))) {
			return [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41];
		}

		var lnN = JSBI.toNumber(log2(n)) * Math.log(2);
		return primes(Math.floor(1 / Math.log(2) * lnN * Math.log(lnN)));
	}

	function isPrime(n) {
		if (!(n instanceof JSBI)) {
			throw new RangeError();
		}
		if (JSBI.lessThan(n, JSBI.BigInt(0))) {
			throw new RangeError();
		}
		if (JSBI.lessThan(n, JSBI.BigInt(2))) {
			return false;
		}
		var smallPrimes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41];
		var s = JSBI.toNumber(JSBI.remainder(n, JSBI.BigInt(304250263527210)));
		for (var i = 0; i < smallPrimes.length; i += 1) {
			var p = smallPrimes[i];
			if (s - Math.floor(s / p) * p === 0) {
				return JSBI.equal(n, JSBI.BigInt(p));
			}
		}
		if (n < 43 * 43) {
			return true;
		}

		var r = 0;
		var d = JSBI.subtract(n, JSBI.BigInt(1));
		while (JSBI.equal(JSBI.remainder(d, JSBI.BigInt(2)), JSBI.BigInt(0))) {
			d = JSBI.divide(d, JSBI.BigInt(2));
			r += 1;
		}
		var bases = getBases(n);
		for (var iteratora = bases[globalThis.Symbol.iterator](), a = iteratora.next().value; a != null; a = iteratora.next().value) {
			var x = modPow(JSBI.BigInt(a), d, n);
			if (JSBI.notEqual(x, JSBI.BigInt(1))) {
				for (var i = r - 1; i > 0 && JSBI.notEqual(x, JSBI.subtract(n, JSBI.BigInt(1))); i -= 1) {
					x = JSBI.remainder(JSBI.multiply(x, x), n);
				}
				if (JSBI.notEqual(x, JSBI.subtract(n, JSBI.BigInt(1)))) {

					return false;
				}
			}
		}
		return true;
	}

	self.isPrime = isPrime;
};

function PollardsRho() {
	var PollardsRho64 = typeof WebAssembly !== 'undefined' ? new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([0, 97, 115, 109, 1, 0, 0, 0, 1, 28, 4, 96, 2, 126, 126, 1, 126, 96, 4, 126, 126, 126, 126, 1, 126, 96, 3, 126, 126, 127, 1, 126, 96, 2, 126, 127, 1, 126, 3, 5, 4, 0, 1, 2, 3, 7, 29, 2, 9, 103, 99, 100, 66, 105, 110, 97, 114, 121, 0, 0, 13, 80, 111, 108, 108, 97, 114, 100, 115, 82, 104, 111, 54, 52, 0, 3, 10, 246, 6, 4, 98, 2, 2, 126, 1, 127, 32, 0, 80, 4, 64, 32, 1, 15, 11, 32, 1, 80, 4, 64, 32, 0, 15, 11, 32, 0, 32, 1, 132, 122, 33, 3, 32, 0, 32, 0, 122, 136, 33, 0, 32, 1, 32, 1, 122, 136, 33, 1, 3, 64, 32, 1, 32, 0, 125, 32, 0, 32, 1, 125, 32, 0, 32, 1, 84, 34, 4, 27, 33, 2, 32, 0, 32, 1, 32, 4, 27, 33, 1, 32, 2, 32, 2, 122, 136, 34, 0, 66, 0, 82, 13, 0, 11, 32, 1, 32, 3, 134, 11, 174, 1, 1, 4, 126, 32, 0, 66, 32, 136, 34, 5, 32, 1, 66, 255, 255, 255, 255, 15, 131, 34, 4, 126, 32, 0, 66, 255, 255, 255, 255, 15, 131, 34, 6, 32, 4, 126, 66, 32, 136, 124, 33, 7, 32, 1, 66, 32, 136, 34, 4, 32, 5, 126, 32, 7, 66, 32, 136, 124, 32, 4, 32, 6, 126, 32, 7, 66, 255, 255, 255, 255, 15, 131, 124, 66, 32, 136, 124, 34, 4, 32, 0, 32, 1, 126, 32, 3, 126, 34, 0, 66, 32, 136, 34, 1, 32, 2, 66, 32, 136, 34, 3, 126, 32, 2, 66, 255, 255, 255, 255, 15, 131, 34, 5, 32, 1, 126, 32, 0, 66, 255, 255, 255, 255, 15, 131, 34, 0, 32, 5, 126, 66, 32, 136, 124, 34, 1, 66, 32, 136, 124, 32, 0, 32, 3, 126, 32, 1, 66, 255, 255, 255, 255, 15, 131, 124, 66, 32, 136, 124, 34, 0, 125, 32, 2, 66, 0, 32, 0, 32, 4, 86, 27, 124, 11, 160, 4, 2, 8, 126, 5, 127, 32, 0, 33, 4, 65, 2, 33, 13, 3, 64, 32, 13, 65, 192, 0, 72, 4, 64, 32, 4, 66, 2, 32, 0, 32, 4, 126, 125, 126, 33, 4, 32, 13, 32, 13, 106, 33, 13, 12, 1, 11, 11, 32, 4, 33, 6, 66, 2, 33, 7, 66, 127, 32, 0, 130, 66, 1, 124, 33, 4, 3, 64, 32, 7, 66, 0, 82, 4, 64, 32, 7, 66, 1, 131, 167, 4, 64, 32, 3, 32, 0, 32, 4, 125, 34, 8, 125, 32, 0, 66, 0, 32, 3, 32, 8, 84, 27, 124, 33, 3, 11, 32, 4, 32, 0, 32, 4, 125, 34, 8, 125, 32, 0, 66, 0, 32, 4, 32, 8, 84, 27, 124, 33, 4, 32, 7, 66, 1, 136, 33, 7, 12, 1, 11, 11, 66, 127, 32, 0, 130, 66, 1, 124, 33, 7, 3, 64, 32, 1, 66, 0, 82, 4, 64, 32, 1, 66, 1, 131, 167, 4, 64, 32, 5, 32, 0, 32, 7, 125, 34, 4, 125, 32, 0, 66, 0, 32, 4, 32, 5, 86, 27, 124, 33, 5, 11, 32, 7, 32, 0, 32, 7, 125, 34, 4, 125, 32, 0, 66, 0, 32, 4, 32, 7, 86, 27, 124, 33, 7, 32, 1, 66, 1, 136, 33, 1, 12, 1, 11, 11, 65, 1, 33, 13, 66, 1, 33, 4, 32, 3, 33, 1, 3, 64, 32, 2, 32, 11, 79, 4, 64, 32, 1, 33, 7, 3, 64, 32, 1, 32, 1, 32, 0, 32, 6, 16, 1, 34, 1, 32, 0, 32, 5, 125, 34, 8, 125, 32, 0, 66, 0, 32, 1, 32, 8, 84, 27, 124, 33, 1, 32, 11, 65, 1, 106, 34, 11, 32, 13, 65, 3, 108, 65, 2, 118, 77, 4, 126, 66, 1, 33, 4, 32, 11, 33, 12, 32, 1, 5, 32, 7, 32, 1, 125, 32, 1, 32, 7, 125, 32, 1, 32, 7, 84, 27, 33, 8, 32, 4, 66, 1, 81, 4, 126, 32, 8, 5, 32, 4, 32, 8, 32, 0, 32, 6, 16, 1, 11, 33, 4, 32, 11, 65, 255, 0, 113, 69, 32, 11, 32, 13, 70, 114, 32, 14, 114, 4, 126, 2, 126, 32, 0, 32, 4, 80, 13, 0, 26, 32, 4, 32, 0, 80, 13, 0, 26, 32, 0, 32, 4, 132, 122, 33, 9, 32, 4, 32, 4, 122, 136, 33, 8, 32, 0, 32, 0, 122, 136, 33, 4, 3, 64, 32, 4, 32, 8, 125, 32, 8, 32, 4, 125, 32, 4, 32, 8, 86, 34, 15, 27, 33, 10, 32, 8, 32, 4, 32, 15, 27, 33, 4, 32, 10, 32, 10, 122, 136, 34, 8, 66, 0, 82, 13, 0, 11, 32, 4, 32, 9, 134, 11, 34, 4, 66, 1, 82, 4, 64, 32, 0, 32, 4, 82, 4, 64, 32, 4, 15, 11, 32, 14, 4, 64, 32, 0, 15, 11, 65, 1, 33, 14, 32, 12, 33, 11, 32, 3, 33, 1, 11, 66, 1, 33, 4, 32, 11, 33, 12, 32, 1, 5, 32, 3, 11, 11, 33, 3, 32, 11, 32, 13, 71, 13, 0, 11, 32, 13, 65, 1, 116, 33, 13, 12, 1, 11, 11, 66, 0, 11, 63, 1, 2, 126, 32, 0, 66, 2, 88, 4, 64, 66, 0, 15, 11, 32, 0, 66, 1, 131, 80, 4, 64, 66, 2, 15, 11, 3, 64, 32, 2, 66, 1, 124, 34, 2, 66, 42, 86, 4, 64, 66, 0, 15, 11, 32, 0, 32, 2, 32, 1, 16, 2, 34, 3, 32, 0, 81, 13, 0, 11, 32, 3, 11]))).exports.PollardsRho64 : null;
	self.PollardsRho64 = PollardsRho64;
}

function BitSetSparseSolver() {
	function packedArray(n) {

		var array = [];
		for (var i = 0; i < n; i++) {
			array.push(0);
		}
		return array.slice(0);
	}

	function BitSet(size) {
		var n = Math.ceil(size / (8 * 32)) * 8;
		this.data = new Uint32Array(n);
		this.data64 = new BigUint64Array(this.data.buffer);
		this.size = size;
	}

	BitSet.prototype.nextSetBit = function (index) {
		if ((index | 0) >= (this.size | 0)) {
			return -1;
		}
		var data = this.data;
		var q = index >> 5;
		var r = index & 31;
		while ((data[q] >> r) === 0) {
			q += 1;
			if (q === data.length) {
				return -1;
			}
			r = 0;
		}

		r += 31 - Math.clz32((data[q] >> r) & -(data[q] >> r));
		return (q * 32) + r;
	};
	BitSet.prototype.toggle = function (index) {
		if ((index | 0) >= (this.size | 0)) {
			throw new RangeError();
		}
		this.data[index >> 5] ^= (1 << (index & 31));
	};
	BitSet.prototype.xor = function (other) {
		var a = this.data64;
		var b = other.data64;
		var n = a.length | 0;
		if (n !== b.length || n % 2 !== 0) {
			throw new RangeError();
		}
		for (var i = 0; i < n; i += 2) {
			a[i + 0] ^= b[i + 0];
			a[i + 1] ^= b[i + 1];
		}
	};
	BitSet.prototype.clear = function () {
		for (var i = 0; i < this.data.length; i += 1) {
			this.data[i] = 0;
		}
	};
	BitSet.prototype.toString = function () {
		return this.data.map(function (x) {
			return (x >>> 0).toString(2).padStart(32, '0').split('').reverse().join('');
		}).join('').slice(0, this.size);
	};

	function solve(matrixSize, bitsetRows) {
		bitsetRows = bitsetRows == undefined ? false : bitsetRows;

		var M = new Array(matrixSize).fill(null);
		var associatedValues = new Array(matrixSize).fill(undefined);
		var nextSolution = null;
		var state = 1;
		var iterator = {
			next: function solve(rawRowAndValue) {
				while (true) {
					if (state === 1) {
						state = 0;
						return {
							value: nextSolution,
							done: false
						};
					}
					state = 1;
					var rawRow = rawRowAndValue[0];
					var associatedValue = rawRowAndValue[1];
					var row = null;
					if (bitsetRows) {
						row = rawRow;
					} else {
						row = new BitSet(matrixSize);
						var reverseColumns = true;
						for (var j = 0; j < rawRow.length; j++) {
							var unitaryColumn = rawRow[j];
							var c = reverseColumns ? matrixSize - 1 - unitaryColumn : unitaryColumn;
							row.toggle(c);
						}
					}

					for (var pivotColumn = row.nextSetBit(0); pivotColumn !== -1 && row != null; pivotColumn = row == null ? -1 : row.nextSetBit(pivotColumn + 1)) {
						var pivotRow = M[pivotColumn];
						if (pivotRow != null) {

							row.xor(pivotRow);

							row.toggle(pivotColumn);
						} else {

							associatedValues[pivotColumn] = associatedValue;
							M[pivotColumn] = row;
							row = null;
						}
					}
					if (row != null) {

						var solution = [];
						for (var i = row.nextSetBit(0); i !== -1; i = row.nextSetBit(i + 1)) {
							solution.push(associatedValues[i]);
						}
						solution.push(associatedValue);
						nextSolution = solution;
					} else {
						nextSolution = null;
					}
				}

			}
		};
		iterator[globalThis.Symbol.iterator] = function () {
			return this;
		};
		return iterator;
	}

	function SparseGF2Matrix(n, m) {
		this.rows = new Array(n).fill(null);
		this.columns = new Array(m).fill(null).map(function (x) {
			return [];
		});
	}

	SparseGF2Matrix.prototype.addRow = function (rawRow, rowIndex) {

		function removePairs(rawRow) {
			var row = rawRow.slice(0);
			row.sort(function (a, b) {
				return a - b;
			});
			var k = -1;
			for (var i = 0; i < row.length; i++) {
				if (i === 0 || row[k] !== row[i]) {
					k += 1;
					row[k] = row[i];
				} else {
					k -= 1;
				}
			}
			return row.slice(0, k + 1);
		}

		var row = removePairs(rawRow);

		this.rows[rowIndex] = row;
		for (var i = 0; i < row.length; i++) {
			this.columns[row[i]].push(rowIndex);
		}
	};
	SparseGF2Matrix.prototype.deleteColumn = function (columnIndex) {
		var column = this.columns[columnIndex];
		if (column != null) {
			for (var i = 0; i < column.length; i++) {
				var rowIndex = column[i];
				var k = this.rows[rowIndex].indexOf(columnIndex);
				console.assert(k !== -1);
				this.rows[rowIndex].splice(k, 1);
			}
			this.columns[columnIndex] = null;
		}
	};

	SparseGF2Matrix.prototype.deleteRow = function (rowIndex) {
		var row = this.rows[rowIndex];
		if (row != null) {
			for (var i = 0; i < row.length; i++) {
				var columnIndex = row[i];
				this.columns[columnIndex] = this.columns[columnIndex].filter(function (r) {
					return r != rowIndex;
				});
			}
			this.rows[rowIndex] = null;
		}
	};

	SparseGF2Matrix.prototype.reduce = function (rowIndex, xors) {
		var row = this.rows[rowIndex];
		console.assert(row.length === 1);
		var e = row[0];
		var column = this.columns[e];
		for (var i = column.length - 1; i >= 0; i--) {
			if (column[i] !== rowIndex) {
				var j = column[i];
				var a = this.rows[j];
				var k = a.indexOf(e);
				console.assert(k !== -1);
				a.splice(k, 1);
				column.splice(i, 1);
				xors.push({
					a: j,
					b: rowIndex
				});
			}
		}
		console.assert(column.length === 1 && column[0] === rowIndex);
		this.columns[e] = null;
		this.rows[rowIndex] = null;
	};

	function sparseSolve(columnsCount) {
		if (columnsCount < 1024 * 2) {
			return solve(columnsCount);
		}

		function getKthLargest(array, k) {
			array.sort(function (a, b) {
				return a - b;
			});
			return array[Math.max(array.length - k, 0)];
		}

		function deleteNonSparseColumns(sparseMatrix, count) {
			var counts = sparseMatrix.columns.map(function (c) {
				return c == null ? 0 : c.length;
			});
			var t = getKthLargest(counts, count);
			for (var i = 0; i < sparseMatrix.columns.length; i++) {
				var column = sparseMatrix.columns[i];
				if (column != null && column.length >= t) {
					sparseMatrix.deleteColumn(i);
				}
			}
		}

		function eliminateRowsWithSingleColumn(sparseMatrix, eliminatedColumns) {
			var rows = [];
			for (var i = 0; i < sparseMatrix.rows.length; i++) {
				var row = sparseMatrix.rows[i];
				if (row != null && row.length === 1) {
					rows.push(i);
				}
			}
			for (var i = 0; i < rows.length; i++) {
				var rowIndex = rows[i];
				var row = sparseMatrix.rows[rowIndex];
				if (row != null && row.length === 1) {
					sparseMatrix.reduce(rowIndex, xors);
					eliminatedColumns[row[0]] = true;
				} else {
					console.assert(row != null && row.length === 0);
				}
			}
			return rows.length;
		}

		var M = [];
		var data = [];
		var xors = [];
		var newMatrix = null;
		var solutions = null;
		var lastJ = -1;

		function calculateNewMatrix() {
			var FIRST_SPARSE_PRIME_INDEX = 2585;

			var sparseMatrix = new SparseGF2Matrix(M.length, columnsCount);
			for (var i = 0; i < M.length; i++) {
				sparseMatrix.addRow(M[i].filter(function (p) {
					return p >= FIRST_SPARSE_PRIME_INDEX;
				}), i);
			}

			var eliminatedColumns = new Array(columnsCount).fill(false);

			var S = 128;
			var sparseColumns = -1;
			do {
				sparseColumns = sparseMatrix.columns.reduce(function (p, column) {
					return p + (column == null ? 0 : 1);
				}, 0);

				var c = Math.ceil(sparseMatrix.rows.length / S) - eliminateRowsWithSingleColumn(sparseMatrix, eliminatedColumns);
				if (c > 0) {
					deleteNonSparseColumns(sparseMatrix, c);
				}
			} while (sparseColumns > 0);

			var newColumnIds = new Array(columnsCount).fill(0);
			var k = 0;
			for (var i = 0; i < sparseMatrix.columns.length; i++) {
				if (!eliminatedColumns[i]) {
					newColumnIds[i] = k;
					k += 1;
				} else {
					newColumnIds[i] = -1;
				}
			}
			var newColumnsCount = k;

			var pool = [];

			function getNewRow(row) {
				var newRow = null;
				if (pool.length > 0) {
					newRow = pool.pop();
					newRow.clear();
				} else {
					newRow = new BitSet(newColumnsCount);
				}
				for (var j = 0; j < row.length; j++) {
					var e = newColumnIds[row[j]];
					if (e !== -1) {
						newRow.toggle(newColumnsCount - 1 - e);
					}
				}
				return newRow;
			}

			newMatrix = M.map(function (row) {
				return null;
			});
			var lastUsage = sparseMatrix.rows.map(function (row) {
				return (row != null ? 1 / 0 : -1);
			});
			for (var i = xors.length - 1; i >= 0; i -= 1) {
				if (lastUsage[xors[i].a] !== -1) {
					if (lastUsage[xors[i].b] === -1) {
						lastUsage[xors[i].b] = i;
					}
				} else {
					xors[i] = null;
				}
			}
			var newRow = function (i, j) {
				if (newMatrix[i] == null) {
					console.assert(lastUsage[i] >= j);
					newMatrix[i] = getNewRow(M[i]);
				}
				var result = newMatrix[i];
				return result;
			};

			for (var i = 0; i < xors.length; i++) {
				if (xors[i] != null) {
					newRow(xors[i].a, i).xor(newRow(xors[i].b, i));
					if (lastUsage[xors[i].b] <= i) {
						pool.push(newMatrix[xors[i].b]);
						newMatrix[xors[i].b] = null;
					}
				}
			}

			for (var i = 0; i < sparseMatrix.rows.length; i++) {
				if (sparseMatrix.rows[i] != null) {
					console.assert(sparseMatrix.rows[i].length === 0);
					newMatrix[i] = newRow(i, 1 / 0);
				} else {
					newMatrix[i] = null;
				}
			}

			solutions = solve(newColumnsCount, true);
			solutions.next();
		}

		var firstTime = true;
		var iterator = {
			next: function sparseSolve(rawRowAndValue) {
				if (firstTime) {
					firstTime = false;
					return {
						value: null,
						done: false
					};
				}
				if (solutions == null) {
					if (M.length < columnsCount + 32) {
						M.push(rawRowAndValue[0]);
						data.push(rawRowAndValue[1]);
						return {
							value: null,
							done: false
						};
					}
					calculateNewMatrix();
				}
				for (var j = lastJ + 1; j < newMatrix.length; j++) {
					lastJ = j;
					var row = newMatrix[j];
					if (row != null) {
						var solution = solutions.next([row, j]).value;
						if (solution != null) {

							var set = new Array(M.length).fill(0);
							for (var i = 0; i < solution.length; i++) {
								if (set[solution[i]] !== 0) {
									throw new RangeError();
								}
								set[solution[i]] = 1;
							}
							for (var i = xors.length - 1; i >= 0; i--) {
								if (xors[i] != null && set[xors[i].a] === 1) {
									set[xors[i].b] = 1 - set[xors[i].b];
								}
							}

							var newSolution = [];
							for (var i = 0; i < set.length; i++) {
								if (set[i] === 1) {
									newSolution.push(data[i]);
								}
							}

							return {
								value: newSolution,
								done: false
							};
						}
					}
				}
			}
		};
		iterator[globalThis.Symbol.iterator] = function () {
			return this;
		};
		return iterator;
	}

	solve.solve = solve;
	solve.sparseSolve = sparseSolve;
	sparseSolve.solve = solve;
	sparseSolve.sparseSolve = sparseSolve;

	self.solve = solve;
}

function TonelliShanks() {
	function modPowSmall(base, exponent, modulus) {
		var accumulator = 1;
		while (exponent !== 0) {
			if (exponent % 2 === 0) {
				exponent /= 2;
				base = (base * base);
				base = base - Math.floor(base / modulus) * modulus;
			} else {
				exponent -= 1;
				accumulator = (accumulator * base);
				accumulator = accumulator - Math.floor(accumulator / modulus) * modulus;
			}
		}
		return accumulator;
	}

	function legendre(a, n) {
		if (typeof a !== 'number' || typeof n !== 'number') {
			throw new TypeError();
		}

		a = a | 0;
		n = n | 0;

		a = (a | 0) % (n | 0);
		var t = 1;
		var r = 0;

		while (a !== 0) {

			while ((a & 1) === 0) {
				a >>= 1;
				r = n & 7;
				if (r === 3 || r === 5) {
					t = -t;
				}
			}

			r = n;
			n = a;
			a = r;
			if ((a & 3) === 3 && (n & 3) === 3) {
				t = -t;
			}
			a = (a | 0) % (n | 0);
		}
		return n === 1 ? t : 0;
	}

	function sqrtMod(n, p) {

		console.assert(p * p <= Number.MAX_SAFE_INTEGER);
		if (legendre(n, p) !== 1) {

			return -1;
		}
		var q = p - 1;
		var s = 0;
		while (q % 2 === 0) {
			q /= 2;
			s += 1;
		}
		if (s === 1) {
			return modPowSmall(n, (p + 1) / 4, p);
		}
		var z = 2;
		while (z <= p && legendre(z, p) !== -1) {
			z += 1;
		}
		var c = modPowSmall(z, q, p);
		var r = modPowSmall(n, (q + 1) / 2, p);
		var t = modPowSmall(n, q, p);
		var m = s;
		var t2 = 0;
		while ((t - 1) % p !== 0) {
			t2 = (t * t) % p;
			var i = 1;
			while (i <= m && (t2 - 1) % p !== 0) {
				t2 = (t2 * t2) % p;
				i += 1;
			}
			var b = modPowSmall(c, 1 << (m - i - 1), p);
			r = (r * b) % p;
			c = (b * b) % p;
			t = (t * c) % p;
			m = i;
		}
		return r;
	}

	self.sqrtMod = sqrtMod;
}

function QuadraticSieve() {
	function modInverse(a, m) {
		if (typeof a !== 'bigint' || typeof m !== 'bigint') {
			throw new TypeError();
		}
		if (Number(m) <= (Math.pow(2, 30) - 1)) {
			return BigInt(modInverseSmall(Number(a), Number(m)));
		}
		if (a < BigInt(0) || a >= m || m <= BigInt(0)) {
			throw new RangeError();
		}

		var oldR = a;
		var r = m;
		var oldS = BigInt(1);
		var s = BigInt(0);
		while (r !== BigInt(0)) {
			var q = (oldR - oldR % r) / r;
			var newR = oldR - q * r;
			oldR = r;
			r = newR;
			var newS = oldS - q * s;
			oldS = s;
			s = newS;
		}
		if (oldR !== BigInt(1)) {
			return BigInt(0);
		}
		return oldS < BigInt(0) ? oldS + m : oldS;
	}

	function modInverseSmall(a, m) {
		if (typeof a !== 'number' || typeof m !== 'number') {
			throw new TypeError();
		}
		var maxSMI = (~(-1 << 30));
		if (a < 0 || a >= m || m <= 0 || m > maxSMI) {
			throw new RangeError();
		}

		var oldR = a & maxSMI;
		var r = m & maxSMI;
		var oldS = 1;
		var s = 0;
		while (r !== 0) {
			var q = Math.floor(oldR / r);
			var newR = oldR % r;
			oldR = r;
			r = newR;
			var newS = oldS - q * s;
			oldS = s;
			s = newS;
		}
		if (oldR !== 1) {
			return 0;
		}
		return oldS < 0 ? oldS + m : oldS;
	}

	function ChineseRemainderTheorem(r1, r2, m1, m2) {
		if (typeof r1 !== 'bigint' || typeof r2 !== 'bigint' || typeof m1 !== 'bigint' || typeof m2 !== 'bigint') {
			throw new TypeError();
		}

		var c = modInverse(m1 % m2, m2);
		return r1 + (((r2 - r1) * c) % m2) * m1;
	}

	function squareRootsModuloOddPrimesProduct(n, primes, e) {
		e = e == undefined ? 1 : e;

		var result = [];
		result.push(BigInt(0));
		var P = BigInt(1);
		for (var i = 0; i < primes.length; i += 1) {
			var p = BigInt(Math.pow(primes[i], e));
			if (Number(p) > Number.MAX_SAFE_INTEGER) {
				throw new RangeError();
			}
			var x2 = BigInt(squareRootModuloOddPrime(Number(n % p), primes[i], e));
			var result2 = [];
			for (var j = 0; j < result.length; j += 1) {
				var x1 = result[j];
				result2.push(ChineseRemainderTheorem(x1, x2, P, p));
				result2.push(ChineseRemainderTheorem(x1, -x2, P, p));
			}
			P *= p;
			result = result2;
		}
		return result;
	}

	function squareRootsModuloTwo(n, e) {
		e = e == undefined ? 1 : e;

		if (e >= 3) {
			if (n % 8 === 1) {
				var m = Math.pow(2, e);
				var candidate = +squareRootsModuloTwo(n, e - 1)[0];
				var candidate2 = m / 4 - candidate;
				var r = (candidate * candidate) % m !== n % m ? candidate2 : candidate;
				return [r, m / 2 - r, m / 2 + r, m - r];
			}
			return [];
		}
		if (e >= 2) {
			if (n % 4 === 1) {
				return [1, 3];
			}
			return [];
		}
		if (e >= 1) {
			return [1];
		}
		return [];
	}

	function squareRootModuloOddPrime(n, p, e) {
		e = e == undefined ? 1 : e;

		if (typeof n !== 'number' || typeof p !== 'number' || typeof e !== 'number') {
			throw new TypeError();
		}
		var m = Math.pow(p, e);
		if (!(n > 0 && n < m && p > 0 && p % 2 !== 0 && e >= 1 && +n % +p !== 0 && m < Math.floor(Math.sqrt(Number.MAX_SAFE_INTEGER * 4)))) {
			throw new RangeError();
		}

		if (e > 1) {
			var x = squareRootModuloOddPrime(n % Math.pow(p, e - 1), p, e - 1);

			var inv = modInverseSmall(2 * x, m) % m;
			var v = (n - x * x) % m;
			inv = inv > m / 2 ? inv - m : inv;
			v = v > m / 2 ? v - m : v;
			var x1 = x + (v * inv) % m;
			if (x1 >= m) {
				x1 -= m;
			}
			if (x1 < 0) {
				x1 += m;
			}
			return Math.min(x1, m - x1);
		}
		var r = sqrtMod(n, p) | 0;
		return Math.min(r, p - r);
	}

	function bitLength(x) {
		return x.toString(16).length * 4;
	}

	function sqrt(x) {
		if (x < BigInt((Number.MAX_SAFE_INTEGER + 1) / 2)) {
			return BigInt(Math.floor(Math.sqrt(Number(BigInt(x)) + 0.5)));
		}
		var q = BigInt(bitLength(x) >> 2);
		var initialGuess = ((sqrt(x >> (q * BigInt(2))) + BigInt(1)) << q);
		var a = initialGuess;
		var b = a + BigInt(1);
		while (a < b) {
			b = a;
			a = (b + x / b) >> BigInt(1);
		}
		return b;
	}

	function getSmoothFactorization(a, base) {
		var value = BigInt(a);
		if (value === BigInt(0)) {
			return [0];
		}
		var result = [];
		if (value < BigInt(0)) {
			result.push(-1);
			value = -value;
		}
		var i = 0;
		while (i < base.length) {
			var p = base[i];
			while (value % BigInt(p) === BigInt(0)) {
				value /= BigInt(p);
				result.push(p);
			}
			i += 1;
		}
		return value === BigInt(1) ? result : null;
	}

	function CongruenceOfsquareOfXminusYmoduloN(X, Y, N) {
		this.X = X;
		this.Y = Y;
		this.N = N;
	}

	CongruenceOfsquareOfXminusYmoduloN.prototype.toString = function () {
		return 'X**2 ≡ Y (mod N)'.replaceAll('X', this.X)
			.replaceAll('N', this.N)
			.replaceAll('Y', this.Y.join(' * '));
	};

	function isQuadraticResidueModuloPrime(a, p) {
		if (typeof a !== 'bigint' || typeof p !== 'number') {
			throw new TypeError();
		}
		if (p === 2) {

			return true;
		}

		var amodp = Number(BigInt(a) % BigInt(p));
		if (amodp === 0) {
			return true;
		}
		return legendre(amodp, p) === 1;
	}

	function significand(a) {
		var s1 = Number(a);
		if (Math.abs(s1) < 1 / 0) {
			return s1 / Math.pow(2, Math.floor(Math.log2(Math.abs(s1))));
		}
		var e = Math.max(0, bitLength(a) - 1023);
		var s = Number(a >> BigInt(e));
		return s / Math.pow(2, Math.floor(Math.log2(Math.abs(s))));
	}

	function exponent(a) {
		var s1 = Number(a);
		if (Math.abs(s1) < 1 / 0) {
			return Math.floor(Math.log2(Math.abs(s1)));
		}
		var e = Math.max(0, bitLength(a) - 1023);
		var s = Number(a >> BigInt(e));
		return e + Math.floor(Math.log2(Math.abs(s)));
	}

	function log2(a) {
		return Math.log2(significand(a)) + exponent(a);
	}

	function L(N) {
		var lnn = log2(N) * Math.log(2);
		return Math.exp(Math.sqrt(lnn * Math.log(lnn)));
	}

	function modPow(base, exponent, modulus) {
		if (typeof base !== 'bigint' || typeof exponent !== 'bigint' || typeof modulus !== 'bigint') {
			throw new TypeError();
		}
		var e = exponent;
		var b = base;
		var accumulator = BigInt(1);
		while (e !== BigInt(0)) {
			if (BigInt.asUintN(1, e) === BigInt(1)) {
				e -= BigInt(1);
				accumulator = (accumulator * b) % modulus;
			}
			e >>= BigInt(1);
			b = (b * b) % modulus;
		}
		return accumulator;
	}

	function primes(MAX) {

		var sieve = new Array(MAX + 1).fill(true);
		var result = [];
		result.push(2);
		for (var i = 3; i <= MAX; i += 2) {
			if (sieve[i]) {
				result.push(i);
				if (i <= Math.floor(MAX / i)) {
					for (var j = i * i; j <= MAX; j += 2 * i) {
						sieve[j] = false;
					}
				}
			}
		}
		return result;
	}

	function FastModBigInt(a) {
		var array = [];
		while (a !== BigInt(0)) {
			var x = Number(BigInt.asUintN(51, a));
			array.push(x);
			a >>= BigInt(51);
		}
		return new Float64Array(array);
	}

	function FastMod(array, m, mInv) {
		m = -0 + m;
		mInv = -0 + mInv;
		var n = array.length - 1;
		var result = array[n];
		result = result - Math.floor(result * mInv) * m;
		if (n > 0) {
			var x = Math.pow(2, 51) - Math.floor(Math.pow(2, 51) * mInv) * m;
			var i = n;
			do {
				i -= 1;
				result = result * x + array[i];
				result = result - Math.floor(result * mInv) * m;
			} while (i !== 0);
		}
		return -0 + result;
	}

	function exp2(x) {
		var y = Math.floor(Math.pow(2, Math.floor(x)) * Math.exp(Math.LN2 * (x - Math.floor(x))));
		if (y % 2 === 0) {
			y += 1;
		}
		return y;
	}

	var useMultiplePolynomials = true;

	function QuadraticPolynomial(A, B, N, AFactors, useQ2Form) {
		if (typeof A !== 'bigint' || typeof B !== 'bigint' || typeof N !== 'bigint') {
			throw new TypeError();
		}
		var BBmN = (B * B - N);
		if (useQ2Form && N % BigInt(4) !== BigInt(1)) {
			throw new RangeError();
		}
		if (BBmN % ((useQ2Form ? BigInt(4) : BigInt(1)) * A) !== BigInt(0)) {
			throw new TypeError();
		}
		var C = BBmN / (useQ2Form ? BigInt(4) * A : A);
		this.A = A;
		this.B = B;
		this.C = C;
		this.AFactors = AFactors;
		var u = (significand(B) / significand(A)) * Math.pow(2, exponent(B) - exponent(A));
		var v = Math.sqrt(significand(N) / Math.pow(significand(A), 2)) * Math.pow(2, exponent(N) / 2 - exponent(A));
		this.x1 = (useQ2Form ? 1 / 2 : 1) * (-u - v);
		this.x2 = (useQ2Form ? 1 / 2 : 1) * (-u + v);
		this.log2a = log2(A);
		this.useQ2Form = useQ2Form;
	}

	QuadraticPolynomial.generator = function (M, primes, N) {

		var getCombinations = function (elements, k) {
			if (elements.length === 0) {
				return [];
			}
			if (k === 0) {
				return [[]];
			}
			if (k === 1) {
				return elements.map(function (e) {
					return [e];
				});
			}
			return getCombinations(elements.slice(1), k - 1).map(function (c) {
				return [elements[0]].concat(c);
			}).concat(getCombinations(elements.slice(1), k));
		};
		var nthRootApprox = function (A, n) {
			return Math.round(Math.pow(significand(A), 1 / n) * Math.pow(2, exponent(A) / n));
		};
		var max = function (a, b) {
			return a < b ? b : a;
		};
		var useQ2Form = N % BigInt(8) === BigInt(1);
		var S = max(BigInt(1), useQ2Form ? BigInt(sqrt(N / BigInt(2))) / BigInt(M) : BigInt(sqrt(BigInt(2) * N)) / BigInt(M));
		var e = log2(S);
		var max1 = Math.log2(primes[primes.length - 1]);

		var elementPrimes = 2;
		var k = Math.max(elementPrimes, Math.ceil(e / Math.min(e < 180 ? 14.5 : max1, max1) / elementPrimes) * elementPrimes);
		console.debug('k: ', k, 'useQ2Form: ', useQ2Form);
		var p = nthRootApprox(S, k);
		var s = 0;
		var nextPrime = function () {
			var p3 = 0;
			do {
				p3 = p - p % 2 + 1 + (s % 2 === 0 ? s : (-1 - s));
				s += 1;
				if (p + s > primes[primes.length - 1]) {
					if (p - s < primes[0]) {
						throw new RangeError();
					}
				}
			} while (indexOf(primes, p3) === -1);
			return p3;
		};
		var combinations = [];
		var polynomials = [];
		var elements = [];
		QuadraticSieveFactorization.polynomialsCounter = 0;
		return {
			next: function generator() {
				while (polynomials.length === 0) {

					while (combinations.length === 0) {
						var element = [];
						for (var i = 0; i < elementPrimes; i += 1) {
							element.push(nextPrime());
						}
						console.assert(k % elementPrimes === 0);
						combinations = getCombinations(elements, k / elementPrimes - 1).map(function (c) {
							return [element].concat(c);
						});
						elements.push(element);

					}
					var qPrimes = combinations.pop().reduce(function (array, pair) {
						return array.concat(pair);
					}, []);

					var q = BigInt(qPrimes.reduce(function (p, a) {
						return p * BigInt(a);
					}, BigInt(1)));
					var qInv = modInverse(q % N, N);
					if (qInv === BigInt(0)) {

						return this.next();
					}
					var A = q;
					var Bs = squareRootsModuloOddPrimesProduct(N, qPrimes, 1);
					for (var i = 0; i < Bs.length; i += 1) {
						Bs[i] = Bs[i] < BigInt(0) ? Bs[i] + A : Bs[i];
						if (Bs[i] < BigInt(0) || Bs[i] >= A) throw new Error();
					}
					if (useQ2Form) {
						Bs = Bs.map(function (B) {
							return B % BigInt(2) === BigInt(0) ? B - A : B;
						});
					}
					Bs = Bs.slice(0, Bs.length / 2);

					var aFactors = useQ2Form ? [2, 2].concat(qPrimes) : qPrimes.slice(0);
					aFactors.sort(function (a, b) {
						return a - b;
					});
					for (var i = 0; i < Bs.length; i += 1) {
						var B = Bs[i];
						polynomials.push(new QuadraticPolynomial(A, B, N, aFactors, useQ2Form));
					}
				}
				QuadraticSieveFactorization.polynomialsCounter += 1;
				return polynomials.shift();
			}
		};
	};
	QuadraticPolynomial.prototype.X = function (x) {
		return (this.A * BigInt((this.useQ2Form ? 2 : 1) * x) + this.B);
	};
	QuadraticPolynomial.prototype.Y = function (x, s, primes) {
		if (typeof x !== 'number') {
			throw new TypeError();
		}
		var Y = this.A * (x * x >= Math.pow(2, 53) ? BigInt(x) * BigInt(x) : BigInt(x * x)) + this.B * BigInt((this.useQ2Form ? 1 : 2) * x) + this.C;
		if (s === undefined && primes === undefined) {
			return Y;
		}
		if (Y % s !== BigInt(0)) {
			return null;
		}
		var YFactors = getSmoothFactorization(Y / s, primes);
		if (YFactors == null) {
			return null;
		}
		if (YFactors.length === 1 && YFactors[0] === 0) {
			return YFactors;
		}
		return this.AFactors.concat(YFactors);
	};
	QuadraticPolynomial.prototype.log2AbsY = function (x) {
		if (typeof x !== 'number') {
			throw new TypeError();
		}

		var v2 = Math.log2(Math.abs((x - this.x1) * (x - this.x2))) + this.log2a;
		return v2;
	};

	function thresholdApproximationInterval(polynomial, x, threshold, sieveSize) {
		var w = sieveSize > 2048 ? (sieveSize > Math.pow(2, 18) ? 1024 : 256) : 1;
		while (w >= 2 && Math.abs(polynomial.log2AbsY(x + w) - threshold) > 0.5) {
			w = Math.floor(w / 2);
		}
		return x + w;
	}

	var wasmCode = typeof Uint8Array !== 'undefined' ? new Uint8Array([0, 97, 115, 109, 1, 0, 0, 0, 1, 28, 3, 96, 8, 127, 127, 127, 127, 127, 127, 127, 127, 1, 127, 96, 2, 127, 127, 1, 127, 96, 6, 127, 127, 127, 127, 127, 127, 0, 2, 15, 1, 3, 101, 110, 118, 6, 109, 101, 109, 111, 114, 121, 2, 0, 0, 3, 5, 4, 0, 1, 2, 0, 7, 85, 4, 16, 115, 105, 110, 103, 108, 101, 66, 108, 111, 99, 107, 83, 105, 101, 118, 101, 0, 0, 15, 102, 105, 110, 100, 83, 109, 111, 111, 116, 104, 69, 110, 116, 114, 121, 0, 1, 24, 117, 112, 100, 97, 116, 101, 87, 104, 101, 101, 108, 115, 73, 110, 116, 101, 114, 110, 97, 108, 78, 101, 120, 116, 0, 2, 17, 104, 97, 110, 100, 108, 101, 83, 109, 97, 108, 108, 87, 104, 101, 101, 108, 115, 0, 3, 10, 154, 8, 4, 226, 1, 1, 4, 127, 32, 2, 32, 5, 106, 33, 8, 32, 0, 32, 4, 106, 33, 0, 32, 1, 32, 4, 106, 33, 1, 32, 2, 32, 4, 106, 33, 2, 32, 3, 32, 4, 65, 2, 117, 106, 33, 3, 3, 64, 32, 2, 32, 8, 71, 4, 64, 32, 0, 40, 2, 0, 33, 5, 32, 1, 40, 2, 0, 33, 4, 32, 2, 40, 2, 0, 33, 10, 32, 3, 45, 0, 0, 33, 11, 3, 64, 32, 4, 32, 6, 72, 4, 64, 32, 4, 45, 0, 0, 32, 11, 106, 33, 9, 32, 5, 32, 5, 45, 0, 0, 32, 11, 106, 58, 0, 0, 32, 4, 32, 9, 58, 0, 0, 32, 5, 32, 10, 106, 33, 5, 32, 4, 32, 10, 106, 33, 4, 12, 1, 11, 11, 32, 5, 32, 6, 72, 4, 64, 32, 5, 32, 5, 45, 0, 0, 32, 11, 106, 58, 0, 0, 32, 5, 32, 10, 106, 33, 9, 32, 4, 33, 5, 32, 9, 33, 4, 11, 32, 0, 32, 5, 32, 7, 107, 54, 2, 0, 32, 1, 32, 4, 32, 7, 107, 54, 2, 0, 32, 0, 65, 4, 106, 33, 0, 32, 1, 65, 4, 106, 33, 1, 32, 2, 65, 4, 106, 33, 2, 32, 3, 65, 1, 106, 33, 3, 12, 1, 11, 11, 65, 0, 11, 42, 1, 1, 123, 32, 0, 253, 15, 33, 2, 32, 1, 65, 16, 107, 33, 1, 3, 64, 32, 1, 65, 16, 106, 34, 1, 253, 0, 4, 0, 32, 2, 253, 44, 253, 100, 69, 13, 0, 11, 32, 1, 11, 173, 1, 2, 5, 123, 1, 127, 32, 5, 253, 17, 33, 6, 3, 64, 32, 11, 32, 0, 65, 2, 116, 72, 4, 64, 32, 3, 32, 3, 253, 0, 4, 0, 34, 8, 32, 1, 253, 0, 4, 0, 34, 7, 32, 6, 253, 177, 1, 32, 7, 32, 6, 253, 55, 32, 2, 253, 0, 4, 0, 34, 9, 253, 78, 253, 174, 1, 34, 7, 253, 177, 1, 32, 8, 32, 7, 253, 57, 32, 9, 253, 78, 253, 174, 1, 34, 8, 32, 4, 253, 0, 4, 0, 34, 10, 32, 7, 253, 177, 1, 32, 10, 32, 7, 253, 57, 32, 9, 253, 78, 253, 174, 1, 34, 7, 253, 182, 1, 253, 11, 4, 0, 32, 4, 32, 8, 32, 7, 253, 184, 1, 253, 11, 4, 0, 32, 1, 65, 16, 106, 33, 1, 32, 2, 65, 16, 106, 33, 2, 32, 3, 65, 16, 106, 33, 3, 32, 4, 65, 16, 106, 33, 4, 32, 11, 65, 16, 106, 33, 11, 12, 1, 11, 11, 11, 217, 4, 2, 10, 127, 5, 123, 32, 6, 32, 7, 70, 4, 64, 0, 11, 32, 5, 33, 8, 3, 64, 32, 13, 32, 0, 65, 2, 116, 72, 4, 64, 32, 1, 253, 0, 4, 0, 65, 16, 253, 171, 1, 65, 16, 253, 173, 1, 32, 1, 253, 0, 4, 16, 65, 16, 253, 171, 1, 253, 80, 33, 20, 32, 2, 253, 0, 4, 0, 65, 16, 253, 171, 1, 65, 16, 253, 173, 1, 32, 2, 253, 0, 4, 16, 65, 16, 253, 171, 1, 253, 80, 33, 21, 32, 3, 253, 0, 4, 0, 65, 16, 253, 171, 1, 65, 16, 253, 173, 1, 32, 3, 253, 0, 4, 16, 65, 16, 253, 171, 1, 253, 80, 33, 19, 32, 4, 253, 0, 4, 0, 65, 16, 253, 171, 1, 65, 16, 253, 173, 1, 32, 4, 253, 0, 4, 16, 65, 16, 253, 171, 1, 253, 80, 33, 22, 32, 6, 65, 4, 107, 33, 10, 253, 12, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 33, 18, 3, 64, 32, 18, 32, 20, 32, 10, 65, 4, 106, 34, 10, 253, 8, 1, 0, 34, 18, 253, 145, 1, 32, 19, 253, 149, 1, 32, 21, 32, 18, 253, 145, 1, 32, 19, 253, 149, 1, 253, 151, 1, 253, 151, 1, 33, 18, 32, 7, 32, 10, 74, 13, 0, 11, 32, 18, 32, 22, 253, 52, 253, 100, 4, 64, 32, 6, 33, 10, 3, 64, 32, 7, 32, 10, 74, 4, 64, 32, 20, 32, 10, 253, 8, 1, 0, 34, 18, 253, 145, 1, 32, 19, 253, 149, 1, 32, 21, 32, 18, 253, 145, 1, 32, 19, 253, 149, 1, 253, 151, 1, 32, 22, 253, 52, 253, 100, 34, 11, 4, 64, 65, 0, 33, 9, 3, 64, 32, 11, 65, 3, 32, 11, 104, 34, 12, 116, 115, 33, 11, 32, 9, 65, 1, 32, 12, 65, 1, 118, 34, 9, 65, 1, 113, 65, 2, 116, 32, 9, 65, 1, 117, 114, 116, 115, 33, 9, 32, 11, 13, 0, 11, 32, 9, 33, 11, 32, 10, 40, 2, 0, 33, 14, 3, 64, 32, 11, 104, 34, 9, 65, 2, 116, 33, 15, 32, 11, 65, 1, 32, 9, 116, 115, 33, 11, 32, 4, 32, 15, 106, 40, 2, 0, 34, 12, 32, 3, 32, 15, 106, 40, 2, 0, 34, 9, 32, 2, 32, 15, 106, 40, 2, 0, 34, 16, 32, 14, 107, 108, 79, 32, 12, 32, 9, 32, 1, 32, 15, 106, 40, 2, 0, 34, 17, 32, 14, 107, 108, 79, 114, 65, 0, 65, 1, 32, 16, 32, 17, 27, 27, 4, 64, 32, 8, 65, 2, 116, 32, 13, 32, 15, 106, 65, 2, 117, 34, 12, 54, 2, 0, 32, 8, 65, 1, 106, 65, 2, 116, 32, 10, 32, 6, 107, 65, 2, 117, 34, 9, 54, 2, 0, 32, 8, 65, 2, 106, 33, 8, 32, 16, 32, 17, 70, 4, 64, 32, 8, 65, 2, 116, 32, 12, 54, 2, 0, 32, 8, 65, 1, 106, 65, 2, 116, 32, 9, 54, 2, 0, 32, 8, 65, 2, 106, 33, 8, 11, 11, 32, 11, 13, 0, 11, 11, 32, 10, 65, 4, 106, 33, 10, 12, 1, 11, 11, 11, 32, 1, 65, 32, 106, 33, 1, 32, 2, 65, 32, 106, 33, 2, 32, 3, 65, 32, 106, 33, 3, 32, 4, 65, 32, 106, 33, 4, 32, 13, 65, 32, 106, 33, 13, 12, 1, 11, 11, 32, 8, 32, 5, 107, 11]) : null;

	var wasmModule = null;

	function instantiateWasm(memorySize) {
		if (wasmModule == null) {
			wasmModule = new WebAssembly.Module(wasmCode);
		}
		var pages = Math.ceil(memorySize / Math.pow(2, 16));
		var memory = new WebAssembly.Memory({
			initial: pages,
			maximum: pages
		});
		var buffer = memory.buffer;
		var exports = new WebAssembly.Instance(wasmModule, {env: {memory: memory}}).exports;
		return Object.assign({}, exports, {memory: {buffer: buffer}});
	}

	function congruencesUsingQuadraticSieve(primes, N, sieveSize0) {
		if (typeof N !== 'bigint') {
			throw new TypeError();
		}
		var sieveSize1 = Number(sieveSize0 || 0);
		if (sieveSize1 === 0) {
			sieveSize1 = 3 * Math.pow(2, 14);
			sieveSize1 = Math.min(sieveSize1, Math.ceil(Math.pow(+primes[primes.length - 1], 1.15)));
			sieveSize1 = Math.max(sieveSize1, primes[primes.length - 1] + 1);
			if (Number(N) > Math.pow(2, 285)) {
				sieveSize1 = Math.floor(sieveSize1 / 3.2 / 1.5);
			} else if (Number(N) > Math.pow(2, 240)) {
				sieveSize1 = Math.floor(sieveSize1 / 1.6 / 1.5);
			} else {
				sieveSize1 = Math.floor(sieveSize1 / 1.5);
			}
		}

		var q = Math.ceil(sieveSize1 / (typeof navigator !== 'undefined' && navigator.hardwareConcurrency === 12 ? 2.75 * Math.pow(2, 20) : 6 * Math.pow(2, 20)));
		console.debug('q', q);
		var segmentSize = Math.ceil(Math.ceil(sieveSize1 / q) / Math.pow(2, 15)) * Math.pow(2, 15);
		var sieveSize = segmentSize * q;
		console.debug('sieveSize', sieveSize);

		var SHIFT = 0;
		var MAX = 255;
		var SCALE = Math.pow(2, 0);

		var log2B = Math.log2(primes.length === 0 ? Math.sqrt(2) : +primes[primes.length - 1]);
		var largePrimesThreshold = log2B + Math.min(Math.log2(N < Math.pow(2, 240) ? 50 : (N < Math.pow(2, 285) ? 400 : 1000)), log2B);
		console.debug('largePrimesThreshold', largePrimesThreshold);
		var largePrimes = new Map();

		var doubleLargePrimes = Number(N) > Math.pow(2, 285);
		var doubleLargePrimesThreshold = Math.min(2 * log2B + Math.min(Math.log2(200), log2B), 64);
		if (doubleLargePrimes) {
			console.log('doubleLargePrimesThreshold', doubleLargePrimesThreshold);
		}

		var wheels0 = [];
		for (var i = 0; i < primes.length; i += 1) {
			var p = +primes[i];
			for (var beta = 1, pInBeta = p; pInBeta <= sieveSize || beta === 1; beta += 1, pInBeta *= p) {
				var nmodpInBeta = Number(N % BigInt(pInBeta));
				if (nmodpInBeta % p === 0) {

					if (beta === 1) {
						wheels0.push({
							step: pInBeta,
							p: p,
							root: 0
						});
					}
				} else {
					if (p === 2) {
						var roots = squareRootsModuloTwo(nmodpInBeta, beta);
						for (var j = 0; j < Math.ceil(roots.length / 2); j += 1) {
							wheels0.push({
								step: pInBeta,
								p: p,
								root: roots[j] | 0
							});
						}
					} else {
						var root = squareRootModuloOddPrime(nmodpInBeta, p, beta);
						wheels0.push({
							step: pInBeta,
							p: p,
							root: root | 0
						});
					}
				}
			}
		}
		wheels0.sort(function (a, b) {
			return +a.step - +b.step;
		});
		var realWheels = wheels0.length;
		while (wheels0.length % 16 !== 0) {
			wheels0.push(wheels0.at(-1));
		}
		console.debug('wheels', wheels0.length);
		console.debug('max wheel', wheels0.at(-1).step);

		var wheelLogs0 = new Float64Array(wheels0.length);
		var invCacheKey = BigInt(0);
		var zeroInvs = [];

		var wheelsCount = wheels0.length;
		console.assert(segmentSize % 4 === 0);

		var memorySize = 0;
		memorySize += segmentSize * 1;
		memorySize += wheelsCount * 4;
		memorySize += wheelsCount * 4;
		memorySize += wheelsCount * 4;
		memorySize += wheelsCount * 1;
		memorySize += (16 * 1024) * 4;
		memorySize += wheelsCount * 4;
		memorySize += wheelsCount * 4;
		memorySize += 512 * 4;
		memorySize += 30 * wheelsCount * 4;
		memorySize += wheelsCount * 4;
		memorySize += wheelsCount * 4;

		var exports = instantiateWasm(memorySize);
		var singleBlockSieve = exports.singleBlockSieve;
		var findSmoothEntry = exports.findSmoothEntry;
		var updateWheelsInternalNext = exports.updateWheelsInternalNext;
		var handleSmallWheels = exports.handleSmallWheels;
		var arrayBuffer = exports.memory.buffer;

		var offset = 0;
		var uint8Array = function (length) {
			offset += length;
			return new Uint8Array(arrayBuffer, offset - length, length);
		};
		var int32Array = function (length) {
			offset += length * 4;
			return new Int32Array(arrayBuffer, offset - length * 4, length);
		};

		var SIEVE_SEGMENT = uint8Array(segmentSize);
		var wheelRoots1 = int32Array(wheelsCount);
		var wheelRoots2 = int32Array(wheelsCount);
		var wheelSteps = int32Array(wheelsCount);
		var wheelLogs = uint8Array(wheelsCount);
		var storage = int32Array(16 * 1024);
		var wheelRoots = int32Array(wheelsCount);
		var invCache = int32Array(wheelsCount);
		var smoothEntriesX = int32Array(512);
		var alpha = int32Array(30 * wheelsCount);
		var divTestA = int32Array(wheelsCount);
		var divTestB = int32Array(wheelsCount);

		for (var i = 0; i < wheelsCount; i += 1) {
			var w = wheels0[i];
			var wheelLog = i >= realWheels ? 0 : Math.log2(w.p) * (w.step === 2 || w.root === 0 ? 0.5 : 1);
			var log = Math.round(wheelLog * SCALE) | 0;
			if (log >= Math.pow(2, 8) || w.step >= Math.pow(2, 32)) {
				throw new RangeError();
			}

			wheelSteps[i] = w.step;
			wheelLogs[i] = log;
			wheelRoots[i] = w.root;
			wheelLogs0[i] = wheelLog;
		}

		var lpStrategy = function (p, polynomial, x, pb) {

			var lp = largePrimes.get(p);
			if (lp == undefined) {

				largePrimes.set(p, {
					polynomial: polynomial,
					x: x,
					pb: pb.slice(0)
				});
				QuadraticSieveFactorization.lpRels += 1;
			} else {
				var s = BigInt(p);
				var sInverse = modInverse(s, N);
				if (sInverse === BigInt(0)) {
					return new CongruenceOfsquareOfXminusYmoduloN(s, [0], N);
				} else {
					var X = polynomial.X(x);
					var Y = polynomial.Y(x, s, pb);
					var lpX = lp.polynomial.X(lp.x);
					var lpY = lp.polynomial.Y(lp.x, s, lp.pb);
					var X1 = (sInverse * lpX * X) % N;
					if (Y != null && lpY != null) {
						var Y1 = Y.concat(lpY);
						return new CongruenceOfsquareOfXminusYmoduloN(X1, Y1, N);
					} else {
						console.count('bad lp');
					}
				}
			}
			return null;
		};

		var polynomialGenerator = useMultiplePolynomials ? QuadraticPolynomial.generator(sieveSize / 2, primes, N) : null;
		var polynomial = null;
		var baseOffsets = null;
		if (!useMultiplePolynomials) {
			var baseOffset = BigInt(sqrt(N)) + BigInt(1);
			polynomial = new QuadraticPolynomial(BigInt(1), baseOffset, N, []);
			baseOffsets = new Float64Array(wheelsCount);

			for (var i = 0; i < wheelsCount; i += 1) {
				baseOffsets[i] = Number(baseOffset % BigInt(wheelSteps[i])) | 0;
			}
		}

		function checkWheels(offset) {
			for (var k = 0; k < wheelsCount; k += 1) {
				var p = wheelSteps[k];
				for (var v = 0; v <= 1; v += 1) {
					var root = (v === 0 ? wheelRoots1[k] : wheelRoots2[k]);
					if (root !== sieveSize) {
						var x = BigInt(+root + offset);
						var X = ((polynomial.useQ2Form ? BigInt(2) : BigInt(1)) * polynomial.A * x + polynomial.B);
						var Y = X * X - N;
						if (root < 0 || root >= p || Y % ((polynomial.useQ2Form ? BigInt(4) : BigInt(1)) * polynomial.A) !== BigInt(0) || (Y / ((polynomial.useQ2Form ? BigInt(4) : BigInt(1)) * polynomial.A)) % BigInt(p) !== BigInt(0)) {
							throw new Error();
						}
					}
				}
			}
		}

		function modInverseMod2pow32(a) {
			var aInv = a;
			for (var e = 2; e < 32; e += e) {
				aInv = Math.imul(aInv, 2 - Math.imul(a, aInv));
			}
			return aInv;
		}

		function computeDivTestAB(d, Nmax) {

			if (d % 2 === 0) {
				if (d !== Math.pow(2, Math.round(Math.log2(d)))) {
					throw new RangeError();
				}

				return {
					a: (Math.pow(2, 32) / d) | 0,
					b: 0
				};
			}
			var a = modInverseMod2pow32(d);
			var b = Math.floor(Nmax / d);
			b = b < Math.pow(2, 16) ? b : (b | 0xFFFF);
			console.assert(b <= Math.floor((Math.pow(2, 32) - 1) / d));
			return {
				a: a,
				b: b
			};
		}

		for (var i = 0; i < wheelsCount; i += 1) {
			var p = wheelSteps[i];
			var tmp = computeDivTestAB(p, wheels0.at(-1).step + sieveSize);
			divTestA[i] = tmp.a;
			divTestB[i] = tmp.b;
		}

		var BPrev = BigInt(0);
		var Bdistances = [];
		var counternext = 0;

		var updateWheels = function (polynomial, offset) {
			offset = -0 + offset;

			var useCache = BigInt(polynomial.A) === BigInt(invCacheKey);
			if (!useCache) {
				var AA = FastModBigInt((polynomial.useQ2Form ? BigInt(2) : BigInt(1)) * polynomial.A);
				var bsign = polynomial.B < BigInt(0) ? -1 : +1;
				var BB = FastModBigInt(polynomial.B < BigInt(0) ? -polynomial.B : polynomial.B);

				zeroInvs.length = 0;
				for (var i = 0; i < wheelsCount; i += 1) {
					var p = -0 + wheelSteps[i];
					var pInv = (1 + Math.pow(2, -52)) / p;

					var a = -0 + FastMod(AA, p, pInv);
					var invA = modInverseSmall(a, p) | 0;
					invCache[i] = invA;
					if (invA === 0) {
						zeroInvs.push(i);
					}

					var b = -0 + FastMod(BB, p, pInv);
					b = bsign < 0 ? -b : b;
					var root = -0 + wheelRoots[i];
					var x1 = ((p - b) + (p - root)) * invA - offset;
					var x2 = ((p - b) + root) * invA - offset;
					x1 = x1 - Math.floor(x1 * pInv) * p;
					x2 = x2 - Math.floor(x2 * pInv) * p;
					var r1 = Math.min(x1, x2);
					var r2 = Math.max(x1, x2);
					wheelRoots1[i] = r1;
					wheelRoots2[i] = r2;
				}
				BPrev = BigInt(0);

				Bdistances.length = 0;
				counternext = 0;
			}
			if (BPrev === BigInt(0)) {
				BPrev = polynomial.B;
			} else {
				var d = polynomial.B - BPrev;
				BPrev = polynomial.B;
				var e = 0;
				if (d < BigInt(0)) {
					d += (polynomial.useQ2Form ? BigInt(2) : BigInt(1)) * polynomial.A;
					e = 1;
				}
				if (d < BigInt(0) || d >= polynomial.A * BigInt(2)) {
					throw new RangeError();
				}
				var v = Bdistances.indexOf(d);
				if (v === -1) {
					Bdistances.push(d);
					var dd = FastModBigInt(d < BigInt(0) ? -d : d);
					v = Bdistances.length - 1;
					var alphav = v * wheelsCount;
					for (var i = 0; i < wheelsCount; i += 1) {
						var p = -0 + wheelSteps[i];
						var invA = -0 + invCache[i];
						var pInv = (1 + Math.pow(2, -52)) / p;
						var d = FastMod(dd, p, pInv);
						var a = (p - d) * invA;
						a = a + sieveSize;
						a = a - Math.floor(a * pInv) * p;
						a = p - a;
						alpha[alphav + i] = a;
					}
				}
				counternext += 1;
				updateWheelsInternalNext(wheelsCount, alpha.byteOffset + ((v * wheelsCount) * 4), wheelSteps.byteOffset, wheelRoots1.byteOffset, wheelRoots2.byteOffset, e);
			}
			var a = Number(polynomial.A & BigInt(Math.pow(2, 29) - 1));
			var b = Number(polynomial.B & BigInt(Math.pow(2, 29) - 1));
			var c = Number(polynomial.C & BigInt(Math.pow(2, 29) - 1));
			var aInv = modInverseSmall(a, Math.pow(2, 29));
			for (var j = 0; j < zeroInvs.length; j += 1) {
				var i = zeroInvs[j];

				wheelRoots1[i] = sieveSize;
				wheelRoots2[i] = sieveSize;

				if (polynomial.useQ2Form) {
					var p = wheelSteps[i];
					if (p % 2 === 0) {
						var r0 = wheelRoots[i];
						for (var k = 0; k < (p === 2 ? 1 : 2); k += 1) {
							var r = k === 0 ? r0 : p - r0;
							console.assert((-b - r) % 2 === 0);
							console.assert((-b + r) % 2 === 0);
							var r1 = (Math.imul((-b - r) / 2, aInv) - offset) & (p - 1);
							var r2 = (Math.imul((-b + r) / 2, aInv) - offset) & (p - 1);
							var y1 = (Math.imul(Math.imul(a, r1 + offset) + b, r1 + offset) + c) & (p - 1);
							var y2 = (Math.imul(Math.imul(a, r2 + offset) + b, r2 + offset) + c) & (p - 1);
							if (y1 === 0 && y2 === 0) {
								wheelRoots1[i] = Math.min(r1, r2);
								wheelRoots2[i] = Math.max(r1, r2);
							}
							if (p === 2) {

								if (r1 !== r2) {
									wheelLogs[i] = Math.round(1 * SCALE) | 0;
									wheelLogs0[i] = 1;
								} else {
									throw new Error();
								}
							}
						}
					}
				}
			}

			invCacheKey = polynomial.A;

		};

		var gcd = function (a, b) {
			while (b !== 0) {
				var r = +a % +b;
				a = b;
				b = r;
			}
			return a;
		};
		var lcm = function (a, b) {
			return Math.floor(a / gcd(a, b)) * b;
		};

		var getSmallWheels = function () {
			var p = 1;
			var i = 0;
			while (i < wheelsCount && lcm(p, wheelSteps[i]) <= segmentSize / 4) {
				p = lcm(p, wheelSteps[i]);
				i += 1;
			}
			return i;
		};
		var smallWheels = getSmallWheels();

		var copyCycle = function (array, cycleLength, limit) {
			if (typeof limit !== 'number' || typeof cycleLength !== 'number') {
				throw new TypeError();
			}
			if (limit > array.length) {
				throw new RangeError();
			}
			for (var i = cycleLength; i < limit; i += cycleLength) {
				array.copyWithin(i, 0, Math.min(limit - i, cycleLength));
			}
		};

		QuadraticSieveFactorization.smallSegmentTime = 0;
		QuadraticSieveFactorization.largeSegmentTime = 0;

		var updateSieveSegment = function (segmentStart) {
			var cycleLength = 1;
			SIEVE_SEGMENT[0] = SHIFT;
			for (var j = 0; j < smallWheels; j += 1) {
				var newCycleLength = +lcm(cycleLength, wheelSteps[j]);
				copyCycle(SIEVE_SEGMENT, cycleLength, newCycleLength);
				cycleLength = newCycleLength;
				var p = wheelSteps[j];
				var log2p = wheelLogs[j];
				var r1 = (wheelRoots1[j] | 0);
				if (r1 !== sieveSize) {
					for (var k = (r1 + newCycleLength - segmentStart % newCycleLength) % p; k < newCycleLength; k += p) {
						SIEVE_SEGMENT[k] = (SIEVE_SEGMENT[k] + log2p) | 0;
					}
				}
				var r2 = (wheelRoots2[j] | 0);
				if (r2 !== sieveSize) {
					for (var k = (r2 + newCycleLength - segmentStart % newCycleLength) % p; k < newCycleLength; k += p) {
						SIEVE_SEGMENT[k] = (SIEVE_SEGMENT[k] + log2p) | 0;
					}
				}
			}
			copyCycle(SIEVE_SEGMENT, cycleLength, segmentSize);

			var m = (typeof navigator !== 'undefined' && navigator.hardwareConcurrency === 12 ? 1 : 1.5);
			var V = Math.min(0 + wheelsCount - smallWheels, Math.floor(64 * 3 * m * (N > Math.pow(2, 285) ? 4 : (N > Math.pow(2, 240) ? 2 : 1))));
			var S = Math.floor((1 << 15) * m);
			var t1 = performance.now();
			var subsegmentEnd = 0;
			while (subsegmentEnd + S <= segmentSize) {
				subsegmentEnd += S;
				singleBlockSieve(wheelRoots1.byteOffset, wheelRoots2.byteOffset, wheelSteps.byteOffset, wheelLogs.byteOffset, smallWheels * 4, smallWheels * 4 + V * 4, subsegmentEnd, 0);
			}
			QuadraticSieveFactorization.smallSegmentTime += performance.now() - t1;
			var t2 = performance.now();
			singleBlockSieve(wheelRoots1.byteOffset, wheelRoots2.byteOffset, wheelSteps.byteOffset, wheelLogs.byteOffset, smallWheels * 4, wheelsCount * 4, segmentSize, segmentSize);
			QuadraticSieveFactorization.largeSegmentTime += performance.now() - t2;
		};

		var smoothEntryPositions = [];
		var smoothEntryValues = [];
		var smoothEntryFactorBases = [];

		var findSmoothEntries = function (offset, polynomial) {
			if (typeof offset !== "number") {
				throw new TypeError();
			}

			var commonThreshold = Math.max(SHIFT, (Math.round((polynomial.log2AbsY(0) - (doubleLargePrimes ? doubleLargePrimesThreshold : largePrimesThreshold)) * SCALE + SHIFT) | 0) - 9);

			var i = 0;
			var thresholdApproximation = 0;
			while (i < segmentSize) {

				thresholdApproximation = useMultiplePolynomials ? commonThreshold : Math.floor((polynomial.log2AbsY(i + offset) - (doubleLargePrimes ? doubleLargePrimesThreshold : largePrimesThreshold)) * SCALE + SHIFT + 0.5) | 0;
				var j = useMultiplePolynomials ? segmentSize : Math.min(segmentSize, thresholdApproximationInterval(polynomial, i + offset, (thresholdApproximation - SHIFT) * (1 / SCALE) + (doubleLargePrimes ? doubleLargePrimesThreshold : largePrimesThreshold), sieveSize) - offset);

				while (i < j) {
					if (i < j - 1) {
						var tmp = SIEVE_SEGMENT[j - 1];
						SIEVE_SEGMENT[j - 1] = MAX;
						while ((i & 0xF) !== 0 && thresholdApproximation > SIEVE_SEGMENT[i]) {
							i += 1;
						}
						if ((i & 0xF) === 0) {
							i = findSmoothEntry(thresholdApproximation, i);
							var c = 0;
							while (thresholdApproximation > SIEVE_SEGMENT[i]) {
								i += 1;
								c += 1;
							}
							if (c >= 16) {
								console.error('too big c', c);
							}
						}
						SIEVE_SEGMENT[j - 1] = tmp;
					}
					var r = polynomial.log2AbsY(i + offset) - (SIEVE_SEGMENT[i] - SHIFT) * (1 / SCALE);
					if (r < largePrimesThreshold || doubleLargePrimes && r >= log2B * 2 && r < doubleLargePrimesThreshold) {
						smoothEntryPositions.push(i + offset);
						smoothEntryValues.push(-0 + (SIEVE_SEGMENT[i] - SHIFT) * (1 / SCALE));
					}
					i += 1;
				}
			}
		};

		function checkFactorization(x) {
			var p = 0;
			for (var n = 0; n < wheelsCount; n += 1) {
				var log2p = wheelLogs[n];
				var step = wheelSteps[n];
				for (var v = 0; v <= 1; v += 1) {
					if ((x - (v === 0 ? (wheelRoots1[n] | 0) : (wheelRoots2[n] | 0)) - (n < smallWheels ? 0 : segmentSize)) % step === 0) {
						if (polynomial.AFactors.indexOf(step) === -1) {
							console.log(step);
							p += log2p;
						}
					}
				}
			}
			return p;
		}

		function applyOffset(offset) {
			for (var j = 0; j < wheelsCount; j += 1) {
				var step = wheelSteps[j];
				var r1 = (0 + (wheelRoots[j] | 0) - baseOffsets[j] - offset) % step;
				r1 += (r1 < 0 ? step : 0);
				var r2 = (0 - (wheelRoots[j] | 0) - baseOffsets[j] - offset) % step;
				r2 += (r2 < 0 ? step : 0);
				wheelRoots1[j] = Math.min(r1, r2);
				wheelRoots2[j] = Math.max(r1, r2);
			}
		}

		function findPreciseSmoothEntries(offset) {
			if (smoothEntryPositions.length > 512) {
				console.warn('too many smooth entries: ' + smoothEntryPositions.length + ' N = ' + N);
				smoothEntryPositions.length = 512;
			}
			for (var i = 0; i < smoothEntryPositions.length; i += 1) {
				smoothEntriesX[i] = (smoothEntryPositions[i] - offset) - sieveSize;
			}
			for (var j = 0; j < smallWheels; j += 1) {
				var step = wheelSteps[j];
				if (wheelRoots1[j] !== sieveSize) {
					var x = (wheelRoots1[j] + (0 - sieveSize) % step);
					wheelRoots1[j] = x <= 0 ? x + step : x;
				} else {
					wheelRoots1[j] = 0;
				}
				if (wheelRoots2[j] !== sieveSize) {
					var x = (wheelRoots2[j] + (0 - sieveSize) % step);
					wheelRoots2[j] = x <= 0 ? x + step : x;
				} else {
					wheelRoots2[j] = 0;
				}
			}

			var k = smoothEntryPositions.length === 0 ? 0 : handleSmallWheels(wheelsCount, wheelRoots1.byteOffset, wheelRoots2.byteOffset, divTestA.byteOffset, divTestB.byteOffset, storage.byteOffset >> 2, smoothEntriesX.byteOffset, smoothEntriesX.byteOffset + smoothEntryPositions.length * 4);

			var preciseValues = new Float64Array(smoothEntryPositions.length);
			for (var v = 0; v < k; v += 2) {
				var j = storage[v];
				var i = storage[v + 1];
				var step = wheelSteps[j];
				preciseValues[i] += +wheelLogs0[j];
				smoothEntryFactorBases[i].push(step);
			}
			for (var i = 0; i < smoothEntryPositions.length; i += 1) {
				var e = Math.abs(smoothEntryValues[i] - preciseValues[i]);
				if (e >= 9 && e < 100) {
					console.error(e);
				}
				smoothEntryValues[i] = preciseValues[i];
			}
		}

		function Queue() {

			this.a = [];
			this.b = [];
			this.length = 0;
		}

		Queue.prototype.push = function (e) {
			this.a.push(e);
			this.length = this.a.length + this.b.length;
		};
		Queue.prototype.shift = function (e) {
			if (this.b.length === 0) {
				while (this.a.length > 0) {
					this.b.push(this.a.pop());
				}
			}
			var e = this.b.pop();
			this.length = this.a.length + this.b.length;
			return e;
		};

		function Graph() {
			this.edges = 0;
			this.components = 0;
			this.vertices = 0;
			this._edges = new Map();
			this._edgesArray = [];
			this._g = new Map();
		}

		Graph.prototype._insertVertex = function (p) {
			if (!this._g.has(p)) {
				this._g.set(p, p);
				this.vertices += 1;
				this.components += 1;
				return p;
			}
			var root = this._g.get(p);
			while (this._g.get(root) !== root) {
				root = this._g.get(root);
			}
			var x = p;
			while (x !== root) {
				var next = this._g.get(x);
				this._g.set(x, root);
				x = next;
			}
			return root;
		};
		var key = function (p1, p2) {
			return BigInt.asUintN(64, (BigInt(Math.min(p1, p2)) << BigInt(32)) + BigInt(Math.max(p1, p2)));
		};
		Graph.prototype.insertEdge = function (p1, p2, data) {
			var p1p2 = key(p1, p2);
			if (this._edges.get(p1p2) !== undefined) {
				console.count('same p1p2');
				return;
			}
			this._edges.set(p1p2, data);
			this._edgesArray.push({
				p1: p1,
				p2: p2
			});
			if (p1 !== p2) {
				this._edgesArray.push({
					p1: p2,
					p2: p1
				});
			}
			this.edges += 1;
			var p1root = this._insertVertex(p1);
			var p2root = this._insertVertex(p2);
			if (p1root < p2root) {
				this.components -= 1;
				this._g.set(p2root, p1root);
			}
			if (p1root > p2root) {
				this.components -= 1;
				this._g.set(p1root, p2root);
			}
		};
		Graph.prototype.iterateCycles = function (onCycle) {
			var nodes = new Map();
			this._edgesArray.sort(function (a, b) {
				return a.p1 - b.p1 || a.p2 - b.p2;
			});

			var roots = [];
			for (var iteratorv = this._g.keys()[globalThis.Symbol.iterator](), v = iteratorv.next().value; v != null; v = iteratorv.next().value) {
				if (this._g.get(v) === v) {
					roots.push(v);
				}
				nodes.set(v, {
					explored: false,
					finished: false,
					parent: 0
				});
			}
			roots.sort(function (a, b) {
				return a - b;
			});
			var p1Array = this._edgesArray.map(function (edge) {
				return edge.p1;
			});

			var path = function (w) {
				var p = [];
				while (w !== 0) {
					p.push(w);
					w = nodes.get(w).parent;
				}
				return p;
			};

			for (var iteratorr = roots[globalThis.Symbol.iterator](), r = iteratorr.next().value; r != null; r = iteratorr.next().value) {

				var Q = new Queue();
				var root = nodes.get(r);
				console.assert(root.explored === false && root.parent === 0);
				root.explored = true;
				root.parent = 0;
				Q.push(r);
				while (Q.length > 0) {
					var v = Q.shift();
					var start = indexOf(p1Array, v);

					for (var i = start; i >= 0 && this._edgesArray[i].p1 === v; i -= 1) {
						var edge = this._edgesArray[i];
						var p2 = nodes.get(edge.p2);
						if (p2.explored) {
							if (p2.finished) {
								continue;
							}

							var path1 = path(edge.p2);
							var path2 = path(edge.p1);
							var j = 0;
							while (path1.length - 1 - j >= 0 && path2.length - 1 - j >= 0 && path1[path1.length - 1 - j] === path2[path2.length - 1 - j]) {
								j += 1;
							}
							console.assert(j > 0);
							var vertices = path1.slice(0, path1.length - (j - 1)).reverse().concat(path2.slice(0, path2.length - (j - 1)));
							var edges = [];
							for (var i = 1; i < vertices.length; i += 1) {
								edges.push({
									p1: vertices[i - 1],
									p2: vertices[i]
								});
							}
							var edgesMap = this._edges;
							var data = edges.map(function (e) {
								return edgesMap.get(key(e.p1, e.p2));
							});
							onCycle(edges, data);
						} else {
							p2.explored = true;
							p2.parent = edge.p1;
							Q.push(edge.p2);
						}
					}
					nodes.get(v).finished = true;
				}
			}
		};

		var onCycle = function (edges, data) {
			var s = BigInt(1);
			var X = BigInt(1);
			var Y = [];
			for (var j = 0; j < edges.length; j += 1) {
				var lp = edges[j];
				var lpData = data[j];
				var lpX = lpData.polynomial.X(lpData.x);
				var lpY = lpData.polynomial.Y(lpData.x, BigInt(lp.p1) * BigInt(lp.p2), lpData.pb);
				X = (lpX * X) % N;
				if (Y == null || lpY == null) {
					Y = null;
				} else {
					Y = Y.concat(lpY);
				}
				s = (s * BigInt(lp.p2)) % N;
			}
			var sInverse = modInverse(s, N);
			if (sInverse === BigInt(0)) {
				foundGraphRelations.push(new CongruenceOfsquareOfXminusYmoduloN(s, [0], N));
			} else if (Y != null) {
				X = (sInverse * X) % N;
				var c = new CongruenceOfsquareOfXminusYmoduloN(X, Y, N);
				if (((X * X) - Y.reduce(function (p, a) {
					return p * BigInt(a);
				}, BigInt(1))) % N !== BigInt(0)) {
					throw new Error();
				}
				foundGraphRelations.push(c);
			} else {
				console.count('BAD CYCLE');
			}
		};

		var graph = new Graph();
		var foundGraphRelations = [];
		var total = 0;

		function handleDoubleLargePrimeNext(p1, p2, x, polynomial, pb) {
			if (graph == null) {
				return;
			}
			graph.insertEdge(p1, p2, {
				polynomial: polynomial,
				x: x,
				pb: pb.slice(0)
			});
			var cyclesCount = graph.edges + graph.components - graph.vertices;
			if (graph.edges % 10000 === 0) {
				console.debug('graph:', graph.edges, graph.components, graph.vertices, cyclesCount);
			}
			if (cyclesCount > primes.length + 64 - total) {
				console.debug('graph:', graph.edges, graph.components, graph.vertices, cyclesCount);
				console.time('collectGraphRelations');
				graph.iterateCycles(onCycle);
				console.timeEnd('collectGraphRelations');
				console.log(foundGraphRelations.length);
				graph = null;
			}
		}

		function handleDoubleLargePrime(x, polynomial, pb) {
			var Y = abs(polynomial.Y(x));
			for (var j = pb.length - 1; j >= 0; j -= 1) {
				var p = pb[j];
				while (Y % BigInt(p) === BigInt(0)) {
					Y /= BigInt(p);
				}
			}
			var r = BigInt(Y);
			if (Number(r) >= Math.pow(2, 64)) {

				return;
			}
			if (isProbablyPrime64(r)) {

				return;
			}
			var f = Number(PollardsRho64(r, Math.pow(2, 18)));
			if (f === 0 || f === 1) {
				console.count('cannot factor');
				return;
			}
			if (BigInt(r) % BigInt(f) !== BigInt(0) || !(f > 1 && BigInt(f) < BigInt(r))) {
				throw new Error();
			}
			var f2 = Math.floor(Number(BigInt(r) / BigInt(f)));
			var p1 = Math.min(f2, f);
			var p2 = Math.max(f2, f);
			if (!(Math.log2(p1) > log2B && p1 <= 1073741823 && p2 <= 1073741823)) {

				return;
			}
			handleDoubleLargePrimeNext(p1 | 0, p2 | 0, x, polynomial, pb);
		}

		QuadraticSieveFactorization.lpCounter = 0;
		QuadraticSieveFactorization.lpRels = 0;
		var i1 = -1;
		var k = 0;
		var iterator = {
			next: function congruencesUsingQuadraticSieve() {
				total += 1;
				while (k < 32 || (useMultiplePolynomials ? 2 : 1 / 16) * k * sieveSize <= Math.pow(primes[primes.length - 1], 2)) {
					if (foundGraphRelations.length !== 0) {
						return {
							value: foundGraphRelations.pop(),
							done: false
						};
					}

					if (i1 === sieveSize) {
						k += 1;
						i1 = -1;
					}
					var offset = useMultiplePolynomials ? -sieveSize / 2 : (k % 2 === 0 ? 1 : -1) * Math.floor((k + 1) / 2) * sieveSize;
					if (i1 === -1) {

						if (useMultiplePolynomials) {
							polynomial = polynomialGenerator.next();
							updateWheels(polynomial, offset);
						} else {
							applyOffset(offset);
						}

						smoothEntryPositions.length = 0;
						smoothEntryValues.length = 0;

						for (var segmentStart = 0; segmentStart < sieveSize; segmentStart += segmentSize) {
							updateSieveSegment(segmentStart);
							findSmoothEntries(offset + segmentStart, polynomial);
						}

						for (var i = 0; i < smoothEntryPositions.length; i += 1) {
							if (i < smoothEntryFactorBases.length) {
								smoothEntryFactorBases[i].length = 0;
							} else {
								smoothEntryFactorBases.push([]);
							}
						}

						findPreciseSmoothEntries(offset);
					}

					for (var i = i1 + 1; i < smoothEntryPositions.length; i += 1) {
						var x = smoothEntryPositions[i];
						var value = +smoothEntryValues[i];
						var pb = smoothEntryFactorBases[i];
						var threshold = +polynomial.log2AbsY(x);
						var c = null;
						if (threshold - value <= log2B) {
							var X = polynomial.X(x);
							var Y = polynomial.Y(x, BigInt(1), pb);
							if (Y == null) {

								Y = polynomial.Y(x, BigInt(1), pb.concat(zeroInvs.map(function (i) {
									return wheelSteps[i];
								})));
							}
							if (Y != null) {
								c = new CongruenceOfsquareOfXminusYmoduloN(X, Y, N);
							} else {

								console.count('wrong entry', exp2(threshold - value));

							}
						} else if (threshold - value < 2 * log2B) {
							var p = exp2(threshold - value);

							c = lpStrategy(p, polynomial, x, pb);
							if (c != null) {
								QuadraticSieveFactorization.lpCounter += 1;
							} else {
								if (doubleLargePrimes && p <= 1073741823) {
									if (polynomial.Y(x, BigInt(p), pb) != null) {
										handleDoubleLargePrimeNext(1, p | 0, x, polynomial, pb);
									} else {
										console.count('wrong?');
										console.log(polynomial.Y(x), p);
									}
								}
							}
						} else if (doubleLargePrimes && threshold - value < 3 * log2B) {
							handleDoubleLargePrime(x, polynomial, pb);
						} else {
							console.count('too big', (threshold - value) / log2B);
						}
						if (c != null) {
							i1 = i;
							return {
								value: c,
								done: false
							};
						}
					}
					i1 = sieveSize;
				}
				return {
					value: undefined,
					done: true
				};
			}
		};
		iterator[globalThis.Symbol.iterator] = function () {
			return this;
		};
		return iterator;
	}

	function gcd(a, b) {
		while (b !== BigInt(0)) {
			var r = BigInt(a) % BigInt(b);
			a = b;
			b = r;
		}
		return a;
	}

	function abs(x) {
		if (typeof x !== 'bigint') {
			throw new TypeError();
		}
		return x < BigInt(0) ? -x : x;
	}

	function indexOf(sortedArray, x) {
		if (typeof x !== 'number' || (x | 0) !== x) {
			throw new TypeError();
		}
		var min = 0;
		var max = sortedArray.length - 1;
		while (min < max) {
			var mid = Math.ceil((min + max) / 2);
			if ((sortedArray[mid] | 0) > (x | 0)) {
				max = mid - 1;
			} else {
				min = mid;
			}
		}
		if ((sortedArray[min] | 0) === (x | 0)) {
			return min;
		}
		return -1;
	}

	function computeY(primeBase, solution, N) {
		var Y = new Array(primeBase.length + 1).fill(0);
		for (var i = 0; i < solution.length; i += 1) {
			var v = solution[i].v;
			for (var j = 0; j < v.length; j += 1) {
				Y[v[j]] += 1;
			}
		}
		var y = BigInt(1);
		for (var i = 0; i < Y.length; i += 1) {
			if (Y[i] % 2 !== 0) {
				throw new RangeError();
			}
			if (i !== 0) {
				var p = primeBase[i - 1];
				var e = Y[i] / 2;
				if (e > 0) {
					if (e <= 2) {
						y = (y * BigInt(Math.pow(p, e))) % N;
					} else {
						y = (y * modPow(BigInt(p), BigInt(e), N)) % N;
					}
				}
			}
		}
		return y;
	}

	function legendre(a, n) {
		if (typeof a !== 'number' || typeof n !== 'number') {
			throw new TypeError();
		}

		a = a | 0;
		n = n | 0;

		a = (a | 0) % (n | 0);
		var t = 1;
		var r = 0;

		while (a !== 0) {

			while ((a & 1) === 0) {
				a >>= 1;
				r = n & 7;
				if (r === 3 || r === 5) {
					t = -t;
				}
			}

			r = n;
			n = a;
			a = r;
			if ((a & 3) === 3 && (n & 3) === 3) {
				t = -t;
			}
			a = (a | 0) % (n | 0);
		}
		return n === 1 ? t : 0;
	}

	function getBestMultiplier(n, primesList) {

		var scores = new Array(150).fill(0);
		for (var m = 1; m < scores.length; m += 1) {
			scores[m] = -Math.log(m) / 2;
		}

		for (var i = 0; i < primesList.length && i < 300; i += 1) {
			var p = primesList[i];
			if (p === 2) {
				for (var m = 1; m < scores.length; m += 1) {
					var q2formExtraScore = 1;
					scores[m] += [0, 2 + q2formExtraScore, 0, 0.5, 0, 1, 0, 0.5][(m * Number(n % BigInt(8))) % 8] * Math.log(2);
				}
			} else {
				var lnp = legendre(Number(n % BigInt(p)), p);
				var cp = 2 / (p - 1) * Math.log(p);
				for (var m = 1; m < scores.length; m += 1) {
					scores[m] += (lnp * legendre(m, p) === 1 ? cp : 0);
				}
			}
		}

		var max = 0;
		var best = 1;
		for (var m = 1; m <= scores.length; m += 1) {
			var y = +scores[m];
			if (+y > +max) {
				max = y;
				best = m;
			}
		}

		return best;
	}

	function QuadraticSieveFactorization(N) {
		if (typeof N !== 'bigint') {
			throw new TypeError();
		}

		var memoryBasedLimit = Math.floor(((performance.memory || {jsHeapSizeLimit: 0}).jsHeapSizeLimit || 0) / Math.pow(2, 32) < 0.99 ? Math.pow(2, 23.5) : Math.pow(2, 23.75));
		var limit = Math.min(memoryBasedLimit, (1 << 25) - 1);
		var dlpMultiplier = 2.5;
		var B = Math.max(Math.min(Math.floor(Math.sqrt(L(N) / (Number(N) > Math.pow(2, 285) ? 24 * dlpMultiplier : (Number(N) > Math.pow(2, 240) ? 12 : 6)))), limit), 512);
		var primesList = primes(B);
		var k = BigInt(1);
		k = Number(N) > Math.pow(2, 64) ? BigInt(getBestMultiplier(N, primesList)) : BigInt(1);
		for (; ; k += BigInt(1)) {
			if (k !== BigInt(1)) {
				console.debug('multiplier', k);
			}
			if (k !== BigInt(1) && N % k === BigInt(0)) {
				console.error('k');
				return BigInt(k);
			}
			var kN = k * N;
			var primeBase = primesList.filter(function (p) {
				return isQuadraticResidueModuloPrime(kN, p);
			});
			for (var i = 0; i < primeBase.length; i += 1) {
				if (Number(N % BigInt(primeBase[i])) === 0) {
					return BigInt(primeBase[i]);
				}
			}
			var congruences = congruencesUsingQuadraticSieve(primeBase, kN);
			var solutions = solve.sparseSolve(1 + primeBase.length);
			solutions.next();
			var c = null;
			var start = performance.now();
			var congruencesFound = 0;
			var last = start;
			while ((c = congruences.next().value) != undefined) {
				if (c.Y.length === 1 && c.Y[0] === 0) {
					var g = BigInt(gcd(abs(c.X), N));
					if (g !== BigInt(1) && g !== N) {
						return g;
					}
				} else {
					var t = function () {
						throw new TypeError(N);
					};
					var v = c.Y.map(function (p) {
						return (p === -1 ? 0 : 1 + indexOf(primeBase, p) || t());
					});
					var solution = solutions.next([v, {
						c: c,
						v: v
					}]).value;
					if (true) {
						var now = performance.now();
						congruencesFound += 1;
						if (false && congruencesFound % 50 === 0) {
							console.debug('smallSegmentTime: ' + QuadraticSieveFactorization.smallSegmentTime, 'largeSegmentTime: ' + QuadraticSieveFactorization.largeSegmentTime);
							return BigInt(1);
						}
						if (now - last > 5000 || solution != null) {
							console.debug('congruences found: ', congruencesFound, '/', primeBase.length, 'expected time: ', Math.round((now - start) / congruencesFound * primeBase.length), 'large prime congruences: ', QuadraticSieveFactorization.lpCounter + '(' + QuadraticSieveFactorization.lpRels + ')', 'polynomials used: ', QuadraticSieveFactorization.polynomialsCounter);
							last = now;
						}
					}
					if (solution != null) {
						var x = BigInt(1);
						for (var i = 0; i < solution.length; i += 1) {
							x = (x * solution[i].c.X) % N;
						}

						var y = computeY(primeBase, solution, N);
						var g = BigInt(gcd(abs(x + y), N));
						if (g !== BigInt(1) && g !== N) {
							return g;
						}
					}
				}
			}
		}
	}

	QuadraticSieveFactorization.testables = {
		congruencesUsingQuadraticSieve: congruencesUsingQuadraticSieve,
		squareRootModuloOddPrime: squareRootModuloOddPrime,
		isQuadraticResidueModuloPrime: isQuadraticResidueModuloPrime,
		solve: solve,
		QuadraticPolynomial: QuadraticPolynomial,
		thresholdApproximationInterval: thresholdApproximationInterval
	};

	self.QuadraticSieveFactorization = QuadraticSieveFactorization;
}

function ECM() {
	function primes(MAX) {
		var sieve = new Uint8Array(MAX + 1).fill(-1);
		var result = [];
		result.push(2);
		for (var i = 3; i <= MAX; i += 2) {
			if (sieve[i] !== 0) {
				result.push(i);
				if (i <= Math.floor(MAX / i)) {
					for (var j = i * i; j <= MAX; j += 2 * i) {
						sieve[j] = 0;
					}
				}
			}
		}
		return result;
	}

	function gcdext(a, b) {
		if (!(a instanceof JSBI) || !(b instanceof JSBI)) {
			throw new TypeError();
		}
		var B = JSBI.BigInt(0);
		var D = JSBI.BigInt(1);
		var x = a;
		var y = b;
		while (JSBI.notEqual(y, JSBI.BigInt(0))) {
			var q = JSBI.BigInt(JSBI.divide(x, y));
			var y1 = JSBI.subtract(x, JSBI.multiply(q, y));
			x = y;
			y = y1;
			var D1 = JSBI.subtract(B, JSBI.multiply(q, D));
			B = D;
			D = D1;
		}
		return [undefined, B, x];
	}

	function invmod(a, m) {
		if (!(a instanceof JSBI) || !(m instanceof JSBI)) {
			throw new TypeError();
		}
		if (JSBI.lessThan(a, JSBI.BigInt(0))) {
			a = JSBI.add(a, m);
		}
		if (JSBI.lessThan(a, JSBI.BigInt(0)) || JSBI.greaterThan(a, m)) {
			throw new RangeError();
		}
		var $tmpA_B_g = gcdext(m, a);
		var A = $tmpA_B_g[0];
		var B = $tmpA_B_g[1];
		var g = $tmpA_B_g[2];
		if (JSBI.notEqual(JSBI.BigInt(g), JSBI.BigInt(1))) {
			return JSBI.BigInt(0);
		}
		return JSBI.lessThan(JSBI.BigInt(B), JSBI.BigInt(0)) ? JSBI.add(JSBI.BigInt(B), JSBI.BigInt(m)) : JSBI.BigInt(B);
	}

	function gcd(a, b) {
		if (!(a instanceof JSBI) || !(b instanceof JSBI)) {
			throw new TypeError();
		}
		if (JSBI.lessThan(a, JSBI.BigInt(0)) || JSBI.greaterThan(a, b)) {
			throw new RangeError();
		}
		while (JSBI.notEqual(b, JSBI.BigInt(0))) {
			var q = JSBI.BigInt(JSBI.divide(a, b));
			var r = JSBI.subtract(a, JSBI.multiply(q, b));
			a = b;
			b = r;
		}
		return a;
	}

	function ecm(N, unlimited) {
		unlimited = unlimited == undefined ? false : unlimited;
		var factorDigits = unlimited ? 1 / 0 : N.toString(2).length * Math.log10(2) / 4;

		var B = Math.min(Math.round(Math.pow(5, factorDigits / 5) * 16), 1e300);
		var minB = JSBI.lessThan(N, JSBI.BigInt(Math.pow(10, 10))) ? 16 : 400;
		var B1 = B;
		while (B1 > minB) {
			B1 = Math.floor(B1 / 5);
		}
		for (; B1 <= B; B1 *= 5) {
			var curves = Math.round(Math.sqrt(B1) / 16) * 16;
			var curveIndex = 0;
			while (curveIndex < curves) {
				console.debug('curves: ', curveIndex + '/' + curves);
				var f = _ecm(N, B1, curveIndex);
				if (JSBI.notEqual(f, JSBI.BigInt(0))) {
					return f;
				}
				curveIndex += 1;
			}
			console.warn('failed to find a factor');
		}
		return JSBI.BigInt(0);
	}

	ecm.modMuls = 0;

	function makeBarrettReduction(N) {

		var k = N.toString(2).length;
		var NInv = JSBI.divide(JSBI.leftShift(JSBI.BigInt(1), JSBI.BigInt(2 * k)), N);
		var km1 = JSBI.BigInt(k - 1);
		var kp1 = JSBI.BigInt(k + 1);
		var useBarrettReduction = k > 128;
		return useBarrettReduction ? function (p) {
			var y = JSBI.subtract(p, JSBI.multiply(JSBI.signedRightShift(JSBI.multiply(JSBI.signedRightShift(p, km1), NInv), kp1), N));
			while (JSBI.lessThan(y, JSBI.BigInt(0))) {
				y = JSBI.add(y, N);
			}
			while (JSBI.greaterThanOrEqual(y, N)) {
				y = JSBI.subtract(y, N);
			}
			return y;
		} : null;
	}

	function makeSpecialReduction(N) {
		var k = N.toString(2).length;
		var NInv = JSBI.BigInt(invmod(JSBI.asUintN(k - 1, N), JSBI.leftShift(JSBI.BigInt(1), JSBI.BigInt(k - 1))));
		var sN = JSBI.multiply(N, NInv);
		var k1 = sN.toString(2).length - 1;
		var bk1 = JSBI.BigInt(k1);
		var c = JSBI.subtract(sN, JSBI.leftShift(JSBI.BigInt(1), bk1));
		if (JSBI.equal(c, JSBI.BigInt(1))) {
			console.debug("reduction for numbers of form 2^n+1 will be used");

			return function (p) {
				var y = JSBI.subtract(JSBI.asUintN(k1, p), JSBI.signedRightShift(p, bk1));

				if (JSBI.lessThan(y, JSBI.BigInt(0))) {
					y = JSBI.add(y, sN);
				}
				return y;
			};
		}
		return null;
	}

	function _ecm(N, B, curveParam) {
		B = B == undefined ? 50000 : B;
		curveParam = curveParam == undefined ? 0 : curveParam;

		if (!(N instanceof JSBI)) {
			throw new TypeError();
		}
		var useSuyamaParametrization = true;
		var failure = JSBI.BigInt(1);
		var modMuls = 0;
		var reduction1 = makeSpecialReduction(N);
		var modreduction = reduction1 || makeBarrettReduction(N) || function (p) {
			if (!(p instanceof JSBI) || !(N instanceof JSBI)) {
				throw new TypeError();
			}
			return JSBI.remainder(p, N);
		};
		var sN = reduction1 != null ? JSBI.add(reduction1(JSBI.BigInt(-1)), JSBI.BigInt(1)) : N;

		var modmul = function (a, b) {
			if (!(a instanceof JSBI) || !(b instanceof JSBI)) {
				throw new TypeError();
			}
			modMuls += 1;
			return modreduction(JSBI.multiply(a, b));
		};
		var modsub = function (a, b) {
			if (!(a instanceof JSBI) || !(b instanceof JSBI)) {
				throw new TypeError();
			}
			var y = JSBI.subtract(a, b);
			if (JSBI.lessThan(y, JSBI.BigInt(0))) {
				y = JSBI.add(y, sN);
			}
			return y;
		};
		var modadd = function (a, b) {
			if (!(a instanceof JSBI) || !(b instanceof JSBI)) {
				throw new TypeError();
			}
			var y = JSBI.add(a, b);
			if (JSBI.greaterThanOrEqual(y, sN)) {
				y = JSBI.subtract(y, sN);
			}
			return y;
		};
		var moddup = function (a) {
			var y = JSBI.leftShift(a, JSBI.BigInt(1));
			if (JSBI.greaterThanOrEqual(y, sN)) {
				y = JSBI.subtract(y, sN);
			}
			return y;
		};
		var modneg = function (a) {
			if (!(a instanceof JSBI)) {
				throw new TypeError();
			}
			return JSBI.equal(a, JSBI.BigInt(0)) ? a : JSBI.subtract(sN, a);
		};
		var modmulsmall = function (a, b) {
			if (!(a instanceof JSBI) || !(b instanceof JSBI)) {
				throw new TypeError();
			}
			var y = JSBI.remainder(JSBI.multiply(a, b), sN);
			if (JSBI.lessThan(y, JSBI.BigInt(0))) {
				y = JSBI.add(y, sN);
			}
			return y;
		};
		var modInvParallel = function (a) {

			var n = a.length;
			var c = new Array(n);
			c[0] = a[0];
			for (var i = 1; i < n; i += 1) {
				c[i] = modmul(c[i - 1], a[i]);
			}
			var u = JSBI.BigInt(invmod(JSBI.remainder(JSBI.BigInt(c[n - 1]), N), N));
			for (var i = n - 1; i >= 1; i -= 1) {
				c[i] = modmul(u, c[i - 1]);
				u = modmul(u, a[i]);
			}
			c[0] = u;
			u = JSBI.BigInt(1);
			return c;
		};

		function TwistedEdwardsCurve(a, d) {
			this.a = a;
			this.d = d;
		}

		TwistedEdwardsCurve.prototype.addPoints = function (P1, P2) {

			var A = modmul(P1.x, P2.x);
			var B = modmul(P1.y, P2.y);
			var C = modmul(P1.z, P2.t);
			var D = modmul(P1.t, P2.z);
			var E = modadd(D, C);
			var F = modsub(modadd(modmul(modsub(P1.x, P1.y), modadd(P2.x, P2.y)), B), A);
			var G = modadd(B, modmulsmall(this.a, A));
			var H = modsub(D, C);
			var x = modmul(E, F);
			var y = modmul(G, H);
			var z = modmul(F, G);
			var t = modmul(E, H);
			return {
				x: x,
				y: y,
				z: z,
				t: t
			};
		};
		TwistedEdwardsCurve.prototype.doublePoint = function (P, u, extended) {
			extended = extended == undefined ? true : extended;

			var A = modadd(P.x, P.y);
			var B = modmul(A, A);
			var C = modmul(P.x, P.x);
			var D = modmul(P.y, P.y);
			var E = modmulsmall(this.a, C);
			var F = modadd(E, D);
			var H = modmul(P.z, P.z);
			var J = modsub(F, moddup(H));
			var K = modsub(modsub(B, C), D);
			var L = modsub(E, D);
			var x = modmul(K, J);
			var y = modmul(F, L);
			var z = modmul(F, J);
			var t = extended ? modmul(K, L) : undefined;
			return {
				x: x,
				y: y,
				z: z,
				t: t
			};
		};
		TwistedEdwardsCurve.prototype.negatePoint = function (P) {
			return {
				x: modneg(P.x),
				y: P.y,
				z: P.z,
				t: modneg(P.t)
			};
		};
		TwistedEdwardsCurve.prototype.phi = function (points) {
			var v = new Array(points.length);
			for (var i = 0; i < points.length; i += 1) {
				var P = points[i];

				v[i] = P.z;
			}
			var invs = modInvParallel(v);
			var res = new Array(points.length);
			for (var i = 0; i < points.length; i += 1) {
				var P = points[i];

				var y = JSBI.BigInt(modmul(P.y, invs[i]));
				res[i] = JSBI.remainder(y, N);
				if (JSBI.equal(invs[i], JSBI.BigInt(0))) {
					var u = gcd(v[i], N);
					if (JSBI.notEqual(u, JSBI.BigInt(1)) && JSBI.notEqual(u, JSBI.BigInt(N))) {
						failure = u;
						return [];
					}
				}
			}
			return res;
		};
		var MontgomeryToTwistedEdwards = function (x_m, y_m, A, B, N) {
			if (!(N instanceof JSBI)) {
				throw new TypeError();
			}
			var x_e = JSBI.remainder(JSBI.multiply(x_m, JSBI.BigInt(invmod(y_m, N))), N);
			var y_e = JSBI.remainder(JSBI.multiply(JSBI.subtract(x_m, JSBI.BigInt(1)), invmod(JSBI.add(x_m, JSBI.BigInt(1)), N)), N);
			var Binv = invmod(B, N);
			var a = JSBI.remainder(JSBI.multiply(JSBI.add(A, JSBI.BigInt(2)), Binv), N);
			var d = JSBI.remainder(JSBI.multiply(JSBI.subtract(A, JSBI.BigInt(2)), Binv), N);
			if (x_e == JSBI.BigInt(0) || JSBI.equal(y_e, JSBI.BigInt(0)) || JSBI.equal(a, JSBI.BigInt(0)) || JSBI.equal(d, JSBI.BigInt(0))) {
				return null;
			}
			console.assert(JSBI.equal(JSBI.remainder(JSBI.subtract(JSBI.add(JSBI.multiply(JSBI.multiply(a, x_e), x_e), JSBI.multiply(y_e, y_e)), JSBI.add(JSBI.BigInt(1), JSBI.multiply(JSBI.multiply(JSBI.multiply(JSBI.multiply(d, x_e), x_e), y_e), y_e))), N), JSBI.BigInt(0)));

			x_e = JSBI.lessThan(x_e, JSBI.BigInt(0)) ? JSBI.add(x_e, N) : x_e;
			y_e = JSBI.lessThan(y_e, JSBI.BigInt(0)) ? JSBI.add(y_e, N) : y_e;

			d = JSBI.lessThan(d, JSBI.BigInt(0)) ? JSBI.add(d, N) : d;
			return {
				x: x_e,
				y: y_e,
				a: a,
				d: d
			};
		};
		var wAryNonAdjacentFormMultiplication = function (curve, P, s) {
			function wNAF(d, w) {

				var da = [];
				var pos = d.length - 1;
				var carry = false;
				while (pos >= 0 || carry) {
					if ((pos >= 0 ? +d.charCodeAt(pos) - +'0'.charCodeAt(0) : 0) !== (carry ? 1 : 0)) {
						var x = 0;
						for (var i = pos + 1 - w; i <= pos; i += 1) {
							x <<= 1;
							x += i >= 0 ? +d.charCodeAt(i) - +'0'.charCodeAt(0) : 0;
						}
						x += carry ? 1 : 0;
						if (x >= 1 << w - 1) {
							x -= 1 << w;
						}
						da.push(x);
						pos -= 1;
						for (var i = 0; i < w - 1; i += 1) {
							da.push(0);
							pos -= 1;
						}
						carry = x < 0;
					} else {
						da.push(0);
						pos -= 1;
					}
				}
				while (da[da.length - 1] === 0) {
					da.pop();
				}
				return da;
			}

			var w = 2;
			var work = function (w, n) {
				return 1 + Math.pow(2, w - 2) - 1 + n + n / (w + 1);
			};
			while (+work(w + 1, s.length) < +work(w, s.length)) {
				w += 1;
			}
			var d = wNAF(s, w);
			var cache = new Array(Math.pow(2, w - 2)).fill(null);
			cache[0] = P;
			var twoP = curve.doublePoint(P);
			if (twoP == null) {
				return null;
			}
			for (var k = 1; k < cache.length; k += 1) {
				cache[k] = curve.addPoints(cache[k - 1], twoP);
				if (cache[k] == null) {
					return null;
				}
			}
			var Q = null;
			for (var j = d.length - 1; j >= 0; j -= 1) {
				if (Q != null) {
					Q = curve.doublePoint(Q, undefined, d[j] !== 0 || j === 0);
					if (Q == null) {
						return null;
					}
				}
				if (d[j] !== 0) {

					var i = Math.abs(d[j]);
					console.assert((i - 1) % 2 === 0);
					var X = cache[i - 1 >> 1];
					if (Q == null) {
						Q = X;
					} else {
						if (d[j] < 0) {
							Q = curve.addPoints(Q, curve.negatePoint(X));
							if (Q == null) {
								return null;
							}
						} else {
							Q = curve.addPoints(Q, X);
							if (Q == null) {
								return null;
							}
						}
					}
				}
			}
			return Q;
		};
		var scalePoint = function (curve, P, s) {

			return wAryNonAdjacentFormMultiplication(curve, P, s.toString(2));
		};
		var SuyamaParametrization = function (sigma, N) {
			if (!(sigma instanceof JSBI) || !(N instanceof JSBI)) {
				throw new TypeError();
			}

			var u = JSBI.remainder(JSBI.subtract(JSBI.multiply(sigma, sigma), JSBI.BigInt(5)), N);
			var v = JSBI.remainder(JSBI.multiply(JSBI.BigInt(4), sigma), N);
			var z0inv = invmod(JSBI.remainder(JSBI.multiply(JSBI.multiply(v, v), v), N), N);
			if (JSBI.equal(z0inv, JSBI.BigInt(0))) {
				return null;
			}
			var t = invmod(JSBI.remainder(JSBI.multiply(JSBI.multiply(JSBI.multiply(JSBI.multiply(JSBI.BigInt(4), u), u), u), v), N), N);
			if (JSBI.equal(t, JSBI.BigInt(0))) {
				return null;
			}
			var a = JSBI.remainder(JSBI.subtract(JSBI.multiply(JSBI.multiply(JSBI.multiply(JSBI.multiply(JSBI.subtract(v, u), JSBI.subtract(v, u)), JSBI.subtract(v, u)), JSBI.add(JSBI.multiply(JSBI.BigInt(3), u), v)), t), JSBI.BigInt(2)), N);
			var b = JSBI.remainder(JSBI.multiply(u, z0inv), N);
			var x = JSBI.remainder(JSBI.multiply(JSBI.multiply(u, u), u), N);
			var y = JSBI.remainder(JSBI.multiply(JSBI.multiply(JSBI.subtract(JSBI.multiply(sigma, sigma), JSBI.BigInt(1)), JSBI.subtract(JSBI.multiply(sigma, sigma), JSBI.BigInt(25))), JSBI.subtract(JSBI.multiply(JSBI.multiply(JSBI.multiply(sigma, sigma), sigma), sigma), JSBI.BigInt(25))), N);
			x = JSBI.remainder(JSBI.multiply(x, z0inv), N);
			y = JSBI.remainder(JSBI.multiply(y, z0inv), N);
			console.assert(JSBI.equal(JSBI.remainder(JSBI.subtract(JSBI.multiply(JSBI.multiply(b, y), y), JSBI.add(JSBI.add(JSBI.multiply(JSBI.multiply(x, x), x), JSBI.multiply(JSBI.multiply(a, x), x)), x)), N), JSBI.BigInt(0)));

			if (true) {

				var s = JSBI.remainder(JSBI.multiply(JSBI.multiply(JSBI.subtract(v, u), v), invmod(JSBI.remainder(JSBI.multiply(JSBI.multiply(JSBI.BigInt(2), u), u), N), N)), N);
				var sInv = invmod(s, N);
				if (JSBI.notEqual(sInv, JSBI.BigInt(0))) {
					b = JSBI.remainder(JSBI.multiply(JSBI.multiply(b, s), s), N);
					y = JSBI.remainder(JSBI.multiply(y, sInv), N);
					console.assert(JSBI.equal(JSBI.remainder(JSBI.subtract(JSBI.multiply(JSBI.multiply(b, y), y), JSBI.add(JSBI.add(JSBI.multiply(JSBI.multiply(x, x), x), JSBI.multiply(JSBI.multiply(a, x), x)), x)), N), JSBI.BigInt(0)));
				}
			}

			return {
				x: x,
				y: y,
				a: a,
				b: b
			};
		};
		var product = function (array) {
			if (array.length > 16) {
				var middle = Math.floor(array.length / 2);
				return JSBI.multiply(JSBI.BigInt(product(array.slice(0, middle))), JSBI.BigInt(product(array.slice(middle))));
			}
			var p = JSBI.BigInt(1);
			for (var i = 0; i < array.length; i += 1) {
				p = JSBI.multiply(p, JSBI.BigInt(array[i]));
			}
			return p;
		};
		var generateCurveAndStartingPoint = function (curveIndex, flag) {
			flag = flag == undefined ? false : flag;
			if (typeof curveIndex !== 'number') {
				throw new TypeError();
			}
			if (useSuyamaParametrization) {
				var tmp1 = SuyamaParametrization(JSBI.add(JSBI.BigInt(6), JSBI.BigInt(curveIndex)), N);
				if (tmp1 != null) {
					if (true) {
						var tmp3 = MontgomeryToTwistedEdwards(tmp1.x, tmp1.y, tmp1.a, tmp1.b, N);
						if (tmp3 != null) {
							return {
								curve: new TwistedEdwardsCurve(tmp3.a, tmp3.d),
								startingPoint: {
									x: tmp3.x,
									y: tmp3.y,
									z: JSBI.BigInt(1),
									t: modmul(tmp3.x, tmp3.y)
								}
							};
						}
					}
				}
			}
			if (true) {
				var d = JSBI.BigInt(curveIndex + 2);
				var a = JSBI.subtract(JSBI.add(JSBI.multiply(JSBI.multiply(d, JSBI.BigInt(2)), JSBI.BigInt(2)), JSBI.BigInt(1)), JSBI.multiply(JSBI.BigInt(2), JSBI.BigInt(2)));
				return {
					curve: new TwistedEdwardsCurve(a, d),
					startingPoint: {
						x: JSBI.BigInt(1),
						y: JSBI.BigInt(2),
						z: JSBI.BigInt(1),
						t: JSBI.multiply(JSBI.BigInt(1), JSBI.BigInt(2))
					}
				};
			}
		};
		var restoreNulls = function (values, points) {
			var res = new Array(points.length);
			var k = 0;
			for (var i = 0; i < points.length; i += 1) {
				if (points[i] == null) {
					res[i] = null;
				} else {
					res[i] = values[k];
					k += 1;
				}
			}
			return res;
		};
		var pointsRange = function (curve, P, to) {

			var Q = null;
			var array = new Array(to + 1).fill(null);
			for (var j = 1; j <= to; j += 1) {
				Q = j === 1 ? P : j === 2 ? curve.doublePoint(Q) : curve.addPoints(Q, P);
				if (Q == null) {
					return null;
				}
				array[j] = Q;
			}
			return array;
		};
		var pointsRangeFiltered = function (curve, P, to, filter) {
			var twoP = curve.doublePoint(P);
			if (twoP == null) {
				return null;
			}
			var gaps = pointsRange(curve, twoP, 7);
			var Q = null;
			var last = 0;
			var array = new Array(to + 1).fill(null);
			for (var j = 1; j <= to; j += 1) {
				if (filter(j)) {
					if (j === 1) {
						Q = P;
					} else if (j === 2) {
						Q = gaps[1];
					} else {
						if ((j - last) % 2 !== 0 || (j - last) / 2 >= gaps.length) {
							throw new Error();
						}
						Q = curve.addPoints(Q, gaps[j - last >> 1]);
					}
					if (Q == null) {
						return null;
					}
					array[j] = Q;
					last = j;
				}
			}
			return array;
		};
		var verbose = true;
		var B2 = Math.ceil(B * Math.log2(B) * Math.log(B));

		if (true) {
			var tmp = generateCurveAndStartingPoint(curveParam);
			var curve = tmp.curve;
			if (curve == null) {
				return JSBI.BigInt(0);
			}
			var P = tmp.startingPoint;
			if (verbose) {
				console.debug('B1: ', B, 'B2: ', B2, 'curveParam: ', curveParam);
			}

			if (verbose) {
				console.time('stage1');
			}
			var s = product(primes(B).map(function (p) {
				return Math.pow(p, Math.floor(Math.log2(B) / Math.log2(p)));
			}));
			var modMuls0 = modMuls;
			var start = +Date.now();
			var sP = scalePoint(curve, P, s);
			var end = +Date.now();
			if (verbose) {
				console.timeEnd('stage1');
			}
			if (verbose) {
				console.debug('modmuls per second: ', (modMuls - modMuls0) * 1000 / (end - start));
			}
			ecm.modMuls = modMuls;
			if (true && sP != null && sP.z != null) {
				var g = JSBI.BigInt(gcd(JSBI.remainder(JSBI.BigInt(sP.x), JSBI.BigInt(N)), N));
				var B1 = B;
				while (JSBI.equal(JSBI.BigInt(g), JSBI.BigInt(N)) && B1 >= 2) {

					if (B === B1) {
						console.warn('N!', N);
					}
					B1 = Math.ceil(B1 / 2);
					var s = product(primes(B1).map(function (p) {
						return Math.pow(p, Math.floor(Math.log2(B1) / Math.log2(p)));
					}));
					sP = scalePoint(curve, P, s);
					if (sP == null) {

						g = JSBI.BigInt(1);
					} else {
						g = gcd(JSBI.remainder(JSBI.BigInt(sP.x), JSBI.BigInt(N)), N);
					}
				}
				if (JSBI.greaterThan(g, JSBI.BigInt(1)) && JSBI.lessThan(g, JSBI.BigInt(N))) {
					sP = null;
					failure = g;
				}
			}
			if (sP == null) {
				if (JSBI.notEqual(failure, JSBI.BigInt(1)) && JSBI.notEqual(failure, JSBI.BigInt(N))) {
					if (verbose) {
						console.debug('stage1 success');
					}
					return failure;
				}
				console.warn('N');
				return JSBI.BigInt(0);
			}
			if (true) {

				if (verbose) {
					console.time('stage2');
				}

				var useMultipointPolynomialEvaluation = true;
				var primorial = 210 * (B2 > Math.pow(2, 27) ? 11 : 1);
				var x = 48 * (B2 > Math.pow(2, 27) ? 10 : 1);
				var d = Math.round(Math.sqrt(primorial / x * 2 * B2) / primorial) * primorial;
				var dsP = scalePoint(curve, sP, d);
				if (dsP != null) {
					console.assert(d % 210 === 0);
					var filter = function (j) {
						return j % 2 !== 0 && j % 3 !== 0 && j % 5 !== 0 && j % 7 !== 0 && (d % 11 !== 0 || j % 11 !== 0);
					};
					var P1array = pointsRange(curve, dsP, Math.round(B2 / d));
					var P2array = pointsRangeFiltered(curve, sP, d / 2, filter);
					for (var i = Math.max(1, Math.round(B / d)) - 1; i >= 0; i -= 1) {
						P1array[i] = null;
					}
					if (false) {

						for (var i = 0; i < P1array.length; i += 1) {
							for (var j = 0; j < P2array.length; j += 1) {
								var P1 = P1array[i];
								var P2 = P2array[j];
								if (P1 != null && P2 != null) {
									var p = i * d + j;
									var S = curve.addPoints(P1, P2);
									var E = scalePoint(curve, sP, p);
									console.assert(S.x + '' === E.x + '' && S.y + '' === E.y + '');
								}
							}
						}
					}
					do {
						if (JSBI.notEqual(failure, JSBI.BigInt(1))) {
							break;
						}
						var x1array = restoreNulls(curve.phi(P1array.filter(function (P) {
							return P != null;
						})), P1array);
						var x2array = restoreNulls(curve.phi(P2array.filter(function (P) {
							return P != null;
						})), P2array);
						if (JSBI.notEqual(failure, JSBI.BigInt(1))) {
							break;
						}

						if (useMultipointPolynomialEvaluation) {
							var x2s = x2array.filter(function (x) {
								return x != null;
							});
							var x1s = x1array.filter(function (x) {
								return x != null;
							});

							if (+x1s.length < +x2s.length) {

								var tmp = x1s;
								x1s = x2s;
								x2s = tmp;
							}

							var polynomial = Polynomial.fromRoots(x1s, N);
							var products = Polynomial.evaluateModP(polynomial, x2s, N);

							var p = JSBI.BigInt(1);
							for (var j = 0; j < products.length; j += 1) {
								p = modmul(p, products[j]);
							}
							if (JSBI.notEqual(JSBI.BigInt(gcd(JSBI.remainder(JSBI.BigInt(p), JSBI.BigInt(N)), N)), JSBI.BigInt(1))) {
								for (var j = 0; j < products.length; j += 1) {
									var product = products[j];
									var u = JSBI.BigInt(gcd(product, N));
									if (u < 1 || JSBI.greaterThan(u, N)) throw new Error();
									if (JSBI.notEqual(u, JSBI.BigInt(1)) && JSBI.notEqual(u, JSBI.BigInt(N))) {
										failure = u;
										break;
									}

									if (JSBI.notEqual(u, JSBI.BigInt(1))) {
										console.warn('N');
									}
								}
							}
						} else {
							var product = JSBI.BigInt(1);
							var count = 0;
							for (var iteratorp = primes(B2)[globalThis.Symbol.iterator](), p = iteratorp.next().value; p != null; p = iteratorp.next().value) {
								if (JSBI.notEqual(failure, JSBI.BigInt(1))) {
									break;
								}
								if (+p >= +B) {

									var i = Math.round(p / d);
									var j = p - d * i;
									j = j < 0 ? -j : j;

									var x1 = x1array[i];
									var x2 = x2array[j];
									if (x1 != null && x2 != null) {
										product = modmul(product, modsub(x1, x2));
										count += 1;
										if (count % 1024 === 0) {
											var u = JSBI.BigInt(gcd(JSBI.remainder(JSBI.BigInt(product), JSBI.BigInt(N)), N));
											if (JSBI.notEqual(u, JSBI.BigInt(1)) && JSBI.notEqual(u, JSBI.BigInt(N))) {
												failure = u;
												break;
											}

											if (JSBI.notEqual(u, JSBI.BigInt(1))) {
												console.warn('N');
											}
											product = JSBI.BigInt(1);
										}
									}
								}
							}

						}
					} while (false);
				}
				if (verbose) {
					console.timeEnd('stage2');
				}
				ecm.modMuls = modMuls;
				if (JSBI.notEqual(failure, JSBI.BigInt(1)) && JSBI.notEqual(failure, JSBI.BigInt(N))) {
					if (verbose) {
						console.debug('stage2 success');
					}
					return failure;
				}
			}
		}
		return JSBI.BigInt(0);
	}

	globalThis._ecm = _ecm;
	globalThis.ecm = ecm;

	self.ecm = ecm;

	function Polynomial() {
	}

	Polynomial.fromRoots = fromRoots;
	Polynomial.evaluateModP = evaluateModP;

	function fromRoots(roots, p) {
		if (roots.length === 0) {
			return [JSBI.BigInt(1)];
		}
		if (roots.length === 1) {
			return [JSBI.subtract(p, JSBI.BigInt(roots[0])), JSBI.BigInt(1)];
		}
		var middle = Math.floor(roots.length / 2);
		var A = fromRoots(roots.slice(0, middle), p);
		var B = fromRoots(roots.slice(middle), p);
		return mod(multiply(A, B), p);
	}

	function degree(A) {
		return A.length - 1;
	}

	function height(A) {
		var max = JSBI.BigInt(0);
		var min = JSBI.BigInt(0);
		for (var i = 0; i < A.length; i += 1) {
			var a = JSBI.BigInt(A[i]);
			if (JSBI.greaterThan(a, max)) {
				max = a;
			} else if (JSBI.greaterThan(min, a)) {
				min = a;
			}
		}
		return JSBI.greaterThan(JSBI.unaryMinus(min), max) ? JSBI.unaryMinus(min) : max;
	}

	function multiplyKS(A, B) {
		function bitLength(a) {
			var n = JSBI.toNumber(JSBI.BigInt(a));
			if (n < 1 / 0) {
				return Math.ceil(Math.log2(n + 0.5)) + 1;
			}

			return a.toString(16).length * 4;
		}

		function toInteger(coefficients, blockSize) {
			var bigIntCache = new Array(coefficients.length).fill(null);

			function toIntegerInternal(start, end) {
				var k = (end | 0) - (start | 0);
				if (k >= 2) {
					var m = Math.ceil(k / 2);
					if (bigIntCache[m] == null) {
						bigIntCache[m] = JSBI.BigInt(blockSize * m);
					}
					return JSBI.add(JSBI.leftShift(JSBI.BigInt(toIntegerInternal(start + m, end)), bigIntCache[m]), JSBI.BigInt(toIntegerInternal(start, start + m)));
				} else if (k === 1) {
					return coefficients[start];
				} else {
					throw new RangeError();
				}
			}

			var n = toIntegerInternal(0, coefficients.length);
			return n;
		}

		function toPolynomial(bigint, blockSize, blocksCount) {
			var bigIntCache = new Array(blocksCount).fill(null);
			var k = blocksCount;
			var coefficients = new Array(k);

			function toPolynomialInternal(C, start, end) {
				var k = (end | 0) - (start | 0);
				if (k >= 2) {
					var m = Math.ceil(k / 2);
					var r = JSBI.asUintN(blockSize * m, C);
					toPolynomialInternal(r, start, start + m);
					if (bigIntCache[m] == null) {
						bigIntCache[m] = JSBI.BigInt(blockSize * m);
					}
					var q = JSBI.signedRightShift(JSBI.BigInt(C), bigIntCache[m]);
					toPolynomialInternal(q, start + m, end);
				} else if (k === 1) {
					coefficients[start] = C;
				} else {
					throw new RangeError();
				}
			}

			toPolynomialInternal(JSBI.BigInt(bigint), 0, k);
			return coefficients;
		}

		var blockSize = bitLength(height(A)) + bitLength(height(B)) + Math.ceil(Math.log2(Math.min(degree(A) + 1, degree(B) + 1)));
		var blocksCount = degree(A) + degree(B) + 1;
		var Ai = JSBI.BigInt(toInteger(A, blockSize));
		var Bi = JSBI.BigInt(toInteger(B, blockSize));
		var P = JSBI.multiply(Ai, Bi);
		return toPolynomial(P, blockSize, blocksCount);
	}

	function multiplySchoolbook(a, b) {
		var c = new Array(a.length - 1 + b.length - 1 + 1).fill(JSBI.BigInt(0));
		for (var i = 0; i < a.length; i += 1) {
			for (var j = 0; j < b.length; j += 1) {
				var _y;
				_y = i + j, c[_y] = JSBI.add(c[_y], JSBI.multiply(JSBI.BigInt(a[i]), JSBI.BigInt(b[j])));
			}
		}
		return c;
	}

	function multiply(A, B) {
		if (A.length < 16 || B.length < 16) {
			return multiplySchoolbook(A, B, -1);
		}
		return multiplyKS(A, B, -1);
	}

	function mod(A, p) {
		return A.map(function (a) {
			var t = JSBI.remainder(JSBI.BigInt(a), p);
			return JSBI.lessThan(t, JSBI.BigInt(0)) ? JSBI.add(JSBI.BigInt(t), p) : t;
		});
	}

	function calcAtMod(A, point, p) {
		var y = JSBI.BigInt(0);
		for (var i = A.length - 1; i >= 0; i -= 1) {
			y = JSBI.remainder(JSBI.add(JSBI.multiply(y, point), A[i]), p);
		}
		return y;
	}

	function subtract(a, b) {
		var c = new Array(Math.max(a.length, b.length));
		var min = Math.min(a.length, b.length);
		for (var i = 0; i < min; i += 1) {
			c[i] = JSBI.subtract(JSBI.BigInt(a[i]), JSBI.BigInt(b[i]));
		}
		for (var i = min; i < a.length; i += 1) {
			c[i] = a[i];
		}
		for (var i = min; i < b.length; i += 1) {
			c[i] = JSBI.unaryMinus(JSBI.BigInt(b[i]));
		}
		return c;
	}

	function reversal(A) {
		return A.slice(0).reverse();
	}

	function low(A, k) {
		if (k < 0) throw new RangeError();
		return A.slice(0, k);
	}

	function high(A, k) {
		if (k < 0) throw new RangeError();
		return A.slice(k);
	}

	function shift(A, k) {
		return new Array(k).fill(JSBI.BigInt(0)).concat(A);
	}

	var inv = function (A, k, p) {
		var H = [invmod(A[0], p)];
		var e = 1;
		while (e < k) {
			e *= 2;

			H = subtract(H, shift(low(multiply(mod(high(low(multiply(low(A, e), H), e), e >> 1), p), H), e >> 1), e >> 1));

			H = mod(H, p);
			var c = 1;
			while (e * c < k) {
				c *= 2;
			}
			if ((e - 1) * c >= k) {
				e -= 1;
				H = low(H, e);
			}
		}
		return low(H, e);
	};

	function LaurentSeries(coefficients, lowestDegree) {
		this.coefficients = coefficients;
		this.lowestDegree = lowestDegree;
	}

	LaurentSeries.inverse = function (polynomial, precision, p) {
		var revQ = inv(reversal(polynomial), precision, p);
		var Q = shift(reversal(revQ), precision - 1 - degree(revQ));
		return new LaurentSeries(Q, 0 - degree(polynomial) - (precision - 1));
	};

	LaurentSeries.prototype.multiplyMod1 = function (polynomial, precision, p) {
		var e = this.lowestDegree;
		if (0 - precision - e < degree(polynomial)) {
			throw new RangeError('inacurracy');
		}

		var c = multiply(this.coefficients, polynomial);
		c = low(c, 0 - e);
		c = high(c, 0 - precision - e);
		c = mod(c, p);
		return new LaurentSeries(c, 0 - precision);
	};
	LaurentSeries.prototype.multiplyTrunc = function (polynomial) {
		var e = this.lowestDegree;
		var c = multiply(this.coefficients, polynomial);
		c = high(c, Math.max(0 - e, 0));
		return c;
	};
	LaurentSeries.prototype.toString = function () {
		var s = '';
		for (var i = this.coefficients.length - 1; i >= 0; i -= 1) {
			var c = this.coefficients[i];
			s += (JSBI.greaterThanOrEqual(c, JSBI.BigInt(0)) ? '+' : '') + c + 'x^' + (i + this.lowestDegree);
		}
		return s + '+...';
	};

	function evaluateModP(A, points, p) {

		var simple = false;
		if (simple) {
			var results = new Array(points.length);
			for (var i = 0; i < points.length; i += 1) {
				results[i] = calcAtMod(A, points[i], p);
			}
			return results;
		}
		var makeProductsTree = function (points) {
			if (points.length <= 8) {
				return {
					left: null,
					right: null,
					product: fromRoots(points, p),
					points: points
				};
			}
			var middle = Math.floor(points.length / 2);
			var left = makeProductsTree(points.slice(0, middle));
			var right = makeProductsTree(points.slice(middle));
			var product = mod(multiply(left.product, right.product), p);
			return {
				left: left,
				right: right,
				product: product,
				points: points
			};
		};
		var node = makeProductsTree(points);

		var f = function (UoverPmod1, node, p) {
			if (node.left == null || node.right == null) {
				var R = mod(UoverPmod1.multiplyTrunc(node.product), p);
				var results = new Array(node.points.length);
				for (var i = 0; i < node.points.length; i += 1) {
					results[i] = calcAtMod(R, node.points[i], p);
				}
				return results;
			}
			var P0 = node.left.product;
			var P1 = node.right.product;
			var UoverP0mod1 = UoverPmod1.multiplyMod1(P1, degree(P0), p);
			var UoverP1mod1 = UoverPmod1.multiplyMod1(P0, degree(P1), p);

			return f(UoverP0mod1, node.left, p).concat(f(UoverP1mod1, node.right, p));
		};
		var U = A;
		var P = node.product;
		var Pinv = LaurentSeries.inverse(P, degree(U) + 1, p);
		var UoverPmod1 = Pinv.multiplyMod1(U, degree(P), p);
		return f(UoverPmod1, node, p);
	}

	if (false) {
		console.assert(multiplyKS([JSBI.BigInt(1), JSBI.BigInt(1), JSBI.BigInt(1), JSBI.BigInt(1)], [JSBI.BigInt(1), JSBI.BigInt(1), JSBI.BigInt(1), JSBI.BigInt(1)]).toString() === '1,2,3,4,3,2,1');
		console.assert(multiplySchoolbook([JSBI.BigInt(1), JSBI.BigInt(1), JSBI.BigInt(1), JSBI.BigInt(1)], [JSBI.BigInt(1), JSBI.BigInt(1), JSBI.BigInt(1), JSBI.BigInt(1)]).toString() === '1,2,3,4,3,2,1');
		var p = Polynomial.fromRoots([JSBI.BigInt(1), JSBI.BigInt(2), JSBI.BigInt(3), JSBI.BigInt(4), JSBI.BigInt(5)], JSBI.BigInt(17));
		var vals = Polynomial.evaluateModP(p, [JSBI.BigInt(7), JSBI.BigInt(8), JSBI.BigInt(9), JSBI.BigInt(10), JSBI.BigInt(1)], JSBI.BigInt(17));
		console.assert(vals.toString() === '6,4,5,7,0');
		var P = [JSBI.BigInt(24), JSBI.unaryMinus(JSBI.BigInt(50)), JSBI.BigInt(35), JSBI.unaryMinus(JSBI.BigInt(10)), JSBI.BigInt(1)];
		var Pinv = LaurentSeries.inverse(P, 4, JSBI.leftShift(JSBI.BigInt(1), JSBI.BigInt(1024)));
		console.assert(Pinv.toString() === '+1x^-4+10x^-5+65x^-6+350x^-7+...');
		var Pinv2 = LaurentSeries.inverse(P, 5, JSBI.leftShift(JSBI.BigInt(1), JSBI.BigInt(1024)));
		console.assert(Pinv2.toString() === '+1x^-4+10x^-5+65x^-6+350x^-7+1701x^-8+...');
		var U = [JSBI.BigInt(1), JSBI.BigInt(4), JSBI.BigInt(1), JSBI.BigInt(3)];
		var UoverPmod1 = Pinv.multiplyMod1(U, degree(P), JSBI.leftShift(JSBI.BigInt(1), JSBI.BigInt(1024)));
		console.assert(UoverPmod1.toString() === '+3x^-1+31x^-2+209x^-3+1156x^-4+...');
		var P1 = [JSBI.BigInt(12), JSBI.unaryMinus(JSBI.BigInt(7)), JSBI.BigInt(1)];
		var X = UoverPmod1.multiplyMod1(P1, degree(P1), JSBI.leftShift(JSBI.BigInt(1), JSBI.BigInt(1024)));
		console.assert(X.toString() === '+28x^-1+65x^-2+...');
		var P0 = [JSBI.BigInt(2), JSBI.unaryMinus(JSBI.BigInt(3)), JSBI.BigInt(1)];
		var P0inv = LaurentSeries.inverse(P0, 4, JSBI.leftShift(JSBI.BigInt(1), JSBI.BigInt(1024)));
		var X2 = P0inv.multiplyMod1(U, degree(P0), JSBI.leftShift(JSBI.BigInt(1), JSBI.BigInt(1024)));
		console.assert(String(X.toString()) === String(X2.toString()));

		var R = X.multiplyTrunc(P0);
		console.assert(R.toString() === '-19,28', R);
		var vals = Polynomial.evaluateModP(U, [JSBI.BigInt(1), JSBI.BigInt(2), JSBI.BigInt(3), JSBI.BigInt(4)], JSBI.leftShift(JSBI.BigInt(1), JSBI.BigInt(1024)));
		console.assert(String(vals.toString()) === String([JSBI.BigInt(9), JSBI.BigInt(37), JSBI.BigInt(103), JSBI.BigInt(225)].toString()));
		var tests = [{
			A: [1, 2, 3],
			e: 0,
			B: [1, 2, 3],
			precision: 3,
			result: null
		}, {
			A: [1, 2, 3],
			e: -1,
			B: [1],
			precision: 3,
			result: null
		}, {
			A: [1, 2, 3],
			e: -1,
			B: [1, 2, 3],
			precision: 3,
			result: null
		}, {
			A: [1, 0, 2, 3],
			e: -2,
			B: [1, 2, 3],
			precision: 3,
			result: null
		}, {
			A: [1, 2, 3, 4, 5, 6],
			e: -6,
			B: [1, 2, 3],
			precision: 3,
			result: [16, 22, 28]
		}, {
			A: [1, 2, 3, 4, 5, 6],
			e: -6,
			B: [1, 2, 3, 4, 5, 6],
			precision: 3,
			result: null
		}, {
			A: [1, 2, 3, 4, 5, 6, 7],
			e: -7,
			B: [1, 2, 3, 4, 5, 6],
			precision: 3,
			result: null
		}, {
			A: [1, 2, 3, 4, 5, 6, 7, 8],
			e: -8,
			B: [1, 2, 3, 4, 5, 6],
			precision: 3,
			result: [56, 77, 98]
		}, {
			A: [1, 2, 3, 4],
			e: -4,
			B: [1, 2],
			precision: 4,
			result: null
		}, {
			A: [2, 2, 3, 4],
			e: -4,
			B: [1, 2],
			precision: 4,
			result: null
		}, {
			A: [1, 2, 3, 4],
			e: -4,
			B: [1, 2],
			precision: 3,
			result: [4, 7, 10]
		}, {
			A: [2, 2, 3, 4],
			e: -4,
			B: [1, 2],
			precision: 3,
			result: [6, 7, 10]
		}, {
			A: [1, 2, 3, 4],
			e: -4,
			B: [1, 2],
			precision: 2,
			result: [7, 10]
		}, {
			A: [2, 2, 3, 4],
			e: -4,
			B: [1, 2],
			precision: 2,
			result: [7, 10]
		}

		];

		for (var iteratortest = tests[globalThis.Symbol.iterator](), test = iteratortest.next().value; test != null; test = iteratortest.next().value) {
			try {
				var result = new LaurentSeries(test.A.map(function (n) {
					return JSBI.BigInt(n);
				}), test.e).multiplyMod1(test.B.map(function (n) {
					return JSBI.BigInt(n);
				}), test.precision, JSBI.leftShift(JSBI.BigInt(1), JSBI.BigInt(1024)));
				console.assert(test.result != null && String(new LaurentSeries(test.result.map(function (n) {
					return JSBI.BigInt(n);
				}), 0 - test.precision).toString()) === String(result.toString()));
			} catch (error) {
				console.assert(test.result == null, error);
			}
		}
	}
}

function ModularCRT() {
	function modInverseSmall(a, m) {
		a = +a;
		m = +m;
		var oldR = 0.0;
		var r = 0.0;
		var oldX = 0.0;
		var x = 0.0;
		var q = 0.0;
		var newR = 0.0;
		var newX = 0.0;
		var inv = 0.0;
		oldX = 1.0;
		oldR = a;
		r = m;
		while (r != 0.0) {
			q = +Math.floor(oldR / r + 0.5);
			newR = oldR - q * r;
			newX = oldX - q * x;
			oldR = r;
			oldX = x;
			r = newR;
			x = newX;
		}
		inv = oldX;
		inv = oldR < 0.0 ? -inv : inv;
		inv = inv < 0.0 ? inv + m : inv;
		return +inv;
	}

	function roundMod(a, b) {

		a = a % b;
		return a > b - a ? a - b : a;
	}

	function MixedRadixInt() {
		this.digits = [];
	}

	MixedRadixInt.prototype.computeDigit = function (remainder, mrs) {
		var position = this.digits.length;
		var modInverses = mrs.modInverses[position];
		var modulus = -0.0 + mrs.radixes[position];
		var digit = -0.0 + remainder;
		var modulusInv = 1.0 / modulus;
		if (modulus < Math.pow(2, 26)) {
			for (var j = 0; j < position; j += 1) {
				digit = modInverses[j] * (digit - this.digits[j]);
				digit = digit - Math.floor(digit * modulusInv) * modulus;
			}
		} else {
			throw new RangeError();

		}
		if (digit < -0.0) {
			digit += modulus;
		}
		return digit;
	};
	MixedRadixInt.prototype.computeAndAddDigit = function (remainder, mrs) {
		var digit = this.computeDigit(-0.0 + remainder, mrs);
		this.digits.push(-0.0 + digit);
	};
	MixedRadixInt.prototype.getValue = function (mrs) {
		var value = BigInt(0);
		if (mrs.radixes.length !== 0 && mrs.radixes[0] < Math.pow(2, 26)) {
			console.assert(this.digits.length % 2 === 0);
			for (var i = 0; i < this.digits.length; i += 2) {
				var multiplier = mrs.radixProducts[i];
				var x = this.digits[i] + mrs.radixes[i] * this.digits[i + 1];
				value = value + BigInt(x) * multiplier;
			}
		} else {
			throw new RangeError();

		}
		return roundMod(value, mrs.radixProducts[this.digits.length]);
	};

	function MixedRadixSystem() {
		this.radixes = [];
		this.modInverses = [];
		this.radixProducts = [];
		this.radixProducts.push(BigInt(1));
	}

	MixedRadixSystem.prototype.addRadix = function (radix) {

		var modInverses = new Array(this.radixes.length);
		for (var i = 0; i < this.radixes.length; i += 1) {
			modInverses[i] = -0.0 + modInverseSmall(this.radixes[i], radix);
		}
		this.radixes.push(-0.0 + radix);
		this.modInverses.push(modInverses);
		this.radixProducts.push(BigInt(radix) * this.radixProducts[this.radixProducts.length - 1]);
	};

	var cachedCRT = {
		moduli: [],
		crt: undefined
	};

	function CRT(array) {

		var valid = true;
		for (var i = 0, k = Math.min(cachedCRT.moduli.length, array.length); i < k; i += 1) {
			if (cachedCRT.moduli[i] !== array[i].modulus) {
				valid = false;
				console.warn('why?');
			}
		}
		if (!valid || cachedCRT.crt == undefined) {
			cachedCRT.crt = new MixedRadixSystem();
			cachedCRT.moduli = [];
		}
		var mrs = cachedCRT.crt;
		for (var i = cachedCRT.moduli.length; i < array.length; i += 1) {
			var m = array[i].modulus;
			mrs.addRadix(m);
			cachedCRT.moduli.push(m);
		}

		var solution = new MixedRadixInt();
		for (var i = 0; i < array.length; i += 1) {
			solution.computeAndAddDigit(array[i].integer, mrs);
		}
		return solution.getValue(mrs);
	}

	self.CRT = CRT;
}

function FactorizationAlgos() {
	globalThis.QuadraticSieveFactorization = QuadraticSieveFactorization;
	globalThis.PollardsRho64 = PollardsRho64;

	function bitLength(a) {
		if (typeof a === 'number') {
			var v = a | 0;
			if (v === a && v >= 0) {
				return 32 - Math.clz32(v);
			}
		}
		var s = a.toString(16);
		var c = 0 + s.charCodeAt(0) - '0'.charCodeAt(0);
		if (c <= 0) {
			throw new RangeError();
		}
		return (s.length - 1) * 4 + (32 - Math.clz32(Math.min(c, 8)));
	}

	var WHEEL3 = [1, 2, 2, 4, 2, 4, 2, 4, 6, 2, 6];

	function remainder(n, i) {

		return n - Math.floor(n / i) * i;
	}

	function primeFactorUsingWheel(n, max) {
		max = max == undefined ? undefined : max;
		if (typeof n !== 'number') {
			throw new RangeError();
		}
		var steps = WHEEL3;
		var cycle = 3;
		if (max == undefined) {
			max = Math.floor(Math.sqrt(Number(n) + 0.5));
		}
		var i = 2;
		var s = 0;
		while (i <= max) {
			if (remainder(n, i) === 0) {
				return i;
			}
			i += steps[s];
			s += 1;
			if (s === steps.length) {
				s = cycle;
			}
		}
		return n;
	}

	var bigIntWasmSupportChecked = false;

	function checkBigIntWasmSupport() {
		if (!bigIntWasmSupportChecked) {

			try {
				if (+isPrime64(JSBI.BigInt(2)) === 0) {
					isPrime64 = null;
				}
			} catch (e) {

				isPrime64 = null;
				PollardsRho64 = null;
			}
			bigIntWasmSupportChecked = true;
		}
	}

	function _isPrime(n) {
		var a = JSBI.BigInt(n);
		checkBigIntWasmSupport();
		if (isPrime64 != null && JSBI.lessThanOrEqual(a, JSBI.BigInt("18446744073709551615"))) {
			return +isPrime64(a) !== 0;
		}
		return +isPrime(a) !== 0;
	}

	function someFactor(n) {
		var x = +(typeof n === "number" ? n : JSBI.toNumber(JSBI.BigInt(n)));
		if (x < 1) {
			throw new TypeError("primeFactor cannot be called for numbers less than 2");
		}
		if (x === 1) {
			return n;
		}

		if (x <= Number.MAX_SAFE_INTEGER) {
			var pf = primeFactorUsingWheel(x, 1024);
			if (pf < x) {
				return JSBI.BigInt(pf);
			}
			if (x <= 1024 * 1024) {
				return JSBI.BigInt(pf);
			}
			if (x % 2 === 0) {
				return JSBI.BigInt(2);
			}
		}

		var squareRoot = JSBI.BigInt(nthRoot(JSBI.BigInt(n), 2));
		if (JSBI.equal(JSBI.exponentiate(squareRoot, JSBI.BigInt(2)), n)) {
			return squareRoot;
		}
		if (x > 5) {

			var a = JSBI.add(squareRoot, JSBI.BigInt(1));
			var b2 = JSBI.subtract(JSBI.multiply(a, a), JSBI.BigInt(n));
			var b = JSBI.BigInt(nthRoot(JSBI.BigInt(b2), 2));
			if (JSBI.equal(JSBI.multiply(b, b), b2)) {

				return JSBI.subtract(a, b);
			}
		}

		var size = bitLength(JSBI.BigInt(n));
		for (var k = 3; k <= size / 10; k += 2) {
			var root = JSBI.BigInt(nthRoot(JSBI.BigInt(n), k));
			if (JSBI.equal(JSBI.exponentiate(root, JSBI.BigInt(k)), JSBI.BigInt(n))) {
				return root;
			}
		}
		if (_isPrime(n)) {
			return n;
		}
		if (PollardsRho64 != null && JSBI.lessThanOrEqual(JSBI.BigInt(n), JSBI.BigInt("18446744073709551615"))) {

			return JSBI.toNumber(JSBI.BigInt(PollardsRho64(JSBI.BigInt(n), Math.pow(2, 20))));
		}
		if (true) {
			var L = function (n) {
				var e = Math.max(0, n.toString(16).length * 4 - 48);
				var lnn = (Math.log2(JSBI.toNumber(JSBI.signedRightShift(JSBI.BigInt(n), JSBI.BigInt(e)))) + e) * Math.LN2;
				return Math.exp(Math.sqrt(lnn * Math.log(lnn)));
			};

			var limit = Math.floor(Math.log(L(n)));
			if (typeof WebAssembly === 'undefined') {

				limit = 1 / 0;
			}
			limit -= 2;
			if (x >= Math.pow(2, 128)) {

				limit -= 3;
			} else if (x >= Math.pow(2, 96)) {
				limit -= 2;
			} else {
				limit -= 1;
			}

			var s = +Date.now();
			var factor = limit >= 20 && limit < 1 / 0 || true ? JSBI.BigInt(ecm(n)) : JSBI.BigInt(PollardsRho(n, Math.pow(2, limit)));
			var e = +Date.now();
			if (e - s > 1000) {
				console.warn(e - s, n, limit);
			}
			if (JSBI.notEqual(factor, JSBI.BigInt(1)) && JSBI.notEqual(factor, JSBI.BigInt(0))) {
				return factor;
			}
			if (true) {
				if (globalThis.onerror != null) {
					var size = bitLength(n);
					var error = new TypeError("big size of " + "someFactor " + "bitLength(" + n + ")" + " === " + size);
					globalThis.onerror(error.message, "", 0, 0, error);
				}
			}
			return QuadraticSieveFactorization(n);
		}

		return JSBI.BigInt(ecm(n, true));
	}

	function ctz32(a) {
		return 32 - (Math.clz32(a & -a) + 1);
	}

	function ctz(a) {
		var test = JSBI.asUintN(32, a);
		if (JSBI.notEqual(test, JSBI.BigInt(0))) {
			return ctz32(JSBI.toNumber(test));
		}
		var k = 32;
		while (JSBI.equal(JSBI.asUintN(k, a), JSBI.BigInt(0))) {
			k *= 2;
		}
		var n = 0;
		for (var i = Math.floor(k / 2); i >= 32; i = Math.floor(i / 2)) {
			if (JSBI.equal(JSBI.asUintN(i, a), JSBI.BigInt(0))) {
				n += i;
				a = JSBI.signedRightShift(a, JSBI.BigInt(i));
			} else {
				a = JSBI.asUintN(i, a);
			}
		}
		n += ctz32(JSBI.toNumber(JSBI.BigInt(JSBI.asUintN(32, a))));
		return n;
	}

	function countTrailingZeros(x, base) {

		x = JSBI.BigInt(x);
		var b = JSBI.BigInt(base);
		if (JSBI.lessThan(x, JSBI.BigInt(0)) || JSBI.lessThan(b, JSBI.BigInt(0))) {
			throw new RangeError();
		}
		if (JSBI.equal(x, b)) {
			return 1;
		}

		if (JSBI.equal(x, JSBI.BigInt(0))) {
			throw new TypeError();
		}
		if (JSBI.equal(b, JSBI.BigInt(2))) {
			return ctz(x);
		}
		var k = 1;
		while (JSBI.equal(JSBI.remainder(x, JSBI.exponentiate(b, JSBI.BigInt(k))), JSBI.BigInt(0))) {
			k *= 2;
		}
		var n = 0;
		for (var i = k / 2; i >= 1; i /= 2) {
			var v = JSBI.exponentiate(b, JSBI.BigInt(i));
			var q = JSBI.divide(JSBI.BigInt(x), v);
			var r = JSBI.subtract(JSBI.BigInt(x), JSBI.multiply(q, JSBI.BigInt(v)));
			if (JSBI.equal(r, JSBI.BigInt(0))) {
				n = +n + i;
				x = q;
			}
		}
		return n;
	}

	primeFactor._rationalNumberToDecimalString = function (n, d, rounding) {

		var getPeriodOfRepeatingDecimalSegment = function (denominator, limit) {

			denominator = JSBI.BigInt(denominator);
			if (JSBI.equal(JSBI.remainder(denominator, JSBI.BigInt(2)), JSBI.BigInt(0)) || JSBI.equal(JSBI.remainder(denominator, JSBI.BigInt(5)), JSBI.BigInt(0))) {
				throw new RangeError("should be called with denominator not divible by 2 or 5");
			}
			var n = denominator;
			var period = 0;
			if (JSBI.notEqual(n, JSBI.BigInt(1))) {
				var z = JSBI.BigInt(1);
				do {
					period += 1;
					z = JSBI.remainder(JSBI.multiply(JSBI.BigInt(10), z), n);
				} while (period <= limit && JSBI.notEqual(z, JSBI.BigInt(1)));
			}
			return period;
		};
		var bigDecimalToPlainString = function (significand, exponent, minFraction, minSignificant) {
			var e = +exponent + significand.length - 1;
			significand = significand.replace(/0+$/g, '');
			var zeros = Math.max(0, Math.max(e + 1, minSignificant) - significand.length);
			if (e <= -1) {
				significand = String("0".repeat(0 - e)) + String(significand);
				e = 0;
			}
			significand = String(significand) + String("0".repeat(zeros));
			significand = String(significand) + String("0".repeat(Math.max(minFraction - (significand.length - (e + 1)), 0)));
			return significand.slice(0, e + 1) + (significand.length > e + 1 ? "." + significand.slice(e + 1) : "");
		};

		var toPrecision = function (significand, exponent, minSignificant) {
			var e = +exponent + significand.length - 1;
			if (e < -6 || e >= minSignificant) {
				return bigDecimalToPlainString(significand, -(significand.length - 1), 0, minSignificant) + 'e' + (e < 0 ? '-' : '') + Math.abs(e).toString();
			}
			return bigDecimalToPlainString(significand, exponent, 0, minSignificant);
		};
		var digitsToDecimalNumber = function (significand, exponent, rounding) {

			if (rounding.significantDigits != undefined) {
				return toPrecision(significand, exponent, rounding.significantDigits);
			}
			return bigDecimalToPlainString(significand, exponent, rounding.fractionDigits, 0);
		};
		n = JSBI.BigInt(n);
		d = JSBI.BigInt(d);
		var sign = +1;
		if (JSBI.lessThan(d, JSBI.BigInt(0))) {
			d = JSBI.unaryMinus(JSBI.BigInt(d));
			sign = -sign;
		}
		if (JSBI.lessThan(n, JSBI.BigInt(0))) {
			n = JSBI.unaryMinus(JSBI.BigInt(n));
			sign = -sign;
		}
		var floorOfLog10 = function (n, d) {

			var guess = Math.floor((bitLength(n) - 1 - bitLength(d)) / Math.log2(10));
			while (JSBI.greaterThanOrEqual(JSBI.BigInt(guess < 0 ? JSBI.multiply(JSBI.exponentiate(JSBI.BigInt(10), JSBI.BigInt(-guess)), n) : n), JSBI.BigInt(guess > 0 ? JSBI.multiply(JSBI.exponentiate(JSBI.BigInt(10), JSBI.BigInt(guess)), d) : d))) {
				guess += 1;
			}
			return guess - 1;
		};
		var a = primeFactor._countTrailingZeros(d, 2);
		var b = primeFactor._countTrailingZeros(d, 5);
		if (a > 0 && JSBI.equal(JSBI.remainder(n, JSBI.BigInt(2)), JSBI.BigInt(0))) {
			throw new RangeError("not implemented");
		}
		if (b > 0 && JSBI.equal(JSBI.remainder(n, JSBI.BigInt(5)), JSBI.BigInt(0))) {
			throw new RangeError("not implemented");
		}
		var d1 = JSBI.divide(d, JSBI.multiply(JSBI.exponentiate(JSBI.BigInt(2), JSBI.BigInt(a)), JSBI.exponentiate(JSBI.BigInt(5), JSBI.BigInt(b))));
		var lengthOfTransient = +Math.max(a, b);
		if ((rounding.fractionDigits != undefined && lengthOfTransient <= rounding.fractionDigits || rounding.significantDigits != undefined && lengthOfTransient + (floorOfLog10(n, d) + 1) - primeFactor._countTrailingZeros(n, 10) <= rounding.significantDigits) && JSBI.equal(JSBI.remainder(n, d1), JSBI.BigInt(0))) {

			var scaling = lengthOfTransient;
			var result = JSBI.divide(JSBI.multiply(JSBI.exponentiate(JSBI.BigInt(10), JSBI.BigInt(scaling)), n), d).toString();
			var minRounding = rounding.fractionDigits != undefined ? {
				fractionDigits: lengthOfTransient
			} : {
				significantDigits: lengthOfTransient + (floorOfLog10(n, d) + 1) <= rounding.significantDigits ? lengthOfTransient + (floorOfLog10(n, d) + 1) : lengthOfTransient + (floorOfLog10(n, d) + 1) - primeFactor._countTrailingZeros(n, 10)
			};
			var f = (sign < 0 ? '-' : '') + digitsToDecimalNumber(result, -scaling, minRounding);
			return f;
		} else {
			var scaling = +(rounding.fractionDigits != undefined ? rounding.fractionDigits : rounding.significantDigits - (floorOfLog10(n, d) + 1));
			var sn = scaling > 0 ? JSBI.multiply(JSBI.exponentiate(JSBI.BigInt(10), JSBI.BigInt(scaling)), n) : n;
			var sd = scaling < 0 ? JSBI.multiply(JSBI.exponentiate(JSBI.BigInt(10), JSBI.BigInt(-scaling)), d) : d;
			var result = JSBI.divide(JSBI.add(sn, JSBI.divide(sd, JSBI.BigInt(2))), sd).toString();
			var f = (sign < 0 ? '-' : '') + digitsToDecimalNumber(result, -scaling, rounding);
			var period = +getPeriodOfRepeatingDecimalSegment(d1, f.length);

			if (period !== 0 && period <= f.length) {

				var j = f.indexOf('.');
				var offset = j + 1 + lengthOfTransient - (f.indexOf('e') !== -1 ? -Number(String(f.slice(f.indexOf('e') + 1))) - 0 : 0) - primeFactor._countTrailingZeros(n, 10);
				if (offset < j + 1) {

					offset = j + 1;
				}

				var lastFractionDigit = f.indexOf('e') !== -1 ? f.indexOf('e') : f.length;
				if (j !== -1 && (offset + period < lastFractionDigit || offset + period === lastFractionDigit && +f.charCodeAt(offset) < '5'.charCodeAt(0))) {
					f = f.slice(0, offset) + '(' + f.slice(offset, offset + period) + ')' + f.slice(offset + period);
				}
			}
			if (!/[^0\.]/.test(f) && sign >= 0 && JSBI.notEqual(n, JSBI.BigInt(0))) {
				f = '+' + f;
			}
			return f;
		}
	};

	function primeFactor(n) {
		n = JSBI.BigInt(n);
		var factor = JSBI.BigInt(someFactor(n));
		if (JSBI.equal(factor, n)) {
			return factor;
		}

		var a = primeFactor(factor);

		return a;
	}

	function modInverseSmall(a, m) {
		if (typeof a !== 'number' || typeof m !== 'number') {
			throw new TypeError();
		}
		if (m < 0) {
			throw new RangeError();
		}
		console.assert(a >= 0);
		if (a >= m) {
			if (a < 0 || a >= Math.pow(2, 53) || m >= Math.pow(2, 53)) throw new Error();
			a = a - Math.floor(a / m) * m;
		}
		var oldR = a;
		var r = m;
		var oldX = 1;
		var x = 0;
		while (r !== 0) {
			var q = Math.floor(oldR / r);
			var newR = oldR - q * r;
			oldR = r;
			r = newR;
			var newX = oldX - q * x;
			oldX = x;
			x = newX;
		}
		var inv = oldX;
		inv = inv < 0 ? inv + m : inv;
		console.assert(inv >= 0 && inv < m);
		return inv;
	}

	function modInverse(a, m) {
		if (typeof m === "number") {
			if (typeof a === "number") {
				return modInverseSmall(a, m);
			}
			return modInverseSmall(JSBI.toNumber(JSBI.remainder(JSBI.BigInt(a), JSBI.BigInt(m))), m);
		}
		if (JSBI.greaterThanOrEqual(JSBI.BigInt(a), JSBI.BigInt(m))) {

			console.assert('a >= m');
			a = JSBI.remainder(JSBI.BigInt(a), JSBI.BigInt(m));
		}

		return gcd.invmod(JSBI.BigInt(a), JSBI.BigInt(m));
	}

	primeFactor._bitLength = bitLength;
	primeFactor._isPrime = _isPrime;
	primeFactor._countTrailingZeros = countTrailingZeros;
	primeFactor._someFactor = someFactor;
	primeFactor._modInverse = modInverse;
	primeFactor._integerNthRoot = function (a, n) {
		return nthRoot(JSBI.BigInt(a), n);
	};
	primeFactor.testables = {
		factorByPollardRhoSmall: PollardsRho64,

		QuadraticSieveFactorization: QuadraticSieveFactorization
	};
	self.primeFactor = primeFactor;
}

function BigDecimal() {
	var factory = function (BASE, format) {
		format = format == undefined ? null : format;
		var BIGINT_BASE = JSBI.BigInt(BASE);
		var BASE_LOG2 = Math.log2(BASE);
		var BASE_LOG2_INV = 1 / Math.log2(BASE);
		var NumberSafeBits = Math.floor(Math.log2(Number.MAX_SAFE_INTEGER + 1));
		var parseRegex = /^\s*([+\-])?(\d+)?\.?(\d+)?(?:e([+\-]?\d+))?\s*$/;
		var defaultRounding = format === 'decimal128' ? {
			maximumFractionDigits: 6176,
			maximumSignificantDigits: 34,
			maximumExponent: 6144,
			roundingMode: 'half-even'
		} : null;

		function getExponent(number) {
			var e = Math.floor(Math.log(Math.abs(number)) / Math.log(2)) - 1;
			return Math.abs(number) / Math.pow(2, e) >= 2 ? e + 1 : e;
		}

		function convert(value) {
			if (value instanceof BigDecimal) {
				return value;
			}
			if (typeof value === "string") {
				if (BASE !== 10) {
					throw new Error();
				}
				if (format != null) {
					if (value === 'Infinity') {
						return create(JSBI.BigInt(1), SPECIAL_EXPONENT);
					}
					if (value === '-Infinity') {
						return create(JSBI.unaryMinus(JSBI.BigInt(1)), SPECIAL_EXPONENT);
					}
					if (value === 'NaN') {
						return create(JSBI.BigInt(0), SPECIAL_EXPONENT);
					}
					if (value === '-0') {
						return create(JSBI.unaryMinus(JSBI.BigInt(1)), -SPECIAL_EXPONENT);
					}
				}
				var match = parseRegex.exec(value);
				if (match == null) {
					throw new RangeError(value);
				}
				var sign = match[1] || "";
				var integer = match[2] || "";
				var fraction = match[3] || "";
				var exponent = match[4] || "0";
				var result = round(create(JSBI.BigInt(sign + integer + fraction), diff(Math.abs(exponent) < Number.MAX_SAFE_INTEGER ? exponent : JSBI.BigInt(match[4] || "0"), (match[3] || "").length)), null);
				if (format != null) {
					if (sign === "-" && JSBI.equal(result.significand, JSBI.BigInt(0))) {
						result = BigDecimal.unaryMinus(result);
					}
				}
				return result;
			}
			if (typeof value === "number" && Math.floor(value) !== value) {
				if (BASE === 2) {
					var e = getExponent(value);
					var f = value / Math.pow(2, e);
					var significand = f * (Number.MAX_SAFE_INTEGER + 1) / 2;
					var exponent = e - (NumberSafeBits - 1);
					return create(JSBI.BigInt(significand), exponent);
				}

				if (format != null) {
					var e = getExponent(value);
					var f = value / Math.pow(2, e);
					var significand = f * (Number.MAX_SAFE_INTEGER + 1) / 2;
					var exponent = e - (NumberSafeBits - 1);
					if (exponent >= 0) {
						return BigDecimal.multiply(create(JSBI.BigInt(significand), 0), create(JSBI.exponentiate(JSBI.BigInt(2), JSBI.BigInt(exponent)), 0));
					} else if (exponent < 0) {
						return BigDecimal.divide(create(JSBI.BigInt(significand), 0), create(JSBI.exponentiate(JSBI.BigInt(2), JSBI.BigInt(-exponent)), 0));
					}
				}
			}
			if (value === 0 && 1 / value < 0) {
				if (format != null) {
					return create(JSBI.unaryMinus(JSBI.BigInt(1)), -SPECIAL_EXPONENT);
				}
				throw new RangeError();
			}
			var a = create(JSBI.BigInt(value), 0);

			if (format != null) {
				a = round(a, defaultRounding);
			}
			return a;
		}

		function BigDecimal(significand, exponent) {
			if (!(this instanceof BigDecimal)) {
				return convert(significand);
			}
			this.significand = significand;
			this.exponent = exponent;
		}

		var SPECIAL_EXPONENT = 1 / 0;

		var toBigInt = function (a) {
			var e = a.exponent;
			var exponent = typeof e === 'number' ? e : JSBI.toNumber(JSBI.BigInt(e));
			if (exponent === 0) {
				return a.significand;
			}
			if (exponent < 0) {
				var result = bigIntUnscale(a.significand, 0 - exponent);
				if (JSBI.notEqual(bigIntScale(result, 0 - exponent), JSBI.BigInt(a.significand))) {
					throw new RangeError("The BigDecimal " + a.toString() + " cannot be converted to a BigInt because it is not an integer");
				}
				return result;
			}
			return bigIntScale(a.significand, exponent);
		};
		var abs = function (a) {
			return JSBI.lessThan(a.significand, JSBI.BigInt(0)) ? BigDecimal.unaryMinus(a) : a;
		};

		function getCountOfDigits(a) {

			if (JSBI.equal(a.significand, JSBI.BigInt(0))) {
				throw new RangeError();
			}
			return JSBI.add(JSBI.BigInt(digits(a.significand)), JSBI.BigInt(a.exponent));
		}

		function exponentiateBase(n) {
			return create(BASE, n);
		}

		function create(significand, exponent) {
			return (new BigDecimal(significand, exponent));
		}

		function bigIntAbs(a) {
			return JSBI.lessThan(a, JSBI.BigInt(0)) ? JSBI.subtract(JSBI.BigInt(0), a) : a;
		}

		function bitLength(a) {
			var s = a.toString(16);
			var c = +s.charCodeAt(0) - +"0".charCodeAt(0);
			if (c <= 0) {
				throw new RangeError();
			}
			return (s.length - 1) * 4 + (32 - Math.clz32(Math.min(c, 8)));
		}

		function bigIntLog2(n) {
			var k = bitLength(n) - NumberSafeBits;
			var leadingDigits = JSBI.toNumber(JSBI.signedRightShift(n, JSBI.BigInt(k)));
			return Math.log2(leadingDigits) + k;
		}

		function digits(a) {

			a = bigIntAbs(a);
			if (BASE === 2) {
				return bitLength(a);
			}
			var number = JSBI.toNumber(JSBI.BigInt(a));
			if (number < (Number.MAX_SAFE_INTEGER + 1) / 16) {
				return Math.floor(Math.log2(number + 0.5) * BASE_LOG2_INV) + 1;
			}
			var e = (number < 1 / 0 ? Math.log2(number) : bigIntLog2(a)) * BASE_LOG2_INV;
			if (Math.floor(e * (1 - 32 / (Number.MAX_SAFE_INTEGER + 1))) === Math.floor(e) && Math.floor(e * (1 + 32 / (Number.MAX_SAFE_INTEGER + 1))) === Math.floor(e)) {
				return Math.floor(e) + 1;
			}
			var i = Math.floor(e + 0.5);
			return JSBI.greaterThanOrEqual(a, JSBI.BigInt(cachedPower(i))) ? i + 1 : i;
		}

		function sum(a, b) {
			if (typeof a === "number" && typeof b === "number") {
				var value = a + b;
				if (Math.abs(value) <= +Number.MAX_SAFE_INTEGER) {
					return value;
				}
			}
			var v = JSBI.add(JSBI.BigInt(a), JSBI.BigInt(b));
			var nv = JSBI.toNumber(v);
			if (Math.abs(nv) <= +Number.MAX_SAFE_INTEGER) {
				return nv;
			}
			return v;
		}

		function diff(a, b) {
			return sum(a, typeof b === 'number' ? 0 - b : JSBI.unaryMinus(JSBI.BigInt(b)));
		}

		var E = Math.ceil(0.5 * Math.log2(Number.MAX_SAFE_INTEGER + 1) / Math.log2(BASE) - 1);
		var N = JSBI.BigInt(Math.pow(BASE, E));

		function normalize(a, rounding) {
			if (rounding == null || rounding.maximumSignificantDigits != null) {
				if (JSBI.equal(a.significand, JSBI.BigInt(0))) {
					return a.exponent === 0 ? a : create(JSBI.BigInt(0), 0);
				}
				var dividend = a.significand;
				var e = E;
				var divisor = N;
				if (JSBI.equal(JSBI.remainder(dividend, divisor), JSBI.BigInt(0))) {
					while (JSBI.equal(JSBI.remainder(dividend, JSBI.multiply(divisor, divisor)), JSBI.BigInt(0))) {
						divisor = JSBI.multiply(divisor, divisor);
						e *= 2;
					}
					var quotient = JSBI.divide(dividend, divisor);
					return create(quotient, sum(a.exponent, e));
				}
			}
			return a;
		}

		function cachedFunction(f) {
			var cache = {};
			var cacheSize = 0;
			return function (k) {
				var lastValue = cache[k];
				if (lastValue == null) {
					if (cacheSize > 100) {
						cache = {};
						cacheSize = 0;
					}
					lastValue = f(k);
					cache[k] = lastValue;
					cacheSize += 1;
				}
				return lastValue;
			};
		}

		var cachedBigInt = cachedFunction(function (k) {

			return JSBI.BigInt(k);
		});
		var cachedPower = cachedFunction(function (k) {
			return JSBI.exponentiate(BIGINT_BASE, JSBI.BigInt(k));
		});

		function applyMaxExponent(x, rounding) {
			var maximumExponent = rounding.maximumExponent;
			if (maximumExponent != null) {
				if (digits(x.significand) - 1 + x.exponent > maximumExponent) {
					return JSBI.equal(x.significand, JSBI.BigInt(0)) ? create(JSBI.BigInt(0), 0) : create(JSBI.lessThan(x.significand, JSBI.BigInt(0)) ? JSBI.unaryMinus(JSBI.BigInt(1)) : JSBI.BigInt(1), SPECIAL_EXPONENT);
				}
			}
			return x;
		}

		function round(a, rounding) {
			if (format === 'decimal128') {
				if (rounding == null) {
					return round(a, defaultRounding);
				}
				if (Math.abs(a.exponent) === SPECIAL_EXPONENT) {
					return a;
				}
			}
			if (rounding != null) {
				var k = 0;
				var dividend = JSBI.BigInt(a.significand);
				var exponent = a.exponent;
				var maximumSignificantDigits = rounding.maximumSignificantDigits;
				if (maximumSignificantDigits != null) {
					if (!(maximumSignificantDigits > 0)) {
						throw new RangeError("maximumSignificantDigits should be positive");
					}
					if (JSBI.equal(dividend, JSBI.BigInt(0))) {
						return create(JSBI.BigInt(0), 0);
					}
					k = Math.max(k, digits(dividend) - maximumSignificantDigits);
				}
				var maximumFractionDigits = rounding.maximumFractionDigits;
				if (maximumFractionDigits != null) {
					if (!(maximumFractionDigits >= 0)) {
						throw new RangeError("maximumFractionDigits should be non-negative");
					}
					k = Math.max(k, 0 - sum(exponent, maximumFractionDigits));

				}

				if (k > 0) {
					var roundingMode = rounding.roundingMode;
					var quotient = JSBI.BigInt(0);
					if (roundingMode === "floor") {
						if (BASE === 2) {
							quotient = JSBI.signedRightShift(dividend, cachedBigInt(k));
						} else {
							if (JSBI.greaterThanOrEqual(dividend, JSBI.BigInt(0))) {
								quotient = JSBI.divide(dividend, cachedPower(k));
							} else {
								quotient = JSBI.subtract(JSBI.divide(JSBI.add(dividend, JSBI.BigInt(1)), cachedPower(k)), JSBI.BigInt(1));
							}
						}
					} else if (roundingMode === "down") {
						if (BASE === 2) {
							if (JSBI.greaterThanOrEqual(dividend, JSBI.BigInt(0))) {
								quotient = JSBI.signedRightShift(dividend, cachedBigInt(k));
							} else {
								quotient = JSBI.unaryMinus(JSBI.signedRightShift(JSBI.unaryMinus(dividend), cachedBigInt(k)));
							}
						} else {
							quotient = JSBI.divide(dividend, cachedPower(k));
						}
					} else if (roundingMode === "ceil") {
						if (BASE === 2) {
							quotient = JSBI.unaryMinus(JSBI.signedRightShift(JSBI.unaryMinus(dividend), cachedBigInt(k)));
						} else {
							if (JSBI.lessThan(dividend, JSBI.BigInt(0))) {
								quotient = JSBI.divide(dividend, cachedPower(k));
							} else {
								quotient = JSBI.add(JSBI.divide(JSBI.subtract(dividend, JSBI.BigInt(1)), cachedPower(k)), JSBI.BigInt(1));
							}
						}
					} else if (roundingMode === "up") {
						if (BASE === 2) {
							if (JSBI.greaterThanOrEqual(dividend, JSBI.BigInt(0))) {
								quotient = JSBI.unaryMinus(JSBI.signedRightShift(JSBI.unaryMinus(dividend), cachedBigInt(k)));
							} else {
								quotient = JSBI.signedRightShift(dividend, cachedBigInt(k));
							}
						} else {
							if (JSBI.greaterThanOrEqual(dividend, JSBI.BigInt(0))) {
								quotient = JSBI.add(JSBI.divide(JSBI.subtract(dividend, JSBI.BigInt(1)), cachedPower(k)), JSBI.BigInt(1));
							} else {
								quotient = JSBI.subtract(JSBI.divide(JSBI.add(dividend, JSBI.BigInt(1)), cachedPower(k)), JSBI.BigInt(1));
							}
						}
					} else {
						var divisor = JSBI.BigInt(0);
						var twoRemainders = JSBI.BigInt(0);
						if (BASE === 2) {
							var K = cachedBigInt(k);
							divisor = JSBI.leftShift(JSBI.BigInt(1), K);
							if (JSBI.greaterThanOrEqual(dividend, JSBI.BigInt(0))) {
								quotient = JSBI.signedRightShift(dividend, K);
							} else {
								quotient = JSBI.unaryMinus(JSBI.signedRightShift(JSBI.unaryMinus(dividend), K));
							}
							twoRemainders = JSBI.multiply(JSBI.subtract(dividend, JSBI.leftShift(quotient, K)), JSBI.BigInt(2));
						} else {
							divisor = cachedPower(k);
							quotient = JSBI.divide(dividend, divisor);
							twoRemainders = JSBI.multiply(JSBI.subtract(dividend, JSBI.multiply(divisor, quotient)), JSBI.BigInt(2));
						}
						if (JSBI.notEqual(twoRemainders, JSBI.BigInt(0))) {
							if (roundingMode === "half-up") {
								twoRemainders = JSBI.add(twoRemainders, JSBI.lessThan(twoRemainders, JSBI.BigInt(0)) ? JSBI.unaryMinus(JSBI.BigInt(1)) : JSBI.BigInt(1));
							} else if (roundingMode === "half-down") {
								twoRemainders = JSBI.add(twoRemainders, JSBI.BigInt(0));
							} else if (roundingMode === "half-even") {
								twoRemainders = JSBI.add(twoRemainders, JSBI.remainder(quotient, JSBI.BigInt(2)));
							} else {
								throw new RangeError("supported roundingMode (floor/ceil/up/down/half-even/half-up/half-down) is not given");
							}
							if (JSBI.greaterThan(twoRemainders, divisor)) {
								quotient = JSBI.add(quotient, JSBI.BigInt(1));
							}
							if (JSBI.greaterThan(JSBI.unaryMinus(twoRemainders), divisor)) {
								quotient = JSBI.subtract(quotient, JSBI.BigInt(1));
							}
						}
					}
					var e = sum(exponent, k);
					return applyMaxExponent(create(quotient, e), rounding);
				}
				return applyMaxExponent(a, rounding);
			}
			return a;
		}

		BigDecimal.unaryMinus = function (a) {
			if (format != null) {
				if (a.exponent === -SPECIAL_EXPONENT) {
					return create(JSBI.BigInt(0), 0);
				}
				if (JSBI.equal(a.significand, JSBI.BigInt(0)) && a.exponent !== SPECIAL_EXPONENT) {
					return create(JSBI.unaryMinus(JSBI.BigInt(1)), -SPECIAL_EXPONENT);
				}
			}
			return create(JSBI.unaryMinus(JSBI.BigInt(a.significand)), a.exponent);
		};

		function tonum(x) {

			return (JSBI.lessThan(x.significand, JSBI.BigInt(0)) ? -1 : JSBI.greaterThan(x.significand, JSBI.BigInt(0)) ? +1 : 0) * (Math.abs(x.exponent) !== SPECIAL_EXPONENT ? 1 : Math.pow(BASE, x.exponent));
		}

		function fromnum(x) {
			if (x !== x) {
				return create(JSBI.BigInt(0), SPECIAL_EXPONENT);
			}
			if (x === +1 / 0) {
				return create(JSBI.BigInt(1), SPECIAL_EXPONENT);
			}
			if (x === -1 / 0) {
				return create(JSBI.unaryMinus(JSBI.BigInt(1)), SPECIAL_EXPONENT);
			}
			if (x === 0 && 1 / x > 0) {
				return create(JSBI.BigInt(0), 0);
			}
			if (x === 0 && 1 / x < 0) {
				return create(JSBI.unaryMinus(JSBI.BigInt(1)), -SPECIAL_EXPONENT);
			}
			throw new Error(x);
		}

		BigDecimal.add = function (a, b, rounding) {
			rounding = rounding == undefined ? defaultRounding : rounding;
			var as = JSBI.BigInt(a.significand);
			var bs = JSBI.BigInt(b.significand);
			var ae = a.exponent;
			var be = b.exponent;
			if (format != null) {
				if (ae === -SPECIAL_EXPONENT || be === -SPECIAL_EXPONENT) {
					if (ae === -SPECIAL_EXPONENT && be !== -SPECIAL_EXPONENT) {
						return round(b, rounding);
					}
					if (be === -SPECIAL_EXPONENT && ae !== -SPECIAL_EXPONENT) {
						return round(a, rounding);
					}
					return create(JSBI.unaryMinus(JSBI.BigInt(1)), -SPECIAL_EXPONENT);
				}
				if (Math.abs(a.exponent) === SPECIAL_EXPONENT || Math.abs(b.exponent) === SPECIAL_EXPONENT) {
					return fromnum(tonum(a) + tonum(b));
				}
			}
			var bd = diff(ae, be);
			var d = typeof bd === 'number' ? bd : JSBI.toNumber(JSBI.BigInt(bd));
			if (d !== 0) {

				if (JSBI.equal(as, JSBI.BigInt(0))) {
					return round(b, rounding);
				}
				if (JSBI.equal(bs, JSBI.BigInt(0))) {
					return round(a, rounding);
				}
				var msdp1 = rounding != null ? rounding.maximumSignificantDigits + 1 : 0;
				if (d > 0) {
					if (msdp1 !== 0 && d > digits(bs) + msdp1) {
						return round(create(JSBI.add(bigIntScale(as, msdp1), JSBI.lessThan(bs, JSBI.BigInt(0)) ? JSBI.unaryMinus(JSBI.BigInt(1)) : JSBI.BigInt(1)), diff(ae, msdp1)), rounding);
					}
					return round(create(JSBI.add(bigIntScale(as, d), bs), be), rounding);
				}
				if (d < 0) {
					if (msdp1 !== 0 && 0 - d > digits(as) + msdp1) {
						return round(create(JSBI.add(JSBI.lessThan(as, JSBI.BigInt(0)) ? JSBI.unaryMinus(JSBI.BigInt(1)) : JSBI.BigInt(1), bigIntScale(bs, msdp1)), diff(be, msdp1)), rounding);
					}
					return round(create(JSBI.add(as, bigIntScale(bs, 0 - d)), ae), rounding);
				}
			}
			return round(create(JSBI.add(as, bs), ae), rounding);
		};
		BigDecimal.subtract = function (a, b, rounding) {
			rounding = rounding == undefined ? defaultRounding : rounding;
			return BigDecimal.add(a, BigDecimal.unaryMinus(b), rounding);
		};

		function toSignedZero(a, b, p) {
			if (format != null) {
				if (JSBI.equal(p.significand, JSBI.BigInt(0)) || p.exponent === -SPECIAL_EXPONENT) {
					if (JSBI.lessThan(a.significand, JSBI.BigInt(0))) {
						return toSignedZero(BigDecimal.unaryMinus(a), b, BigDecimal.unaryMinus(p));
					}
					if (JSBI.lessThan(b.significand, JSBI.BigInt(0))) {
						return toSignedZero(a, BigDecimal.unaryMinus(b), BigDecimal.unaryMinus(p));
					}
				}
			}
			return p;
		}

		BigDecimal.multiply = function (a, b, rounding) {
			rounding = rounding == undefined ? defaultRounding : rounding;
			if (format != null) {
				if (Math.abs(a.exponent) === SPECIAL_EXPONENT || Math.abs(b.exponent) === SPECIAL_EXPONENT) {
					return fromnum(tonum(a) * tonum(b));
				}
			}
			return toSignedZero(a, b, normalize(round(create(JSBI.multiply(JSBI.BigInt(a.significand), JSBI.BigInt(b.significand)), sum(a.exponent, b.exponent)), rounding), rounding));
		};

		function bigIntScale(a, scaling) {
			if (!(a instanceof JSBI)) {
				throw new TypeError();
			}
			return BASE === 2 ? JSBI.leftShift(a, cachedBigInt(scaling)) : JSBI.multiply(cachedPower(scaling), a);
		}

		function bigIntUnscale(a, unscaling) {
			if (!(a instanceof JSBI)) {
				throw new TypeError();
			}
			return BASE === 2 ? JSBI.signedRightShift(a, cachedBigInt(unscaling)) : JSBI.divide(a, cachedPower(unscaling));
		}

		BigDecimal.divide = function (a, b, rounding) {
			rounding = rounding == undefined ? defaultRounding : rounding;
			if (format != null) {
				if (Math.abs(a.exponent) === SPECIAL_EXPONENT || Math.abs(b.exponent) === SPECIAL_EXPONENT || JSBI.equal(b.significand, JSBI.BigInt(0))) {
					return fromnum(tonum(a) / tonum(b));
				}
			}
			var exponent = diff(a.exponent, b.exponent);
			var scaling = 0;
			if (rounding != null && rounding.maximumSignificantDigits != null) {
				scaling = rounding.maximumSignificantDigits + ((JSBI.equal(b.significand, JSBI.BigInt(0)) ? 0 : digits(b.significand)) - (JSBI.equal(a.significand, JSBI.BigInt(0)) ? 0 : digits(a.significand)));
			} else if (rounding != null && rounding.maximumFractionDigits != null) {

				scaling = sum(rounding.maximumFractionDigits, exponent);
			} else {

				scaling = Math.ceil(digits(b.significand) * BASE_LOG2) + 1;
			}
			var dividend = JSBI.BigInt(scaling > 0 ? bigIntScale(a.significand, scaling) : a.significand);
			var divisor = JSBI.BigInt(scaling < 0 ? bigIntScale(b.significand, 0 - scaling) : b.significand);
			if (JSBI.lessThan(divisor, JSBI.BigInt(0))) {
				dividend = JSBI.unaryMinus(dividend);
				divisor = JSBI.unaryMinus(divisor);
			}
			var quotient = JSBI.BigInt(0);
			if (rounding != null && rounding.roundingMode === "floor") {
				if (JSBI.greaterThanOrEqual(dividend, JSBI.BigInt(0))) {
					quotient = JSBI.divide(dividend, divisor);
				} else {
					quotient = JSBI.subtract(JSBI.divide(JSBI.add(dividend, JSBI.BigInt(1)), divisor), JSBI.BigInt(1));
				}
			} else if (rounding != null && rounding.roundingMode === "ceil") {
				if (JSBI.lessThanOrEqual(dividend, JSBI.BigInt(0))) {
					quotient = JSBI.divide(dividend, divisor);
				} else {
					quotient = JSBI.add(JSBI.divide(JSBI.subtract(dividend, JSBI.BigInt(1)), divisor), JSBI.BigInt(1));
				}
			} else {
				if (JSBI.lessThan(dividend, JSBI.BigInt(0))) {
					quotient = JSBI.subtract(JSBI.divide(JSBI.add(dividend, JSBI.BigInt(1)), divisor), JSBI.BigInt(1));
				} else {
					quotient = JSBI.divide(dividend, divisor);
				}
				var remainder = JSBI.subtract(dividend, JSBI.multiply(divisor, quotient));
				console.assert(JSBI.greaterThanOrEqual(remainder, JSBI.BigInt(0)));
				if (JSBI.notEqual(remainder, JSBI.BigInt(0))) {
					if (rounding == null) {
						throw new RangeError("rounding is not given for inexact operation");
					}
					quotient = JSBI.multiply(quotient, JSBI.exponentiate(BIGINT_BASE, JSBI.BigInt(2)));
					scaling = sum(scaling, 2);
					if (JSBI.lessThan(JSBI.multiply(remainder, JSBI.BigInt(2)), divisor)) {
						quotient = JSBI.add(quotient, JSBI.BigInt(1));
					} else if (JSBI.equal(JSBI.multiply(remainder, JSBI.BigInt(2)), divisor)) {
						quotient = JSBI.add(quotient, JSBI.divide(JSBI.exponentiate(BIGINT_BASE, JSBI.BigInt(2)), JSBI.BigInt(2)));
					} else {
						quotient = JSBI.add(quotient, JSBI.add(JSBI.divide(JSBI.exponentiate(BIGINT_BASE, JSBI.BigInt(2)), JSBI.BigInt(2)), JSBI.BigInt(1)));
					}
				} else {

					while (scaling >= 1 && JSBI.equal(JSBI.remainder(quotient, BIGINT_BASE), JSBI.BigInt(0))) {
						quotient = JSBI.divide(quotient, BIGINT_BASE);
						scaling -= 1;
					}
				}
			}
			return toSignedZero(a, b, round(create(quotient, diff(exponent, scaling)), rounding));
		};

		function cmpnum(a, b) {
			return a < b ? -1 : b < a ? +1 : a === b ? 0 : undefined;
		}

		function compare(a, b) {
			if (format != null) {
				if (Math.abs(a.exponent) === SPECIAL_EXPONENT || Math.abs(b.exponent) === SPECIAL_EXPONENT || JSBI.equal(b.significand, JSBI.BigInt(0))) {
					return cmpnum(tonum(a), tonum(b));
				}
			}
			var as = JSBI.BigInt(a.significand);
			var bs = JSBI.BigInt(b.significand);
			var ae = a.exponent;
			var be = b.exponent;
			var bd = diff(ae, be);
			var d = typeof bd === 'number' ? +bd : JSBI.toNumber(JSBI.BigInt(bd));
			if (d === 0) {
				return JSBI.lessThan(as, bs) ? -1 : JSBI.greaterThan(as, bs) ? +1 : 0;
			}
			if (JSBI.lessThanOrEqual(as, JSBI.BigInt(0)) && JSBI.greaterThanOrEqual(bs, JSBI.BigInt(0))) {
				return !(JSBI.equal(as, JSBI.BigInt(0)) && JSBI.equal(bs, JSBI.BigInt(0))) ? -1 : 0;
			}
			if (JSBI.greaterThanOrEqual(as, JSBI.BigInt(0)) && JSBI.lessThanOrEqual(bs, JSBI.BigInt(0))) {
				return JSBI.equal(as, JSBI.BigInt(0)) && JSBI.equal(bs, JSBI.BigInt(0)) ? 0 : +1;
			}
			if (BASE !== 2 || d >= 9007199254740992 || d <= -9007199254740992) {
				var x = sum(bd, digits(as) - digits(bs));
				var differenceOfLogarithms = typeof x === 'number' ? x : JSBI.toNumber(JSBI.BigInt(x));
				if (differenceOfLogarithms !== 0) {
					return JSBI.lessThan(as, JSBI.BigInt(0)) && JSBI.lessThan(bs, JSBI.BigInt(0)) ? differenceOfLogarithms > 0 ? -1 : +1 : differenceOfLogarithms < 0 ? -1 : +1;
				}
			} else {

				var x = d >= 0 ? as : JSBI.signedRightShift(as, cachedBigInt(0 - d));
				var y = d <= 0 ? bs : JSBI.signedRightShift(bs, cachedBigInt(d));
				if (JSBI.lessThan(x, y)) {
					return -1;
				}
				if (JSBI.lessThan(y, x)) {
					return +1;
				}

			}

			var x = d <= 0 ? as : bigIntScale(as, d);
			var y = d >= 0 ? bs : bigIntScale(bs, 0 - d);
			return JSBI.lessThan(x, y) ? -1 : JSBI.greaterThan(x, y) ? +1 : 0;
		}

		BigDecimal.cmp = function (a, b) {
			return compare(a, b);
		};
		BigDecimal.equal = function (a, b) {
			return compare(a, b) === 0;
		};
		BigDecimal.lessThan = function (a, b) {
			return compare(a, b) < 0;
		};
		BigDecimal.greaterThan = function (a, b) {
			return compare(a, b) > 0;
		};
		BigDecimal.round = function (a, rounding) {

			return round(a, rounding);
		};
		BigDecimal.prototype.toString = function () {

			if (BASE !== 10) {
				throw new Error();
			}
			if (arguments.length !== 0) {
				throw new RangeError("not implemented");
			}
			var x = convert(this);
			var significand = x.significand.toString();
			if (format != null) {
				if (Math.abs(x.exponent) === SPECIAL_EXPONENT) {
					return tonum(x).toString();
				}
			}

			if (significand === "0") {
				return "0";
			}
			var sign = "";
			if (+significand.charCodeAt(0) === +"-".charCodeAt(0)) {
				significand = significand.slice(1);
				sign = "-";
			}
			var E = sum(x.exponent, significand.length - 1);
			var e = typeof E === 'number' ? E : JSBI.toNumber(JSBI.BigInt(E));
			var normalize = format != null ? false : true;
			var minSignificant = normalize ? 0 : significand.length;
			if (e > -7 && e < 21) {
				return sign + bigDecimalToPlainString(significand, e + 1 - significand.length, 0, minSignificant);
			}
			return sign + bigDecimalToPlainString(significand, -(significand.length - 1), 0, minSignificant) + "e" + (e >= 0 ? "+" : "") + E.toString();
		};

		function bigDecimalToPlainString(significand, exponent, minFraction, minSignificant) {
			var e = significand.length - 1 + exponent;
			if (e <= -1) {
				significand = String("0".repeat(0 - e)) + significand;
				minSignificant += 0 - e;
				e = 0;
			}
			var fraction = significand.length - (e + 1);
			var i = significand.length;
			while (fraction > minFraction && +i >= +minSignificant && i >= 1 && +significand.charCodeAt(i - 1) === +"0".charCodeAt(0)) {
				i -= 1;
				fraction -= 1;
			}
			if (+i < +significand.length) {
				significand = significand.slice(0, i);
			}
			var zeros = Math.max(minFraction - fraction, +minSignificant - +significand.length);
			if (zeros > 0) {
				significand += String("0".repeat(zeros));
			}
			return significand.length > e + 1 ? significand.slice(0, e + 1) + "." + significand.slice(e + 1) : significand;
		}

		function toPrecision(significand, exponent, minSignificant) {
			var E = sum(exponent, significand.length - 1);
			var e = typeof E === 'number' ? E : JSBI.toNumber(JSBI.BigInt(E));
			if (e < -6 || e >= +minSignificant) {
				return bigDecimalToPlainString(significand, -(significand.length - 1), 0, minSignificant) + "e" + (e < 0 ? "" : "+") + E.toString();
			}
			return bigDecimalToPlainString(significand, typeof exponent === 'number' ? exponent : JSBI.toNumber(JSBI.BigInt(exponent)), 0, minSignificant);
		}

		function toFixed(significand, exponent, minFraction) {
			return bigDecimalToPlainString(significand, exponent, minFraction, 0);
		}

		function toExponential(significand, exponent, minFraction) {
			var E = sum(exponent, significand.length - 1);
			var e = typeof E === 'number' ? E : JSBI.toNumber(JSBI.BigInt(E));
			return bigDecimalToPlainString(significand, -(significand.length - 1), 0, minFraction + 1) + "e" + (e < 0 ? "" : "+") + E.toString();
		}

		BigDecimal.prototype.toFixed = function (fractionDigits, roundingMode) {
			roundingMode = roundingMode == undefined ? "half-up" : roundingMode;
			if (Math.floor(fractionDigits) !== fractionDigits) {
				throw new RangeError();
			}
			if (format != null) {
				if (Math.abs(this.exponent) === SPECIAL_EXPONENT) {
					return tonum(this).toFixed(fractionDigits);
				}
			}
			var value = BASE === 10 ? create(this.significand, sum(this.exponent, fractionDigits)) : BigDecimal.multiply(convert(JSBI.exponentiate(JSBI.BigInt(10), JSBI.BigInt(fractionDigits))), this);
			var sign = JSBI.lessThan(value.significand, JSBI.BigInt(0)) ? "-" : "";
			var rounded = BigDecimal.round(value, {
				maximumFractionDigits: 0,
				roundingMode: roundingMode
			});
			var a = abs(rounded);
			return sign + toFixed(toBigInt(a).toString(), 0 - fractionDigits, fractionDigits);
		};

		function getDecimalSignificantAndExponent(value, precision, roundingMode) {
			if (BASE === 10) {
				var x = BigDecimal.round(abs(value), {
					maximumSignificantDigits: precision,
					roundingMode: roundingMode
				});
				return {
					significand: x.significand.toString(),
					exponent: JSBI.BigInt(x.exponent)
				};
			}

			var exponentiate = function (x, n, rounding) {
				if (JSBI.lessThan(n, JSBI.BigInt(0))) {
					return BigDecimal.divide(convert(1), exponentiate(x, JSBI.unaryMinus(JSBI.BigInt(n)), rounding), rounding);
				}
				var y = undefined;
				while (JSBI.greaterThanOrEqual(n, JSBI.BigInt(1))) {
					if (JSBI.equal(JSBI.remainder(n, JSBI.BigInt(2)), JSBI.BigInt(0))) {
						x = BigDecimal.multiply(x, x, rounding);
						n = JSBI.divide(n, JSBI.BigInt(2));
					} else {
						y = y == undefined ? x : BigDecimal.multiply(x, y, rounding);
						n = JSBI.subtract(n, JSBI.BigInt(1));
					}
				}
				return y == undefined ? convert(1) : y;
			};
			var logarithm = function (x, b, rounding) {
				if (BigDecimal.cmp(x, convert(0)) <= 0) {
					throw new RangeError();
				}
				if (BigDecimal.cmp(x, convert(1)) < 0) {
					return JSBI.subtract(JSBI.BigInt(0), logarithm(BigDecimal.divide(convert(1), x, rounding), b, rounding));
				}
				var digits = getCountOfDigits(x);
				var v = JSBI.BigInt(Math.max(0, bitLength(digits) - NumberSafeBits));
				var log = JSBI.leftShift(JSBI.BigInt(Math.floor(JSBI.toNumber(JSBI.signedRightShift(digits, v)) / Math.log2(b) * BASE_LOG2)), v);
				if (JSBI.lessThan(log, JSBI.BigInt(3))) {
					return log;
				}
				return JSBI.add(log, logarithm(BigDecimal.divide(x, exponentiate(convert(b), log, rounding), rounding), b, rounding));
			};
			var sign = JSBI.lessThan(value.significand, JSBI.BigInt(0)) ? -1 : +1;
			var roundToInteger = function (a) {
				return BigDecimal.round(sign >= 0 ? a : BigDecimal.unaryMinus(a), {
					maximumFractionDigits: 0,
					roundingMode: roundingMode
				});
			};
			if (BigDecimal.cmp(value, convert(0)) === 0) {
				return {
					significand: "0",
					exponent: JSBI.BigInt(0)
				};
			}
			var ten = convert(10);
			var minimumSignificantDigits = Math.pow(2, Math.ceil(Math.log2(bitLength(JSBI.add(bigIntAbs(JSBI.BigInt(value.exponent)), JSBI.BigInt(1))) * BASE_LOG2_INV)));
			var rounding = {
				maximumSignificantDigits: Math.max(minimumSignificantDigits, BASE === 2 ? 32 : 8),
				roundingMode: "half-even"
			};
			var result = undefined;
			var fd = JSBI.BigInt(0);
			do {
				var x = abs(value);
				fd = JSBI.subtract(JSBI.BigInt(0), logarithm(x, 10, rounding));
				x = BigDecimal.multiply(exponentiate(ten, fd, rounding), x, rounding);
				if (BigDecimal.cmp(x, ten) >= 0) {
					fd = JSBI.subtract(fd, JSBI.BigInt(1));
					x = BigDecimal.divide(x, ten, rounding);
				}
				if (BigDecimal.cmp(x, convert(1)) < 0) {
					fd = JSBI.add(fd, JSBI.BigInt(1));
					x = BigDecimal.multiply(x, ten, rounding);
				}
				if (BigDecimal.cmp(x, convert(1)) >= 0 && BigDecimal.cmp(x, ten) < 0) {
					fd = JSBI.add(fd, JSBI.BigInt(precision - 1));

					if (rounding.maximumSignificantDigits > (Math.abs(JSBI.toNumber(fd)) + precision) * Math.log2(10) + digits(value.significand)) {
						x = abs(value);
						x = BigDecimal.multiply(x, exponentiate(ten, fd, rounding), rounding);
						result = toBigInt(abs(roundToInteger(x))).toString();
					} else {
						x = BigDecimal.multiply(x, exponentiate(ten, JSBI.BigInt(precision - 1), rounding), rounding);
						x = abs(x);
						var error = BigDecimal.multiply(BigDecimal.multiply(convert(JSBI.add(bigIntAbs(fd), JSBI.BigInt(precision))), exponentiateBase(0 - rounding.maximumSignificantDigits)), x);
						if (BigDecimal.cmp(roundToInteger(BigDecimal.add(x, error)), roundToInteger(BigDecimal.subtract(x, error))) === 0) {
							result = toBigInt(abs(roundToInteger(x))).toString();
						}
					}
				}
				rounding = {
					maximumSignificantDigits: rounding.maximumSignificantDigits * 2,
					roundingMode: "half-even"
				};
			} while (result == undefined);
			return {
				significand: result,
				exponent: JSBI.unaryMinus(fd)
			};
		}

		BigDecimal.prototype.toPrecision = function (precision, roundingMode) {
			roundingMode = roundingMode == undefined ? "half-up" : roundingMode;
			if (format != null) {
				if (Math.abs(this.exponent) === SPECIAL_EXPONENT) {
					return tonum(this).toPrecision(precision);
				}
			}
			var tmp = getDecimalSignificantAndExponent(this, precision, roundingMode);
			return (BigDecimal.cmp(this, convert(0)) < 0 ? "-" : "") + toPrecision(tmp.significand, tmp.exponent, precision);
		};
		BigDecimal.prototype.toExponential = function (fractionDigits, roundingMode) {
			roundingMode = roundingMode == undefined ? "half-up" : roundingMode;
			if (format != null) {
				if (Math.abs(this.exponent) === SPECIAL_EXPONENT) {
					return tonum(this).toExponential(fractionDigits);
				}
			}
			var tmp = getDecimalSignificantAndExponent(this, fractionDigits + 1, roundingMode);
			return (BigDecimal.cmp(this, convert(0)) < 0 ? "-" : "") + toExponential(tmp.significand, tmp.exponent, fractionDigits);
		};
		return BigDecimal;
	};
	var BigDecimal = factory(10);
	var BigFloat = factory(2);
	var Decimal128 = factory(10, 'decimal128');
	BigDecimal.BigDecimal = BigDecimal;
	BigFloat.BigFloat = BigFloat;
	Decimal128.Decimal128 = Decimal128;
	self.BigDecimal = BigDecimal;
	self.BigFloat = BigFloat;
	self.Decimal128 = Decimal128;
}

function BigDecimalMath() {
	function addMath(BigDecimal, BASE) {
		var BASE_LOG2_INV = 1 / Math.log2(BASE);
		var BIGINT_BASE = JSBI.BigInt(BASE);

		function convert(x) {
			return BigDecimal(x);
		}

		var exponentiate = function (x, n) {
			if (JSBI.lessThan(n, JSBI.BigInt(0))) {
				return BigDecimal.divide(convert(1), exponentiate(x, JSBI.unaryMinus(JSBI.BigInt(n))));
			}
			var y = undefined;
			while (JSBI.greaterThanOrEqual(n, JSBI.BigInt(1))) {
				if (JSBI.equal(JSBI.remainder(n, JSBI.BigInt(2)), JSBI.BigInt(0))) {
					x = BigDecimal.multiply(x, x);
					n = JSBI.divide(n, JSBI.BigInt(2));
				} else {
					y = y == undefined ? x : BigDecimal.multiply(x, y);
					n = JSBI.subtract(n, JSBI.BigInt(1));
				}
			}
			return y == undefined ? convert(1) : y;
		};

		function exponentiateBase(n) {

			return exponentiate(convert(BASE), JSBI.BigInt(n));
		}

		function bigIntAbs(a) {
			return JSBI.lessThan(a, JSBI.BigInt(0)) ? JSBI.subtract(JSBI.BigInt(0), a) : a;
		}

		var NumberSafeBits = Math.floor(Math.log2(Number.MAX_SAFE_INTEGER + 1));

		function bitLength(a) {
			var s = a.toString(16);
			var c = +s.charCodeAt(0) - "0".charCodeAt(0);
			if (c <= 0) {
				throw new RangeError();
			}
			return (s.length - 1) * 4 + (32 - Math.clz32(Math.min(c, 8)));
		}

		function bigIntLog2(n) {
			var k = bitLength(n) - NumberSafeBits;
			var leadingDigits = JSBI.toNumber(JSBI.signedRightShift(n, JSBI.BigInt(k)));
			return Math.log2(leadingDigits) + k;
		}

		function digits(a) {

			a = bigIntAbs(a);
			if (BASE === 2) {
				return bitLength(a);
			}
			var number = JSBI.toNumber(JSBI.BigInt(a));
			if (number < (Number.MAX_SAFE_INTEGER + 1) / 16) {
				return Math.floor(Math.log2(number + 0.5) * BASE_LOG2_INV) + 1;
			}
			var e = (number < 1 / 0 ? Math.log2(number) : bigIntLog2(a)) * BASE_LOG2_INV;
			if (Math.floor(e * (1 - 32 / (Number.MAX_SAFE_INTEGER + 1))) === Math.floor(e) && Math.floor(e * (1 + 32 / (Number.MAX_SAFE_INTEGER + 1))) === Math.floor(e)) {
				return Math.floor(e) + 1;
			}
			var i = Math.floor(e + 0.5);
			return JSBI.greaterThanOrEqual(a, JSBI.BigInt(cachedPower(i))) ? i + 1 : i;
		}

		function cachedFunction(f) {
			var cache = {};
			var cacheSize = 0;
			return function (k) {
				var lastValue = cache[k];
				if (lastValue == null) {
					if (cacheSize > 100) {
						cache = {};
						cacheSize = 0;
					}
					lastValue = f(k);
					cache[k] = lastValue;
					cacheSize += 1;
				}
				return lastValue;
			};
		}

		var cachedBigInt = cachedFunction(function (k) {

			return JSBI.BigInt(k);
		});
		var cachedPower = cachedFunction(function (k) {
			return JSBI.exponentiate(BIGINT_BASE, JSBI.BigInt(k));
		});

		function bigIntScale(a, scaling) {
			if (!(a instanceof JSBI)) {
				throw new TypeError();
			}
			return BASE === 2 ? JSBI.leftShift(a, cachedBigInt(scaling)) : JSBI.multiply(cachedPower(scaling), a);
		}

		function bigIntUnscale(a, unscaling) {
			if (!(a instanceof JSBI)) {
				throw new TypeError();
			}
			return BASE === 2 ? JSBI.signedRightShift(a, cachedBigInt(unscaling)) : JSBI.divide(a, cachedPower(unscaling));
		}

		var toBigInt = function (a) {
			var e = a.exponent;
			var exponent = typeof e === 'number' ? e : JSBI.toNumber(JSBI.BigInt(e));
			if (exponent === 0) {
				return a.significand;
			}
			if (exponent < 0) {
				var result = bigIntUnscale(a.significand, 0 - exponent);
				if (JSBI.notEqual(bigIntScale(result, 0 - exponent), JSBI.BigInt(a.significand))) {
					throw new RangeError("The BigDecimal " + a.toString() + " cannot be converted to a BigInt because it is not an integer");
				}
				return result;
			}
			return bigIntScale(a.significand, exponent);
		};

		function getCountOfDigits(a) {

			if (JSBI.equal(a.significand, JSBI.BigInt(0))) {
				throw new RangeError();
			}
			return JSBI.add(JSBI.BigInt(digits(a.significand)), JSBI.BigInt(a.exponent));
		}

		var zero = BigDecimal(0);
		BigDecimal.abs = function (a) {
			return BigDecimal.cmp(a, zero) < 0 ? BigDecimal.unaryMinus(a) : a;
		};
		BigDecimal.sign = function (a) {
			return BigDecimal.cmp(a, zero) < 0 ? -1 : BigDecimal.cmp(a, zero) > 0 ? +1 : 0;
		};
		BigDecimal.max = function (a, b) {
			if (arguments.length > 2) {
				throw new RangeError("not implemented");
			}
			return BigDecimal.cmp(a, b) < 0 ? b : a;
		};
		BigDecimal.min = function (a, b) {
			if (arguments.length > 2) {
				throw new RangeError("not implemented");
			}
			return BigDecimal.cmp(a, b) > 0 ? b : a;
		};

		function significandDigits(a) {
			var maximumSignificantDigits = 1;
			while (BigDecimal.cmp(BigDecimal.round(a, {
				maximumSignificantDigits: maximumSignificantDigits,
				roundingMode: "half-even"
			}), a) !== 0) {
				maximumSignificantDigits *= 2;
			}
			var from = maximumSignificantDigits / 2;
			var to = maximumSignificantDigits;
			while (to - 1 > from) {
				var middle = from + Math.floor((to - from) / 2);
				if (BigDecimal.cmp(BigDecimal.round(a, {
					maximumSignificantDigits: middle,
					roundingMode: "half-even"
				}), a) !== 0) {
					from = middle;
				} else {
					to = middle;
				}
			}
			return to;
		}

		function tryToMakeCorrectlyRounded(specialValue, f, name) {
			function getExpectedResultIntegerDigits(x) {
				if (name === "exp") {

					return Math.ceil(JSBI.toNumber(JSBI.BigInt(toBigInt(BigDecimal.round(x, {
						maximumFractionDigits: 0,
						roundingMode: "half-even"
					})))) / Math.log(BASE));
				}
				if (name === "log") {

					return Math.ceil(Math.log2(Math.ceil(Math.max(JSBI.toNumber(getCountOfDigits(x)), 1) * Math.log(BASE))) * BASE_LOG2_INV);
				}
				return 1;
			}

			return function (x, rounding) {
				if (BigDecimal.cmp(x, convert(specialValue)) === 0) {
					return f(x, {
						maximumSignificantDigits: 1,
						roundingMode: "half-even"
					});
				}
				var result = convert(0);
				var i = 0;
				var error = convert(0);
				do {
					if (i > 4 * ((9 + 1) / BASE) && rounding.maximumSignificantDigits != null && rounding.roundingMode === "half-even" && name !== "sin" && name !== "cos") {
						console.error(x, rounding);
						throw new Error();
					}
					i += 1;
					var internalRounding = {
						maximumSignificantDigits: Math.ceil(Math.max(rounding.maximumSignificantDigits || rounding.maximumFractionDigits + 1 + getExpectedResultIntegerDigits(x) - 1, significandDigits(x)) * Math.pow(2, Math.ceil((i - 1) / 3))) + 2 + (BASE === 2 ? 1 : 0),
						roundingMode: "half-even"
					};
					result = undefined;
					if (BASE === 2 && Math.max(internalRounding.maximumSignificantDigits + 2, significandDigits(x) + 1) <= Math.log2(Number.MAX_SAFE_INTEGER + 1)) {

						var e = x.exponent;
						var exponent = typeof e === 'number' ? e : JSBI.toNumber(JSBI.BigInt(e));
						var v = JSBI.toNumber(JSBI.BigInt(x.significand)) * Math.pow(BASE, exponent);

						if (name !== "sin" && name !== "cos" && name !== "tan" || Math.abs(v) <= Math.PI / 4) {
							var numberValue = Math[name](v);
							var MIN_NORMALIZED_VALUE = (Number.MIN_VALUE * 1.25 > Number.MIN_VALUE ? Number.MIN_VALUE : Number.MIN_VALUE * (Number.MAX_SAFE_INTEGER + 1) / 2) || Math.pow(2, -1022);
							var a = Math.abs(numberValue);
							if (a < 1 / 0 && a > MIN_NORMALIZED_VALUE) {
								result = convert(numberValue);
							}
						}
					}
					if (result == undefined) {
						result = f(x, internalRounding);
					}

					error = BigDecimal.multiply(exponentiateBase(JSBI.unaryMinus(JSBI.BigInt(internalRounding.maximumSignificantDigits))), BigDecimal.abs(result));

				} while (BigDecimal.cmp(BigDecimal.round(BigDecimal.subtract(result, error), rounding), BigDecimal.round(BigDecimal.add(result, error), rounding)) !== 0);
				if (i > 1) {

				}
				return BigDecimal.round(result, rounding);
			};
		}

		function sqrt(x, rounding) {

			var lastResult = BigDecimal.add(x, convert(1));
			var result = x;
			while (BigDecimal.cmp(result, lastResult) < 0) {
				lastResult = result;
				result = BigDecimal.divide(BigDecimal.add(BigDecimal.divide(x, result, rounding), result), convert(2), rounding);
			}
			return result;
		}

		BigDecimal.log = tryToMakeCorrectlyRounded(1, function log(x, rounding) {
			if (BigDecimal.cmp(x, convert(0)) <= 0) {
				throw new RangeError();
			}

			var internalRounding = {
				maximumSignificantDigits: rounding.maximumSignificantDigits + Math.ceil(Math.log2(rounding.maximumSignificantDigits + 0.5) * BASE_LOG2_INV),
				roundingMode: "half-even"
			};
			if (true) {

				var k = JSBI.subtract(getCountOfDigits(x), JSBI.BigInt(1));
				var f = BigDecimal.multiply(exponentiateBase(JSBI.unaryMinus(k)), x);
				var ff = BigDecimal.round(BigDecimal.multiply(f, f), {
					maximumSignificantDigits: 3,
					roundingMode: "half-even"
				});
				if (BigDecimal.cmp(ff, exponentiateBase(JSBI.BigInt(1))) > 0) {
					k = JSBI.add(k, JSBI.BigInt(1));
					f = BigDecimal.multiply(exponentiateBase(JSBI.unaryMinus(JSBI.BigInt(1))), f);
				}
				if (BigDecimal.cmp(ff, exponentiateBase(JSBI.unaryMinus(JSBI.BigInt(1)))) < 0) {
					k = JSBI.subtract(k, JSBI.BigInt(1));
					f = BigDecimal.multiply(exponentiateBase(JSBI.BigInt(1)), f);
				}
				if (JSBI.notEqual(k, JSBI.BigInt(0))) {
					return BigDecimal.add(BigDecimal.log(f, internalRounding), BigDecimal.multiply(convert(JSBI.multiply(JSBI.BigInt(2), k)), BigDecimal.log(sqrt(convert(BASE), internalRounding), internalRounding)));
				}
			}

			var g = BigDecimal.divide(BigDecimal.subtract(x, convert(1)), BigDecimal.add(x, convert(1)), internalRounding);
			var n = 1;
			var term = convert(1);
			var sum = term;
			var lastSum = convert(0);
			var gg = BigDecimal.multiply(g, g, internalRounding);
			while (BigDecimal.cmp(lastSum, sum) !== 0) {
				n += 2;
				term = BigDecimal.multiply(term, convert(n - 2));
				term = BigDecimal.multiply(term, gg);
				term = BigDecimal.divide(term, convert(n), internalRounding);
				lastSum = sum;
				sum = BigDecimal.add(sum, term, internalRounding);
			}
			return BigDecimal.multiply(BigDecimal.multiply(convert(2), g), sum);
		}, "log");

		function fromNumberApproximate(number) {
			return BigDecimal.divide(convert(Math.floor(number * (Number.MAX_SAFE_INTEGER + 1))), BigDecimal.add(convert(Number.MAX_SAFE_INTEGER), convert(1)), {
				maximumSignificantDigits: Math.floor(Math.log2(Number.MAX_SAFE_INTEGER + 1) * BASE_LOG2_INV + 0.5),
				roundingMode: "half-even"
			});
		}

		BigDecimal.exp = tryToMakeCorrectlyRounded(0, function exp(x, rounding) {

			var internalRounding = {
				maximumSignificantDigits: rounding.maximumSignificantDigits + Math.ceil(Math.log2(rounding.maximumSignificantDigits + 0.5) * BASE_LOG2_INV),
				roundingMode: "half-even"
			};
			if (BigDecimal.cmp(x, convert(0)) !== 0) {
				var logBASEApproximate = fromNumberApproximate(Math.log(BASE));
				var kApproximate = BigDecimal.round(BigDecimal.divide(x, logBASEApproximate, {
					maximumSignificantDigits: Math.max(JSBI.toNumber(getCountOfDigits(x)), 1),
					roundingMode: "half-even"
				}), {
					maximumFractionDigits: 0,
					roundingMode: "half-even"
				});
				if (BigDecimal.cmp(kApproximate, convert(0)) !== 0) {
					var logBASE = BigDecimal.log(convert(BASE), {
						maximumSignificantDigits: internalRounding.maximumSignificantDigits + JSBI.toNumber(getCountOfDigits(kApproximate)),
						roundingMode: "half-even"
					});
					var k = BigDecimal.round(BigDecimal.divide(x, logBASE, {
						maximumSignificantDigits: Math.max(JSBI.toNumber(getCountOfDigits(x)), 1),
						roundingMode: "half-even"
					}), {
						maximumFractionDigits: 0,
						roundingMode: "half-even"
					});
					if (BigDecimal.cmp(k, convert(0)) !== 0) {
						var r = BigDecimal.subtract(x, BigDecimal.multiply(k, logBASE));
						return BigDecimal.multiply(exponentiateBase(JSBI.BigInt(toBigInt(k))), BigDecimal.exp(r, internalRounding));
					}
				}
			}

			var n = 0;
			var term = convert(1);
			var sum = term;
			var lastSum = convert(0);
			while (BigDecimal.cmp(lastSum, sum) !== 0) {
				n += 1;
				term = BigDecimal.multiply(term, x);
				term = BigDecimal.divide(term, convert(n), internalRounding);
				lastSum = sum;
				sum = BigDecimal.add(sum, term, internalRounding);
			}
			return sum;
		}, "exp");

		function divideByHalfOfPI(x, rounding) {

			var quarterOfPiApproximated = fromNumberApproximate(Math.PI / 4);
			if (BigDecimal.cmp(BigDecimal.abs(x), quarterOfPiApproximated) > 0) {

				var internalRounding = {
					maximumSignificantDigits: rounding.maximumSignificantDigits + significandDigits(x) + JSBI.toNumber(getCountOfDigits(x)) + 1 + Math.ceil(42 * BASE_LOG2_INV),
					roundingMode: "half-even"
				};
				var halfOfPi = BigDecimal.multiply(convert(2), BigDecimal.atan(convert(1), internalRounding));
				var i = BigDecimal.round(BigDecimal.divide(x, halfOfPi, {
					maximumSignificantDigits: Math.max(JSBI.toNumber(getCountOfDigits(x)), 1),
					roundingMode: "half-even"
				}), {
					maximumFractionDigits: 0,
					roundingMode: "half-even"
				});
				var remainder = BigDecimal.subtract(x, BigDecimal.multiply(i, halfOfPi));
				return {
					remainder: remainder,
					k: (JSBI.toNumber(JSBI.remainder(JSBI.BigInt(toBigInt(i)), JSBI.BigInt(4))) + 4) % 4
				};
			}
			return {
				remainder: x,
				k: 0
			};
		}

		function _cos(x, rounding, subtractHalfOfPi) {
			var tmp = divideByHalfOfPI(x, rounding);
			var a = tmp.remainder;
			var k = (tmp.k + (subtractHalfOfPi ? -1 + 4 : 0)) % 4;

			var internalRounding = {
				maximumSignificantDigits: rounding.maximumSignificantDigits + Math.ceil(Math.log2(rounding.maximumSignificantDigits + 0.5) * BASE_LOG2_INV),
				roundingMode: "half-even"
			};
			var n = k === 1 || k === 3 ? 1 : 0;
			var term = convert(1);
			var sum = term;
			var lastSum = convert(0);
			var aa = BigDecimal.multiply(a, a);
			while (BigDecimal.cmp(lastSum, sum) !== 0) {
				n += 2;
				term = BigDecimal.multiply(term, aa);
				term = BigDecimal.divide(term, convert(-n * (n - 1)), internalRounding);
				lastSum = sum;
				sum = BigDecimal.add(sum, term, internalRounding);
			}
			if (k === 1 || k === 2) {
				sum = BigDecimal.unaryMinus(sum);
			}
			return k === 1 || k === 3 ? BigDecimal.multiply(a, sum) : sum;
		}

		BigDecimal.sin = tryToMakeCorrectlyRounded(0, function (x, rounding) {
			return _cos(x, rounding, true);
		}, "sin");
		BigDecimal.cos = tryToMakeCorrectlyRounded(0, function (x, rounding) {
			return _cos(x, rounding, false);
		}, "cos");
		BigDecimal.atan = tryToMakeCorrectlyRounded(0, function (x, rounding) {
			if (BigDecimal.cmp(BigDecimal.abs(x), convert(1)) > 0) {

				var internalRounding = {
					maximumFractionDigits: rounding.maximumSignificantDigits + 1,
					roundingMode: "half-even"
				};
				var halfOfPi = BigDecimal.multiply(BigDecimal.atan(convert(1), internalRounding), convert(2));
				return BigDecimal.multiply(convert(BigDecimal.cmp(x, convert(0)) < 0 ? -1 : +1), BigDecimal.subtract(halfOfPi, BigDecimal.atan(BigDecimal.divide(convert(1), BigDecimal.abs(x), internalRounding), internalRounding)));
			}

			var internalRounding = {
				maximumSignificantDigits: rounding.maximumSignificantDigits + Math.ceil(Math.log2(rounding.maximumSignificantDigits + 0.5) * BASE_LOG2_INV),
				roundingMode: "half-even"
			};
			var n = 0;
			var xx = BigDecimal.multiply(x, x);
			var xxplus1 = BigDecimal.add(convert(1), xx);
			var term = BigDecimal.divide(convert(1), xxplus1, internalRounding);
			var sum = term;
			var lastSum = convert(0);
			while (BigDecimal.cmp(lastSum, sum) !== 0) {
				n += 1;
				term = BigDecimal.multiply(term, BigDecimal.multiply(convert(2 * n), xx));
				term = BigDecimal.divide(term, BigDecimal.multiply(convert(2 * n + 1), xxplus1), internalRounding);
				lastSum = sum;
				sum = BigDecimal.add(sum, term, internalRounding);
			}
			return BigDecimal.multiply(x, sum);
		}, "atan");
		BigDecimal.sqrt = function (x, rounding) {
			if (BigDecimal.cmp(x, convert(0)) < 0) {
				throw new RangeError();
			}
			if (BigDecimal.cmp(x, convert(0)) === 0) {
				return x;
			}

			var e = JSBI.divide(getCountOfDigits(x), JSBI.BigInt(2));
			var t = exponentiateBase(e);
			var y = BigDecimal.multiply(x, exponentiateBase(JSBI.unaryMinus(JSBI.multiply(JSBI.BigInt(2), e))));
			var k = Math.floor(Math.log2(Number.MAX_SAFE_INTEGER + 1) * BASE_LOG2_INV) - 1;
			var xn = JSBI.toNumber(JSBI.BigInt(toBigInt(BigDecimal.round(BigDecimal.multiply(y, exponentiateBase(k)), {
				maximumFractionDigits: 0,
				roundingMode: "half-even"
			})))) / Math.pow(BASE, k);
			var r = Math.sqrt(xn);

			var resultSignificantDigits = 2 * (rounding.maximumSignificantDigits || rounding.maximumFractionDigits + Math.ceil(significandDigits(x) / 2) || 1);
			var result = BigDecimal.multiply(convert(Math.sign(r) * Math.floor(Math.abs(r) * Math.pow(BASE, k) + 0.5)), exponentiateBase(-k));
			var iteration = function (result, internalRounding) {
				return BigDecimal.divide(BigDecimal.add(y, BigDecimal.multiply(result, result)), BigDecimal.multiply(convert(2), result), internalRounding);
			};
			for (var i = Math.max(k - 1, 1); i <= resultSignificantDigits; i *= 2) {
				var internalRounding = {
					maximumSignificantDigits: i,
					roundingMode: "half-even"
				};
				result = iteration(result, internalRounding);
			}
			result = iteration(result, rounding);
			return BigDecimal.multiply(result, t);
		};
	}

	self.addMath = addMath;
}

function NewtonInterpolation() {
	var DefaultYField = {
		ONE: 1,
		sub: function (a, b) {
			return a - b;
		},
		mul: function (a, b) {
			return a * b;
		},
		div: function (a, b) {
			return a / b;
		},
		scale: function (a, s) {
			return a * Number(s);
		}
	};

	var yField = DefaultYField;

	function NewtonInterpolation(basisPolynomialCache) {
		basisPolynomialCache = basisPolynomialCache == undefined ? undefined : basisPolynomialCache;

		var coefficients = function () {
			var x = [];
			var diagonal = [];
			var equidistantly = true;
			var hInKTimeskFactorial = yField.ONE;
			var c = yField.ONE;
			var firstTime = true;
			var iterator = {
				next: function (point) {
					while (true) {
						if (firstTime) {
							firstTime = false;
							return {
								value: c,
								done: false
							};
						}
						var $tmpxi_yi = point;
						var xi = $tmpxi_yi[0];
						var yi = $tmpxi_yi[1];
						if (equidistantly && x.length >= 2 && x[x.length - 1] - x[x.length - 2] !== xi - x[x.length - 1]) {

							var h = x[x.length - 1] - x[x.length - 2];
							hInKTimeskFactorial = yField.ONE;
							for (var k = 1; k < diagonal.length; k += 1) {
								hInKTimeskFactorial = yField.scale(hInKTimeskFactorial, h * k);
								diagonal[k] = yField.div(diagonal[k], hInKTimeskFactorial);
							}
							equidistantly = false;
						}
						var value = yi;
						for (var i = 0; i < diagonal.length; i += 1) {

							var difference = yField.sub(value, diagonal[i]);
							if (!equidistantly) {
								difference = yField.div(difference, yField.scale(yField.ONE, xi - x[x.length - 1 - i]));
							}
							diagonal[i] = value;
							value = difference;
						}
						diagonal.push(value);
						x.push(xi);
						c = diagonal[diagonal.length - 1];
						if (equidistantly && x.length >= 2) {
							var k = diagonal.length - 1;
							var h = x[x.length - 1] - x[x.length - 2];
							hInKTimeskFactorial = yField.scale(hInKTimeskFactorial, h * k);
							c = yField.div(c, hInKTimeskFactorial);
						}
						return {
							value: c,
							done: false
						};
					}
				}
			};
			iterator[globalThis.Symbol.iterator] = function () {
				return this;
			};
			return iterator;
		};
		var yZERO = yField.sub(yField.ONE, yField.ONE);
		var yONE = yField.ONE;
		var a = coefficients();
		a.next();

		var basisPolynomial = [yONE];
		var N = [];
		var firstTime = true;
		var iterator = {
			next: function (point) {
				while (true) {
					if (firstTime) {
						firstTime = false;
						return {
							value: N,
							done: false
						};
					}
					var $tmpxi_yi = point;
					var xi = $tmpxi_yi[0];
					var yi = $tmpxi_yi[1];
					var c = yField.sub(yZERO, a.next([xi, yi]).value);

					N.push(yZERO);
					for (var i = basisPolynomial.length - 1; i >= 0; i -= 1) {
						N[i] = yField.sub(N[i], yField.mul(basisPolynomial[i], c));
					}

					if (basisPolynomialCache !== undefined && basisPolynomialCache[xi] != null) {
						basisPolynomial = basisPolynomialCache[xi];
					} else {
						if (basisPolynomialCache !== undefined) {
							basisPolynomial = basisPolynomial.slice(0);
						}

						basisPolynomial.push(yZERO);
						for (var i = basisPolynomial.length - 1; i >= 0; i -= 1) {
							basisPolynomial[i] = yField.sub(i >= 1 ? basisPolynomial[i - 1] : yZERO, yField.scale(basisPolynomial[i], xi));
						}
						if (basisPolynomialCache !== undefined) {
							basisPolynomialCache[xi] = basisPolynomial.slice(0);
						}
					}
					return {
						value: N,
						done: false
					};
				}
			}
		};
		iterator[globalThis.Symbol.iterator] = function () {
			return this;
		};
		return iterator;
	}

	NewtonInterpolation.setField = function (newYField) {
		yField = newYField || DefaultYField;
	};

	globalThis.NewtonInterpolation = NewtonInterpolation;
	self.NewtonInterpolation = NewtonInterpolation;
}

function SymbolicAlgebra() {
	globalThis.bigIntGCD = globalThis.bigIntGCD || globalThis.gcd;
	globalThis.halfgcd = bigIntGCD.halfgcd;
	globalThis.gcdext = bigIntGCD.gcdext;
	globalThis.gcd = bigIntGCD;

	function gcdOfSafeIntegers(a, b) {
		a = Math.abs(a);
		b = Math.abs(b);
		while (b !== 0) {
			var r = a - Math.floor(a / b) * b;
			a = b;
			b = r;
		}
		return a;
	}

	Math.gcd = function (a, b) {
		if (typeof a !== "number" && typeof b !== "number") {
			throw new RangeError();
		}
		var maxSMI = 1073741823;
		if ((a | 0) === a && Math.abs(a) <= maxSMI && (b | 0) === b && Math.abs(b) <= maxSMI) {
			var A = Math.abs(a);
			var B = Math.abs(b);
			while (B !== 0) {
				var R = A % B;
				A = B;
				B = R;
			}
			return A;
		}
		return gcdOfSafeIntegers(a, b);
	};

	function integerMin(a, b) {
		return a.compareTo(b) < 0 ? a : b;
	}

	function bigIntGCDWrapper2(a, b) {
		var na = SmallBigInt.toNumber(a);
		var nb = SmallBigInt.toNumber(b);
		if (Math.abs(na) >= 1 / 0 && Math.abs(nb) >= 1 / 0) {
			var size = integerMin(Expression.Integer.fromBigInt(a).abs(), Expression.Integer.fromBigInt(b).abs()).bitLength();
			size = Math.pow(2, Math.ceil(Math.log2(size)));
			if (size >= 128 * 1024) {
				if (size > lastMaxSize) {
					lastMaxSize = size;
					var error = new TypeError("big size of " + "gcd" + " " + size);
					if (globalThis.onerror != null) {
						globalThis.onerror(error.message, "", 0, 0, error);
					}
				}
			}
		}
		if (na < 0) {
			a = SmallBigInt.unaryMinus(a);
		}
		if (nb < 0) {
			b = SmallBigInt.unaryMinus(b);
		}
		if (na === 0) {
			return b;
		}
		if (nb === 0) {
			return a;
		}
		var c1 = primeFactor._countTrailingZeros(a, Expression.TWO.toBigInt());
		var c2 = primeFactor._countTrailingZeros(b, Expression.TWO.toBigInt());
		if (c1 + c2 >= 4) {
			var g = bigIntGCD(c1 === 0 ? SmallBigInt.BigInt(a) : SmallBigInt.signedRightShift(SmallBigInt.BigInt(a), SmallBigInt.BigInt(c1)), c2 === 0 ? SmallBigInt.BigInt(b) : SmallBigInt.signedRightShift(SmallBigInt.BigInt(b), SmallBigInt.BigInt(c2)));
			var c = Math.min(c1, c2);
			return c === 0 ? g : SmallBigInt.leftShift(g, SmallBigInt.BigInt(c));
		}
		return bigIntGCD(SmallBigInt.BigInt(a), SmallBigInt.BigInt(b));
	}

	function bigIntGCDWrapper(a, b) {
		if (typeof a === "number" && typeof b === "number") {
			return Math.gcd(a, b);
		}
		return bigIntGCDWrapper2(a, b);
	}

	var pow = function (x, count, accumulator) {
		if (!(count >= 0)) {
			throw new RangeError();
		}
		if (count > Number.MAX_SAFE_INTEGER) {
			throw new RangeError("NotSupportedError");
		}
		return (count < 1 ? accumulator : (2 * Math.floor(count / 2) !== count ? pow(x, count - 1, accumulator.multiply(x)) : pow(x.multiply(x), Math.floor(count / 2), accumulator)));
	};

	var binomialCoefficient = function (n, k) {
		return k === 0 ? Expression.ONE : n.multiply(binomialCoefficient(n.subtract(Expression.ONE), k - 1)).divide(Integer.fromNumber(k));
	};

	var matrixInN = function (matrix, n) {
		var condition = -1;

		var D = matrix.map(function (e, i, j) {
			return i === j ? e : Expression.ZERO;
		});
		var N = matrix.subtract(D);
		if (N.isNilpotent()) {
			if (D.multiply(N).eql(N.multiply(D))) {

				for (var k = 0; k < D.cols(); k += 1) {
					if (D.e(k, k).equals(Expression.ZERO)) {
						var index = 1;
						while (!N.pow(index).map(function (e, i, j) {
							return i !== k ? Expression.ZERO : e;
						}).isZero()) {
							if (index >= N.cols()) {
								throw new TypeError("assertion");
							}
							index += 1;
						}
						condition = Math.max(condition, index - 1);
					}
				}
				var result = Matrix.Zero(N.cols(), N.cols());
				for (var k = 0; k < N.cols() && (k === 0 || !N.isZero()); k += 1) {
					var Dnmk = D.map(function (e, i, j) {
						return i === j ? (e.equals(Expression.ZERO) ? Expression.ZERO : e.pow(n.subtract(Expression.Integer.fromNumber(k)))) : Expression.ZERO;
					});
					result = result.add(Dnmk.multiply(N.pow(k)).scale(binomialCoefficient(n, k)));
				}
				var an = new Expression.Matrix(result);
				if (condition > 0) {
					var cases = [];
					cases.push(new ExpressionWithCondition(an, Condition.TRUE.andGreaterZero(n.subtract(Integer.fromNumber(condition)))));
					for (var i = 1; i <= condition; i += 1) {
						cases.push(new ExpressionWithCondition(new Expression.Matrix(matrix.pow(i)), Condition.TRUE.andZero(n.subtract(Integer.fromNumber(i)))));
					}
					return new Expression.Cases(cases);
				}
				return condition !== -1 ? new ExpressionWithCondition(an, Condition.TRUE.andGreaterZero(n.subtract(Integer.fromNumber(condition)))) : an;
			}
		}

		var canExponentiate = function (k) {
			if (enableAN && k instanceof Expression.Symbol) {
				return true;
			}
			if (k instanceof Exponentiation && getBase(k) instanceof Integer && getBase(k).compareTo(Expression.ONE) > 0 && isIntegerOrN(getExponent(k).inverse())) {
				return true;
			}
			return isConstant(k) || isConstant(k.divide(Expression.E));
		};

		var a = matrix;

		var symbolName = "aa";
		var anm1 = matrix.map(function (e, i, j) {
			return new Expression.Symbol(symbolName + "_(" + i + "," + j + ")");
		});
		var anm1previous = anm1.map(function (e, i, j) {
			return Expression.ZERO;
		});
		var an = undefined;
		var iteration = -1;
		while (!anm1.eql(anm1previous)) {
			iteration += 1;
			anm1previous = anm1;

			an = anm1.multiply(a);
			anm1 = an.map(function (e, i, j) {
				var isSymbol = anm1.e(i, j) instanceof Expression.Symbol && anm1.e(i, j).symbol.slice(0, symbolName.length) === symbolName;
				if (!isSymbol) {
					return anm1.e(i, j);
				}

				if (!(e instanceof Integer)) {
					var m = Polynomial.toPolynomial(e.getNumerator(), n).getDegree();
					var previous = anm1.e(i, j);
					var p = Polynomial.toPolynomial(e.getNumerator(), previous);
					var k = p.getLeadingCoefficient().divide(e.getDenominator());
					if (m !== 0 && p.getDegree() === 1 && a.e(i, j).equals(Expression.ZERO) && (k instanceof Integer || k instanceof Expression.Complex || canExponentiate(k))) {
						var f = k.pow(n).divide(k.pow(Integer.fromNumber(m + 1))).multiply(binomialCoefficient(n.subtract(Expression.ONE), m));
						var c = e.subtract(k.multiply(previous)).divide(f);

						if (c instanceof Integer) {
							console.log("!", e.toString());

							return c.multiply(k.pow(n).divide(k.pow(Integer.fromNumber(m + 2))).multiply(binomialCoefficient(n.subtract(Expression.ONE), m + 1)));
						}
					}
				}

				if (e.equals(anm1.e(i, j))) {
					return a.e(i, j);
				}

				if (anm1.e(i, j) instanceof Expression.Symbol && anm1.e(i, j).symbol === symbolName + "_(" + i + "," + j + ")" && !e.equals(Expression.ZERO)) {
					var previous = anm1.e(i, j);
					var p = Polynomial.toPolynomial(e.getNumerator(), previous);
					var k = p.getLeadingCoefficient().divide(e.getDenominator());
					var b = p.getCoefficient(0).divide(e.getDenominator());
					if (!Expression.has(b, Expression.Symbol) && e.equals(k.multiply(previous).add(b))) {
						var s = k.equals(Expression.ONE) ? b.multiply(n.subtract(Expression.TWO)) : b.multiply(Expression.ONE.subtract(k.pow(n.subtract(Expression.TWO))).divide(Expression.ONE.subtract(k)));
						return k.pow(n.subtract(Expression.TWO)).multiply(a.e(i, j)).add(s);
					}
				}
				if (anm1.e(i, j) instanceof Expression.Symbol && anm1.e(i, j).symbol === symbolName + "_(" + i + "," + j + ")" && e.equals(Expression.ZERO)) {

					condition = iteration;
					return Expression.ZERO;
				}

				var sub = e.subtract(anm1.e(i, j));
				if (sub instanceof Integer) {
					return a.e(i, j).add(sub.multiply(n.subtract(Expression.TWO)));
				}
				var dpnm1pda = function (k) {
					if (!canExponentiate(k)) {
						return Expression.ZERO;
					}
					var previous = anm1.e(i, j);
					return k.pow(n.subtract(Expression.ONE)).add(k.multiply(previous));
				};

				if (!e.equals(Expression.ZERO)) {
					var previous = anm1.e(i, j);
					var p = Polynomial.toPolynomial(e.getNumerator(), previous);
					var k = p.getLeadingCoefficient().divide(e.getDenominator());
					var d = k;
					if (e.equals(dpnm1pda(d))) {
						return d.pow(n.subtract(Expression.TWO)).multiply(n.subtract(Expression.TWO).add(a.e(i, j)));
					}
					var d = k.negate();
					if (e.equals(dpnm1pda(d))) {
						return d.pow(n.subtract(Expression.TWO)).multiply(n.subtract(Expression.TWO).add(a.e(i, j)));
					}
				}

				return anm1.e(i, j);
			});
		}
		for (var i = 0; i < anm1.rows(); i += 1) {
			for (var j = 0; j < anm1.cols(); j += 1) {
				var e = anm1.e(i, j);
				if (e instanceof Expression.Symbol && e.symbol.slice(0, symbolName.length) === symbolName) {
					return undefined;
				}
			}
		}
		if (condition > 0) {
			var cases = [];
			cases.push(new ExpressionWithCondition(new Expression.Matrix(an), Condition.TRUE.andGreaterZero(n.subtract(Integer.fromNumber(condition)))));
			for (var i = 1; i <= condition; i += 1) {
				cases.push(new ExpressionWithCondition(new Expression.Matrix(a.pow(i)), Condition.TRUE.andZero(n.subtract(Integer.fromNumber(i)))));
			}
			return new Expression.Cases(cases);
		}
		var e = new Expression.Matrix(an);
		return condition !== -1 ? new ExpressionWithCondition(e, Condition.TRUE.andGreaterZero(n.subtract(Integer.fromNumber(condition)))) : e;
	};

	var enableEX = true;
	var enable2X = true;
	var enableEC = true;
	var enableAN = true;

	var isNonNegativeQuick = function (x) {
		if (x instanceof Integer) {
			return x.compareTo(Expression.ZERO) >= 0;
		}
		if (x instanceof NthRoot) {
			return isNonNegativeQuick(x.a);
		}
		if ((x instanceof Multiplication || x instanceof Division) && !x.a.equals(Expression.ONE.negate()) && !x.b.equals(Expression.ONE.negate())) {
			return (isNonNegativeQuick(x.a) && isNonNegativeQuick(x.b)) || (isNonNegativeQuick(x.a.negate()) && isNonNegativeQuick(x.b.negate()));
		}
		if (x instanceof Addition) {
			return isNonNegativeQuick(x.a) && isNonNegativeQuick(x.b);
		}
		if (x instanceof Expression.PolynomialRootSymbol) {
			return isNonNegativeQuick(x.interval.a) && isNonNegativeQuick(x.interval.b);
		}
		if (x instanceof Expression.Multiplication && x.a.equals(Expression.ONE.negate()) && x.b instanceof Expression.PolynomialRootSymbol) {
			return !isNonNegativeQuick(x.b.interval.a) && !isNonNegativeQuick(x.b.interval.b);
		}

		if (x instanceof Expression.Abs) {
			return true;
		}
		return false;
	};

	var isPositive = function (x) {
		if (x.equals(Expression.ZERO)) {
			return false;
		}
		if (isNonNegativeQuick(x)) {
			return true;
		}
		if (isNonNegativeQuick(x.negate())) {
			return false;
		}
		if (x instanceof Expression.Symbol && !(x instanceof Expression.PolynomialRootSymbol) && !(x instanceof Expression.ExpressionPolynomialRoot) && !(x instanceof Expression.ExpressionWithPolynomialRoot)) {
			if (x === Expression.PI || x === Expression.E) {
				return true;
			}
			return false;
		}
		if (x instanceof Expression.Complex) {
			return false;
		}
		if (Expression.has(x, Expression.Complex)) {
			return false;
		}

		if (x instanceof Expression.ExpressionPolynomialRoot) {
			return x.sign() > 0;
		}
		if (x instanceof Addition || x instanceof Expression.Cos || x instanceof Expression.Sin || x instanceof Expression.Exponentiation || x instanceof Expression.Multiplication || x instanceof Expression.PolynomialRootSymbol || x instanceof Expression.ExpressionPolynomialRoot || x instanceof Expression.ExpressionWithPolynomialRoot || x instanceof Expression.Division) {
			var tmp = toDecimalStringInternal(x, {significantDigits: 1});
			var value = tmp == undefined ? 0 / 0 : Number(tmp.replace(/\((\d+)\)/g, '$1').replace(/\*10\^/g, 'e'));
			if (!Number.isNaN(value)) {
				return value > 0;
			}
		}
		if (x instanceof Expression.ExponentiationOfMinusOne) {
			return false;
		}
		if (x instanceof Expression.Exponentiation && getExponent(x) instanceof Expression.Integer) {
			return isPositive(x.a);
		}
		if (Expression.has(x, Expression.Symbol)) {
			return false;
		}

		if (x instanceof Expression.Logarithm) {
			return isPositive(x.a.subtract(Expression.ONE));
		}
		throw new TypeError("!" + x);
	};

	Expression._isPositive = isPositive;

	var isIntegerOrN = function (e) {
		if (e instanceof Integer) {
			return true;
		}
		if (e instanceof Expression.Symbol && (e.symbol === "n" || e.symbol === "k")) {
			return true;
		}
		if (e instanceof Expression.Addition || e instanceof Expression.Multiplication || e instanceof Expression.Exponentiation) {
			return isIntegerOrN(e.a) && isIntegerOrN(e.b);
		}

		return false;
	};

	var isGoodPolynomial = function (x) {
		if (x instanceof Expression.Exponentiation) {
			return false;
		}
		var v = getVariableInternal(getLastMultiplicationOperand(getFirstAdditionOperand(x))).next().value.v;
		if (v instanceof Expression.Symbol) {
			var p = Polynomial.toPolynomial(x, v);
			if (p.getDegree() === 1 && p.getCoefficient(0) instanceof Expression.Integer && p.getCoefficient(1) instanceof Expression.Integer) {
				if (p.getContent().equals(Expression.ONE)) {
					return true;
				}
			}
		}
		return false;
	};

	var isMatrixSymbolTranspose = function (e) {
		if (e instanceof Expression.Exponentiation) {
			if (getBase(e) instanceof Expression.MatrixSymbol) {
				var exp = getExponent(e);
				if (exp instanceof Expression.Symbol && exp.symbol === "T") {
					return true;
				}
				if (exp instanceof Expression.Multiplication && exp.a instanceof Expression.Integer && exp.b instanceof Expression.Symbol && exp.b.symbol === "T") {
					return true;
				}
			}
		}
		return false;
	};

	Expression.prototype.powExpression = function (x) {
		var y = this;

		if (y === Expression.INFINITY && Expression.isScalar(x)) {
			if (Expression.isReal(x)) {
				if (x.compareTo(Expression.ONE) > 0) {

					throw new RangeError("NotSupportedError");
				}
				if (x.compareTo(Expression.ONE) === 0) {
					return Expression.ONE;
				}
				if (x.compareTo(Expression.ONE.negate()) > 0) {
					return Expression.ZERO;
				}
				throw new RangeError("NotSupportedError");
			}
			var tmp = Expression.getComplexNumberParts(x);
			if (Expression.isReal(tmp.real) && Expression.isReal(tmp.imaginary)) {
				var rhorho = tmp.real._pow(2).add(tmp.imaginary._pow(2));
				if (rhorho.compareTo(Expression.ONE) < 0) {
					return Expression.ZERO;
				}
			}
		}

		if (y instanceof Expression.Symbol && (y.symbol === "t" || y.symbol === "T")) {
			if (Expression.has(x, MatrixSymbol) || Expression.has(x, Expression.Matrix)) {
				return x.transpose();
			}
		}
		if (y instanceof Expression.Multiplication && y.a instanceof Expression.Integer && y.b instanceof Expression.Symbol && (y.b.symbol === "t" || y.b.symbol === "T")) {
			if (Expression.has(x, MatrixSymbol) || Expression.has(x, Expression.Matrix)) {
				return x.pow(y.a).transpose();
			}
		}

		if (y instanceof Expression.Symbol && (y.symbol === "H")) {
			if (Expression.has(x, MatrixSymbol) || Expression.has(x, Expression.Matrix)) {
				return x.transpose().complexConjugate();
			}
		}

		if (y instanceof Division && y.a instanceof Integer && y.b instanceof Integer && x !== Expression.E && !(x instanceof Expression.Symbol) && !Expression.has(x, Expression.Symbol)) {
			if (typeof hit === "function") {
				hit({powExpression: y.toString()});
			}
			var n = y.b.toNumber();

			var q = y.a.truncatingDivide(y.b);
			var r = y.a.subtract(q.multiply(y.b));
			if (q.equals(Expression.ZERO)) {
				return x.pow(r)._nthRoot(n);
			}
			return x.pow(q).multiply(x.pow(r)._nthRoot(n));

		}

		if (x instanceof Expression.Integer && y === Expression.CIRCLE) {
			return new Expression.Degrees(x);
		}

		if (enableEX) {
			if (x === Expression.E || (enable2X && x instanceof Integer && x.compareTo(Expression.ONE) > 0 && integerPrimeFactor(x).compareTo(x) === 0)) {
				var isValid = function (y) {
					if (x instanceof Integer && y instanceof Integer) {
						return false;
					}
					if (y instanceof Addition) {
						return isValid(y.a) && isValid(y.b);
					}
					if (y instanceof Integer || y instanceof NthRoot || y instanceof Expression.Symbol || y instanceof Expression.ComplexConjugate && y.a instanceof Expression.Symbol) {
						return true;
					}
					if (y instanceof Multiplication || y instanceof Exponentiation) {
						for (var iteratorf = y.factors()[globalThis.Symbol.iterator](), f = iteratorf.next().value; f != null; f = iteratorf.next().value) {
							var b = getBase(f);
							if (!(b instanceof Integer || b instanceof NthRoot || b instanceof Expression.Symbol)) {
								if (!isValid(b)) {
									return false;
								}
							}
						}
						return true;
					}
					if ((x === Expression.E || x instanceof Integer && x.compareTo(Expression.ONE) > 0) && y instanceof Division && y.b instanceof Integer) {
						return isValid(y.a);
					}
					return false;
				};
				if (y.getNumerator() instanceof Addition && (y.getNumerator().a.isNegative() || y.getNumerator().b.isNegative())) {
					return Expression.ONE.divide(x.pow(y.getNumerator().a.negate().divide(y.getDenominator())).divide(x.pow(y.getNumerator().b.divide(y.getDenominator()))));
				}
				if (isValid(y)) {
					if (y.isNegative()) {
						return Expression.ONE.divide(new Expression.Exponentiation(x, y.negate()));
					}

					if (y instanceof Expression.ExpressionWithPolynomialRoot) {
						return x.pow(y.upgrade());
					}
					return new Expression.Exponentiation(x, y);
				}
			}
			if (enable2X && x instanceof Integer && x.compareTo(Expression.ONE) > 0) {
				if (y instanceof Addition && (y.a instanceof Integer || y.b instanceof Integer)) {
					return x.pow(y.a).multiply(x.pow(y.b));
				}
				var xf = integerPrimeFactor(x);
				if (xf.equals(x)) {
					if (y instanceof Division && y.b instanceof Integer) {
						var n = y.b.toNumber();
						if (n >= 2 && n <= Number.MAX_SAFE_INTEGER) {
							return x.pow(y.a)._nthRoot(n);
						}
					}

					if (y instanceof Division && isIntegerOrN(y.a) && isIntegerOrN(y.b)) {
						if (x.compareTo(Expression.ONE) > 0) {
							return new Expression.Exponentiation(x, y);
						}
					}

				} else {
					if (!Expression.has(y, Expression.Logarithm)) {
						var ctz = primeFactor._countTrailingZeros(x.toBigInt(), xf.toBigInt());
						return xf.pow(y.multiply(Integer.fromNumber(ctz))).multiply(x.divide(xf._pow(ctz)).pow(y));
					}
				}
			}
		}

		if (enableEX) {

			if (x instanceof Integer && x.equals(Expression.ONE)) {
				return Expression.ONE;
			}
			if (x instanceof Division || x instanceof Multiplication && (y.getDenominator().equals(Expression.ONE) || isPositive(x.a) || isPositive(x.b))) {
				if (x instanceof Division) {
					return x.a.pow(y).divide(x.b.pow(y));
				}
				if (enable2X) {
					if (x instanceof Multiplication) {
						return x.a.pow(y).multiply(x.b.pow(y));
					}
				}
			}
		}

		var yn = y.getNumerator();
		var yd = y.getDenominator();
		if (x === Expression.E && yn instanceof Multiplication && yn.a instanceof Expression.Complex && yn.a.real.equals(Expression.ZERO) && yn.b instanceof Expression.Symbol) {
			var t = y.multiply(Expression.I.negate());
			return t.cos().add(Expression.I.multiply(t.sin()));
		}
		if (x === Expression.E && getConstant(yn) instanceof Expression.Complex && yd instanceof Expression.Integer) {
			var c = getConstant(yn);
			if (c.real.equals(Expression.ZERO)) {
				var t = y.multiply(Expression.I.negate());
				t = Expression.has(y, Expression.Symbol) ? t : new Expression.Radians(t);
				return t.cos().add(Expression.I.multiply(t.sin()));
			}
			return x.pow(c.real.divide(yd)).multiply(x.pow(c.imaginary.multiply(Expression.I).multiply(yn.divide(c)).divide(yd)));
		}
		if (x === Expression.E && yn instanceof Expression.Addition && yd instanceof Expression.Integer) {
			return x.pow(yn.a.divide(yd)).multiply(x.pow(yn.b.divide(yd)));
		}

		if (x instanceof Expression.Matrix && (isIntegerOrN(y) || y === Expression.INFINITY)) {
			if (!x.matrix.isSquare()) {
				throw new RangeError("NonSquareMatrixException");
			}
			var an = matrixInN(x.matrix, y);
			if (an != undefined) {

				var D = x.matrix.map(function (e, i, j) {
					return i === j ? e : Expression.ZERO;
				});
				var N = x.matrix.subtract(D);
				if (x.matrix.isDiagonal()) {

				} else if (N.isNilpotent() && D.multiply(N).eql(N.multiply(D))) {
					if (Expression.callback != undefined) {
						Expression.callback(new Expression.Event("DpN-matrix-pow", x));
					}
				}

				return an;
			}

			if (true) {
				var eigenvalues = Expression.getEigenvalues(x.matrix);
				if (eigenvalues.length === x.matrix.cols()) {
					var eigenvectors = Expression.getEigenvectors(x.matrix, eigenvalues);
					if (eigenvectors.filter(function (v) {
						return v != null;
					}).length === x.matrix.cols()) {
						var tmp = Expression.diagonalize(x.matrix, eigenvalues, eigenvectors);
						var L = tmp.L;
						var SL = matrixInN(L, y);
						if (SL != undefined) {
							if (Expression.callback != undefined) {
								Expression.callback(new Expression.Event("pow-using-diagonalization", x));
							}
							if (Expression.callback != undefined) {

								Expression.callback(new Expression.Event("diagonalize", x));
							}
							return new Expression.Matrix(tmp.T).multiply(SL).multiply(new Expression.Matrix(tmp.T_INVERSED));
						}
					} else {
						var tmp = Expression.getFormaDeJordan(x.matrix, eigenvalues);
						var JN = matrixInN(tmp.J, y);
						if (JN != undefined) {
							if (Expression.callback != undefined) {
								Expression.callback(new Expression.Event("pow-using-Jordan-normal-form", x));
							}
							if (Expression.callback != undefined) {

								Expression.callback(new Expression.Event("Jordan-decomposition", x));
							}

							return new Expression.Matrix(tmp.P).multiply(JN).multiply(new Expression.Matrix(tmp.P_INVERSED));
						}
					}
				}
			}

		}

		if (Expression.ExponentiationOfMinusOne != null) {
			if (x instanceof Integer && x.compareTo(Expression.ZERO) < 0 || x.equals(Expression.E.negate())) {
				if (y instanceof Expression.Symbol && (y.symbol === "n" || y.symbol === "k")) {
					return new Expression.ExponentiationOfMinusOne(Expression.ONE.negate(), y).multiply(x.negate().pow(y));
				}
				if (y instanceof Addition && y.a instanceof Expression.Symbol && (y.a.symbol === "n" || y.a.symbol === "k") && y.b instanceof Integer) {
					return new Expression.ExponentiationOfMinusOne(Expression.ONE.negate(), y.a).multiply(Expression.ONE.negate().pow(y.b)).multiply(x.negate().pow(y));
				}
				if (y instanceof Multiplication) {
					return x.pow(y.a).pow(y.b);
				}
				if (y instanceof Addition && y.b instanceof Integer) {
					return x.pow(y.a).multiply(x.pow(y.b));
				}
			}
		}

		if (Expression.ExponentiationOfImaginaryUnit != null) {
			if (x instanceof Expression.Complex && x.equals(Expression.I.negate())) {
				return Expression.ONE.negate().pow(y).multiply(x.negate().pow(y));
			}
			if (x instanceof Expression.Complex && (x.equals(Expression.I) || x.real.compareTo(Expression.ZERO) > 0 && x.primeFactor().equals(x))) {
				if (y instanceof Expression.Symbol && (y.symbol === "n" || y.symbol === "k")) {
					return new Expression.ExponentiationOfImaginaryUnit(x, y);
				}
				if (y instanceof Addition && y.a instanceof Expression.Symbol && (y.a.symbol === "n" || y.a.symbol === "k") && y.b instanceof Integer) {

					return x.pow(y.a).multiply(x.pow(y.b));
				}
				if (y instanceof Multiplication) {
					return x.pow(y.a).pow(y.b);
				}
				if (y instanceof Addition && y.b instanceof Integer) {
					return x.pow(y.a).multiply(x.pow(y.b));
				}
			}
			if (x instanceof Expression.Complex && x.real.equals(Expression.ZERO) && !x.imaginary.equals(Expression.ONE)) {
				if (y instanceof Expression.Symbol && (y.symbol === "n" || y.symbol === "k")) {
					return x.imaginary.pow(y).multiply(Expression.I.pow(y));
				}
				if (y instanceof Multiplication) {
					return x.pow(y.a).pow(y.b);
				}
				if (y instanceof Addition) {
					return x.pow(y.a).multiply(x.pow(y.b));
				}
			}
			if (x instanceof Expression.Complex) {
				var pf = x.primeFactor();
				return x.divide(pf).pow(y).multiply(pf.pow(y));
			}

			if (x instanceof Expression.Integer && y instanceof Division && y.getDenominator() instanceof Integer && y.getNumerator() instanceof Expression.Symbol && (y.getNumerator().symbol === "n" || y.getNumerator().symbol === "k")) {
				return x.pow(Expression.ONE.divide(y.getDenominator())).pow(y.getNumerator());
			}

			if (x instanceof Expression.Integer && y instanceof Division && y.getDenominator() instanceof Integer && y.getNumerator() instanceof Addition) {
				return x.pow(Expression.ONE.divide(y.getDenominator())).pow(y.getNumerator());
			}
		}

		if (x === Expression.E && y instanceof Expression.Matrix) {
			if (!y.matrix.isSquare()) {
				throw new RangeError("NonSquareMatrixException");
			}

			var eigenvalues = Expression.getEigenvalues(y.matrix);
			if (eigenvalues.length === y.matrix.cols()) {
				var tmp = Expression.getFormaDeJordan(y.matrix, eigenvalues);

				var D = tmp.J.map(function (e, i, j) {
					return i === j ? e : Expression.ZERO;
				});
				var N = tmp.J.map(function (e, i, j) {
					return i !== j ? e : Expression.ZERO;
				});
				var exp = function (N) {

					var z = Matrix.Zero(N.cols(), N.cols());
					var s = z;
					var p = Matrix.I(N.cols());
					var k = 0;
					var f = 1;
					while (!p.eql(z)) {
						var summand = p.scale(Expression.ONE.divide(Integer.fromNumber(f)));
						s = s.add(summand);
						p = p.multiply(N);
						k += 1;
						f *= k;
					}
					return s;
				};
				if (Expression.callback != undefined) {
					Expression.callback(new Expression.Event("exponential-using-Jordan-canonical-form", y));
				}

				return new Expression.Matrix(tmp.P.multiply(D.map(function (e, i, j) {
					return i === j ? Expression.E.pow(e) : Expression.ZERO;
				}).multiply(exp(N))).multiply(tmp.P_INVERSED));
			}
		}

		if (x instanceof NthRoot && x.a instanceof Integer) {
			return x.a.pow(y.divide(Expression.Integer.fromNumber(x.n)));
		}

		if (enableEC) {
			if (x === Expression.E && isConstant(y) && !has(y, Expression.Complex) && !has(y, Expression.Logarithm)) {
				return new Expression.Exponentiation(x, y);
			}
			if ((x instanceof Expression.Symbol || Expression.has(x, Expression.Symbol)) && y instanceof Expression.Division && y.getDenominator() instanceof Integer) {
				return x.pow(y.getNumerator())._nthRoot(y.getDenominator().toNumber());
			}
			if (x instanceof Expression.Symbol && y instanceof Expression.Division && isIntegerOrN(y.getNumerator()) && isIntegerOrN(y.getDenominator())) {
				return new Expression.Exponentiation(x, y);
			}
			if (x === Expression.E && y instanceof Expression.Addition) {
				return x.pow(y.a).multiply(x.pow(y.b));
			}
			if (x instanceof Exponentiation && getBase(x) === Expression.E) {
				return getBase(x).pow(getExponent(x).multiply(y));
			}
			if (isGoodPolynomial(x) && y instanceof Expression.Division && isIntegerOrN(y.getNumerator()) && isIntegerOrN(y.getDenominator())) {
				return new Expression.Exponentiation(x, y);
			}
		}

		if (x instanceof Expression.Matrix && y instanceof Expression.Addition) {
			return x.pow(y.a).multiply(x.pow(y.b));
		}
		if (x instanceof Expression.Matrix && y instanceof Expression.Multiplication && y.a instanceof Expression.Integer) {
			return x.pow(y.a).pow(y.b);
		}
		if (x instanceof Expression.Matrix && y instanceof Expression.Division) {

			if (y.getNumerator().equals(Expression.ONE) && y.getDenominator() instanceof Expression.Symbol && (y.getDenominator().symbol === "n" || y.getDenominator().symbol === "k")) {
				return x._nthRoot(y.getDenominator());
			}
			if (isIntegerOrN(y.getNumerator()) && isIntegerOrN(y.getDenominator())) {
				return x.pow(y.getNumerator()).pow(Expression.ONE.divide(y.getDenominator()));
			}
		}

		if (y instanceof Expression.Symbol && (y.symbol === "n" || y.symbol === "k")) {
			var qi = QuadraticInteger.toQuadraticInteger(x);
			if (qi != null && Number(qi.a.toString()) > 0 && qi.D > 0 && (qi.isValid() || true)) {
				if (Number(qi.b.toString()) > 0) {
					return new Expression.ExponentiationOfQuadraticInteger(x, y);
				}
				if (Number(qi.b.toString()) < 0) {
					var xc = qi.conjugate().toExpression();
					return x.multiply(xc).pow(y).divide(xc.pow(y));
				}
			}
			if (qi != null && Number(qi.a.toString()) < 0) {
				return Expression.ONE.negate().pow(y).multiply(qi.toExpression().negate().pow(y));
			}

		}

		if (enableAN) {
			if (isIntegerOrN(y)) {
				if (y instanceof Addition) {
					for (var iterators = y.summands()[globalThis.Symbol.iterator](), s = iterators.next().value; s != null; s = iterators.next().value) {
						if (s.isNegative()) {
							return x.pow(y.subtract(s)).divide(x.pow(s.negate()));
						}
					}
				}
				if (y.isNegative()) {
					return Expression.ONE.divide(x.pow(y.negate()));
				}

				if (Expression.isConstant(x) && !getConstant(y).equals(Expression.ONE)) {
					return x.pow(getConstant(y)).pow(y.divide(getConstant(y)));
				}
				var goodX = x instanceof Expression.Symbol || x instanceof Expression.Addition && !(Expression.has(x, Expression.Sin) || Expression.has(x, Expression.Cos));
				if (goodX) {
					return new Expression.Exponentiation(x, y);
				}
			}
			if (x instanceof Exponentiation && getBase(x) instanceof Integer && getBase(x).compareTo(Expression.ONE) > 0 && isIntegerOrN(getExponent(x).getNumerator()) && isIntegerOrN(getExponent(x).getDenominator())) {
				return getBase(x).pow(getExponent(x).multiply(y));
			}
			if (x instanceof Exponentiation && isGoodPolynomial(getBase(x)) && isIntegerOrN(getExponent(x)) && isIntegerOrN(y)) {
				return getBase(x).pow(getExponent(x).multiply(y));
			}
			if (x instanceof Exponentiation && isGoodPolynomial(getBase(x)) && isIntegerOrN(getExponent(x).inverse()) && isIntegerOrN(y.inverse())) {
				return getBase(x).pow(getExponent(x).multiply(y));
			}
		}

		if (Expression.has(x, Expression.Sin) || Expression.has(x, Expression.Cos)) {
			return Expression._replaceBySinCos(Expression._replaceSinCos(x).pow(y));
		}

		if (x === Expression.E && y instanceof Expression.Logarithm) {
			return y.a;
		}
		if (x === Expression.E && y instanceof Expression.Multiplication && y.a instanceof Integer && y.b instanceof Expression.Logarithm) {
			return x.pow(y.b).pow(y.a);
		}
		if (x === Expression.E && y instanceof Expression.Multiplication && y.a instanceof Expression.Symbol && y.b instanceof Expression.Logarithm) {
			return x.pow(y.b).pow(y.a);
		}
		if (x instanceof Expression.Integer && Expression.has(y, Expression.Logarithm)) {
			return Expression.E.pow(x.logarithm().multiply(y));
		}

		if (x instanceof Exponentiation && getBase(x) instanceof Integer && getBase(x).compareTo(Expression.TWO) >= 0 && isIntegerOrN(y)) {

			return getBase(x).pow(getExponent(x).multiply(y));
		}

		if (x === Expression.E && y instanceof Expression.ComplexConjugate && y.a instanceof Expression.Symbol) {
			return new Expression.Exponentiation(x, y);
		}

		throw new RangeError("NotSupportedError");
	};

	Expression.prototype.compare4Addition = function (y) {
		var x = this;
		if (x instanceof Integer && y instanceof Integer) {
			return x.compareTo(y);
		}
		if (x instanceof Expression.Symbol && y instanceof Integer) {
			return +1;
		}
		if (x instanceof Integer && y instanceof Expression.ExpressionPolynomialRoot) {

			return 0;
		}
		if (x instanceof Integer && y instanceof Expression.Symbol) {
			return -1;
		}
		if (x instanceof Expression.Symbol && y instanceof Expression.Symbol) {
			return x.symbol < y.symbol ? -1 : (y.symbol < x.symbol ? +1 : 0);
		}

		if (x instanceof Expression.Matrix && y instanceof MatrixSymbol) {
			return +1;
		}
		if (x instanceof MatrixSymbol && y instanceof Expression.Matrix) {
			return -1;
		}
		if (x instanceof Expression.Matrix && y instanceof Expression.Matrix) {

			return 0;
		}

		if (x instanceof Addition || y instanceof Addition) {
			return Addition.compare4Addition(x, y);
		}

		if (x instanceof Multiplication || y instanceof Multiplication) {
			return Multiplication.compare4Addition(x, y);
		}

		if (x instanceof Integer && y instanceof Expression.Function) {
			return -1;
		}

		if (x instanceof Division && y instanceof Division) {
			return x.a.compare4Addition(y.a) || x.b.compare4Addition(y.b);
		}
		if (x instanceof Expression && y instanceof Division) {
			return +1;
		}
		if (x instanceof Division && y instanceof Expression) {
			return -1;
		}

		if (x instanceof Expression.Matrix) {
			return -1;
		}
		if (y instanceof Expression.Matrix) {
			return +1;
		}

		if (x instanceof Integer && y instanceof Expression.Complex) {
			return -1;
		}
		if (x instanceof Expression.Complex && y instanceof Integer) {
			return +1;
		}

		if (x.equals(y)) {
			return 0;
		}

		if (x instanceof Expression.Exponentiation || y instanceof Expression.Exponentiation) {
			return getBase(x).compare4Addition(getBase(y)) || (0 - getExponent(x).compare4Addition(getExponent(y)));
		}

		if (y instanceof Expression.Symbol) {
			return -1;
		}

		throw new RangeError();
	};

	var compare = function (x, y) {
		return x.compare4Addition(y);
	};

	var compare4Multiplication = function (x, y) {

		return x.compare4Multiplication(y);
	};

	var getBase = function (x) {

		return x instanceof Exponentiation ? x.a : x;
	};
	var getExponent = function (x) {

		return x instanceof Exponentiation ? x.b : Expression.ONE;
	};

	var getConstant = function (e, allowExpressionPolynomialRoot) {
		allowExpressionPolynomialRoot = allowExpressionPolynomialRoot == undefined ? undefined : allowExpressionPolynomialRoot;

		if (e instanceof Integer) {
			return e;
		} else if (e instanceof Expression.Complex) {
			return e;
		} else if (e instanceof Expression.ExpressionPolynomialRoot) {
			if (allowExpressionPolynomialRoot) {
				return e;
			}
		} else if (e instanceof Multiplication) {
			var c = undefined;
			var x = e;
			for (var iteratory = x.factors()[globalThis.Symbol.iterator](), y = iteratory.next().value; y != null; y = iteratory.next().value) {
				var t = getConstant(y, allowExpressionPolynomialRoot);
				c = c == undefined ? t : t.multiply(c);
			}
			if (c != undefined) {
				return c;
			}
		} else if (e instanceof Addition) {
			var c = undefined;
			for (var iteratorx = e.summands()[globalThis.Symbol.iterator](), x = iteratorx.next().value; x != null; x = iteratorx.next().value) {
				var t = getConstant(x, allowExpressionPolynomialRoot);

				c = c == undefined ? t : complexGCD(t, c);
			}
			if (c != undefined) {
				return c;
			}
		}
		return Expression.ONE;
	};
	var getTerm = function (x, allowExpressionPolynomialRoot) {
		allowExpressionPolynomialRoot = allowExpressionPolynomialRoot == undefined ? undefined : allowExpressionPolynomialRoot;

		if (x instanceof Integer) {
			return undefined;
		} else if (x instanceof Expression.Complex) {
			return undefined;
		} else if (x instanceof Expression.ExpressionPolynomialRoot) {
			if (allowExpressionPolynomialRoot) {
				return undefined;
			}
		} else if (x instanceof Multiplication) {
			var terms = [];
			for (var iteratory = x.factors()[globalThis.Symbol.iterator](), y = iteratory.next().value; y != null; y = iteratory.next().value) {
				var t = getTerm(y, allowExpressionPolynomialRoot);
				if (t != undefined) {
					terms.push(t);
				}
			}
			var result = undefined;
			for (var j = terms.length - 1; j >= 0; j -= 1) {
				result = result == undefined ? terms[j] : new Multiplication(result, terms[j]);
			}
			return result;
		} else if (x instanceof Addition) {
			return x.divide(getConstant(x));
		}
		return x;
	};

	Expression.getConstant = getConstant;

	var multiplyByInteger = function (x, y) {
		if (x.compareTo(Expression.ZERO) === 0) {
			return x;
		}
		if (x.compareTo(Expression.ONE) === 0) {
			return y;
		}
		return new Multiplication(x, y);
	};

	Expression.prototype.multiplyExpression = function (x) {
		var y = this;

		if (x instanceof Expression && y instanceof Multiplication) {
			return x.multiply(y.a).multiply(y.b);
		}
		if (x instanceof Multiplication && y instanceof Expression) {
			var c = compare4Multiplication2(x.b, y);
			if (c === 0) {
				return x.a.multiply(x.b.multiply(y));
			}
			return c > 0 ? x.a.multiply(y).multiply(x.b) : new Multiplication(x, y);
		}

		var c = 0;
		if (x instanceof Integer && y instanceof Expression.Symbol) {
			return multiplyByInteger(x, y);
		}
		if (x instanceof Expression.Symbol && y instanceof Integer) {
			return multiplyByInteger(y, x);
		}
		if (x instanceof Expression.Symbol && y instanceof Expression.Symbol) {
			c = compare4Multiplication(x, y);
			if (c === 0) {
				return x.pow(Expression.TWO);
			}
			return c > 0 ? new Multiplication(y, x) : new Multiplication(x, y);
		}
		if (x instanceof Integer && y instanceof Exponentiation) {
			return multiplyByInteger(x, y);
		}
		if (x instanceof Exponentiation && y instanceof Integer) {
			return multiplyByInteger(y, x);
		}

		if (getBase(x) instanceof Expression.MatrixSymbol || getBase(y) instanceof Expression.MatrixSymbol) {
			c = compare4Multiplication(getBase(x), getBase(y));
			if (c === 0) {
				if (getExponent(x).equals(new Expression.Symbol("T")) || getExponent(y).equals(new Expression.Symbol("T"))) {
					return new Multiplication(x, y);
				}
			}
		}
		if (x instanceof Exponentiation && y instanceof Expression.Symbol) {
			c = compare4Multiplication(getBase(x), y);
			if (c === 0) {
				return y.pow(getExponent(x).add(Expression.ONE));
			}
			return c > 0 ? new Multiplication(y, x) : new Multiplication(x, y);
		}
		if (x instanceof Expression.Symbol && y instanceof Exponentiation) {
			c = compare4Multiplication(x, getBase(y));
			if (c === 0) {
				return x.pow(getExponent(y).add(Expression.ONE));
			}
			return c > 0 ? new Multiplication(y, x) : new Multiplication(x, y);
		}
		if (x instanceof Exponentiation && y instanceof Exponentiation) {
			c = compare4Multiplication(getBase(x), getBase(y));
			if (c === 0) {
				return getBase(x).pow(getExponent(x).add(getExponent(y)));
			}
			return c > 0 ? new Multiplication(y, x) : new Multiplication(x, y);
		}

		if (x instanceof SquareRoot && y instanceof SquareRoot) {
			if (x.a instanceof Integer && y.a instanceof Exponentiation) {
				return new Multiplication(x, y);
			}

			var g = x.a.gcd(y.a);
			var r1 = x.a.divide(g).multiply(y.a.divide(g));
			if (x.a instanceof Expression.Integer && y.a instanceof Expression.Integer && r1.compareTo(Expression.ONE) > 0) {

				return g.multiply(makeRoot(r1, 2));
			}
			return g.multiply(r1.squareRoot());

		}
		if (x instanceof NthRoot && x.n === 3 && y instanceof NthRoot && y.n === 3) {

			return x.a.multiply(y.a)._nthRoot(3);
		}
		if (x instanceof NthRoot && y instanceof NthRoot) {

			if (x.a instanceof Integer && !(y.a instanceof Integer) && x.n < y.n && getVariable(y.a)._pow(2).gcd(x.a).equals(x.a)) {
				if (Expression.isConstant(x) && Expression.isConstant(y)) {
					return y.multiply(x);
				}
			}

			var ng = Math.gcd(x.n, y.n);

			if (!(x.a instanceof Integer) && (!(y.a instanceof Integer) || !x.a._pow(2).gcd(y.a).equals(Expression.ONE) || getVariable(x.a)._pow(2).gcd(y.a).equals(getVariable(x.a)._pow(2))) || !x.a.gcd(y.a).equals(Expression.ONE)) {
				var v = Expression.pow(x.a, y.n / ng).multiply(Expression.pow(y.a, x.n / ng));
				var nn = x.n / ng * y.n;
				return v._nthRoot(nn);
			}
			if (!(x.a instanceof Integer) && x.n === 2 && y.a instanceof Integer && y.n === 4 && !(getConstant(x.a.getNumerator()).multiply(y.a)._nthRoot(y.n) instanceof NthRoot)) {
				return x.a.multiply(y.a._nthRoot(2))._nthRoot(2);
			}
			return x.n < y.n ? new Multiplication(x, y) : (x.n > y.n ? new Multiplication(y, x) : x.a.multiply(y.a)._nthRoot(x.n));
		}

		if (x instanceof MatrixSymbol && y instanceof Expression.Matrix) {
			return new Multiplication(x, y);
		}
		if (x instanceof Expression.Matrix && y instanceof MatrixSymbol) {
			return new Multiplication(x, y);
		}
		if (has(x, MatrixSymbol) && y instanceof Expression.Matrix) {
			return new Multiplication(x, y);
		}
		if (x instanceof Expression.Matrix && has(y, MatrixSymbol)) {
			return new Multiplication(x, y);
		}

		if (x instanceof Integer && y instanceof Expression) {
			if (x.compareTo(Expression.ZERO) === 0) {
				return x;
			}
			if (x.compareTo(Expression.ONE) === 0) {
				return y;
			}
		}
		if (x instanceof Expression && y instanceof Integer) {
			if (y.compareTo(Expression.ZERO) === 0) {
				return y;
			}
			if (y.compareTo(Expression.ONE) === 0) {
				return x;
			}
		}

		var cmp = x instanceof Expression.Complex && y instanceof Expression.ExponentiationOfImaginaryUnit ? -1 : (x instanceof Expression.ExponentiationOfImaginaryUnit && y instanceof Expression.Complex ? +1 : compare4Multiplication(getBase(x), getBase(y)));
		if (cmp === 0) {
			return getBase(x).pow(getExponent(x).add(getExponent(y)));
		}
		if (cmp < 0) {
			return new Multiplication(x, y);
		}
		if (cmp > 0) {
			return new Multiplication(y, x);
		}

	};

	function Iterator() {
	}

	if ("\v" !== "v") {
		Object.defineProperty(Iterator.prototype, "done", {
			get: function () {
				return this.value == null;
			}
		});
	}
	Iterator.prototype[globalThis.Symbol.iterator] = function () {
		return this;
	};

	function TermFactorsIterator(e) {
		this.value = undefined;
		this.e = e;
		this.hasPolynomialRoot = false;
	}

	TermFactorsIterator.prototype = Object.create(Iterator.prototype);
	TermFactorsIterator.prototype.next = function () {
		this.value = this.e instanceof Multiplication ? this.e.b : (this.e instanceof Integer || this.e instanceof Expression.Complex || this.e instanceof Expression.ExpressionPolynomialRoot ? null : this.e);
		this.hasPolynomialRoot = this.e instanceof Expression.ExpressionPolynomialRoot;
		this.e = this.e instanceof Multiplication ? this.e.a : undefined;
		return this;
	};

	function termFactors(e) {
		return new TermFactorsIterator(e);
	}

	var compare4Addition = function (x, y) {

		var i = termFactors(x);
		var j = termFactors(y);
		var a = i.next().value;
		var b = j.next().value;
		while (a != null && b != null) {

			var cmp = 0 - compare(getBase(a), getBase(b));
			if (cmp === 0) {
				cmp = compare(getExponent(a), getExponent(b));
			}
			if (cmp !== 0) {
				return cmp;
			}
			a = i.next().value;
			b = j.next().value;
		}

		while (a == null && i.hasPolynomialRoot && Expression.isRealAlgebraicNumber(b)) {
			b = j.next().value;
		}
		while (b == null && j.hasPolynomialRoot && Expression.isRealAlgebraicNumber(a)) {
			a = i.next().value;
		}

		if (a instanceof Expression.Matrix || b instanceof Expression.Matrix) {
			if (y instanceof Integer && x instanceof Multiplication) {
				return +1;
			}
			if (x instanceof Integer && y instanceof Multiplication) {
				return -1;
			}
			if (a != null && i.next().value != null) {
				return +1;
			}
			if (b != null && j.next().value != null) {
				return -1;
			}
			return 0;
		}

		return a != null ? +1 : (b != null ? -1 : 0);
	};

	var addSimilar = function (x, y) {
		if (x instanceof Expression.Matrix && y instanceof Expression.Matrix) {
			return x.add(y);
		}
		var c1 = getConstant(x);
		var c2 = getConstant(y);
		var i = termFactors(getTerm(x));
		var j = termFactors(getTerm(y));
		var a = i.next().value;
		var b = j.next().value;
		var result = Expression.ONE;
		var added = false;
		while (a != null || b != null) {
			var f = null;
			if (a instanceof Expression.Matrix && a.matrix.isScalar() && isScalar(a.matrix.e(0, 0)) && !a.matrix.e(0, 0).equals(Expression.ZERO) && b instanceof Expression.Matrix && b.matrix.isScalar() && isScalar(b.matrix.e(0, 0)) && !b.matrix.e(0, 0).equals(Expression.ZERO) && a.matrix.rows() === b.matrix.rows() && a.matrix.cols() === b.matrix.cols() && !a.equals(b)) {
				var f = function (a, x) {

					return a.matrix.e(0, 0).multiply(x).multiply(a.inverse());
				};
				return addSimilar(f(a, x), f(b, y));
			} else if (!added && (a instanceof Expression.Matrix || b instanceof Expression.Matrix) && (a == null || b == null || !a.equals(b))) {
				added = true;
				f = (a == null ? c1 : a.multiply(c1)).add(b == null ? c2 : b.multiply(c2));
				c1 = Expression.ONE;
				c2 = Expression.ONE;
			} else {
				if (!a.equals(b)) {

					return null;
				}
				f = a;
			}
			result = f.multiply(result);
			a = i.next().value;
			b = j.next().value;
		}
		if (!added) {
			result = c1.add(c2).multiply(result);
		}
		return result;
	};

	Expression.getComplexNumberParts = function (e) {
		if (e instanceof Expression.Division) {
			var tmp = Expression.getComplexNumberParts(e.getNumerator());
			return {
				real: tmp.real.divide(e.getDenominator()),
				imaginary: tmp.imaginary.divide(e.getDenominator())
			};
		}
		if (!Expression.has(e, Expression.Complex)) {
			return {
				real: e,
				imaginary: Expression.ZERO
			};
		}
		var real = [];
		var imaginary = [];
		for (var iteratorx = e.summands()[globalThis.Symbol.iterator](), x = iteratorx.next().value; x != null; x = iteratorx.next().value) {
			var c = undefined;
			for (var iteratory = x.factors()[globalThis.Symbol.iterator](), y = iteratory.next().value; y != null; y = iteratory.next().value) {
				if (c == undefined && y instanceof Expression.Complex) {
					c = y;
				}
			}
			if (c == undefined) {
				real.push(x);
			} else if (c.real.equals(Expression.ZERO)) {
				imaginary.push(x.multiply(Expression.I.negate()));
			} else {
				var r = null;
				if (x !== c) {
					for (var iteratory = x.factors()[globalThis.Symbol.iterator](), y = iteratory.next().value; y != null; y = iteratory.next().value) {
						if (y !== c) {
							r = r == null ? y : r.multiply(y);
						}
					}
				}
				if (r == null) {

					real.push(c.real);
					imaginary.push(c.imaginary);
				} else {
					real.push(r.multiply(c.real));
					imaginary.push(r.multiply(c.imaginary));
				}
			}
		}
		return {
			real: _sum(real),
			imaginary: _sum(imaginary)
		};
	};

	Expression.prototype.addExpression = function (x) {
		var y = this;
		if (x.equals(Expression.ZERO)) {
			return y;
		}
		if (y.equals(Expression.ZERO)) {
			return x;
		}

		if (x instanceof Multiplication && x.b instanceof IdentityMatrix) {
			var t = getIdentityMatrixCoefficient(y);
			if (t != null) {
				return x.a.add(t).multiply(x.b);
			}
		} else if (x instanceof IdentityMatrix) {
			var t = getIdentityMatrixCoefficient(y);
			if (t != null) {
				return Expression.ONE.add(t).multiply(x);
			}
		}
		if (y instanceof Multiplication && y.b instanceof IdentityMatrix) {
			var t = getIdentityMatrixCoefficient(x);
			if (t != null) {
				return t.add(y.a).multiply(y.b);
			}
		} else if (y instanceof IdentityMatrix) {
			var t = getIdentityMatrixCoefficient(x);
			if (t != null) {
				return t.add(Expression.ONE).multiply(y);
			}
		}

		if ((has2(x, Expression.Complex) || has2(y, Expression.Complex)) && (has2(x, Expression.ExpressionPolynomialRoot) || has2(y, Expression.ExpressionPolynomialRoot))) {
			var tmp = Expression.getComplexNumberParts(x);
			var tmp1 = Expression.getComplexNumberParts(y);
			var re = tmp.real.add(tmp1.real);
			var im = tmp.imaginary.add(tmp1.imaginary);
			if (im.equals(Expression.ZERO)) {
				return re;
			}
			if (!(im instanceof Expression.Addition)) {
				if (re.equals(Expression.ZERO)) {
					return im.multiply(Expression.I);
				}
				if (!has2(re, Expression.ExpressionPolynomialRoot) && !has2(im, Expression.ExpressionPolynomialRoot)) {
					return re.add(im.multiply(Expression.I));
				}
				return new Expression.Addition(re, im.multiply(Expression.I));
			}
		}

		var i = x.summands();
		var j = y.summands();
		var a = i.next().value;
		var dontMove = 0;
		var b = j.next().value;
		var s = [];

		while (a != null && b != null) {
			var c = compare4Addition(a, b);
			if (c < 0) {
				s.push(a);
				a = i.next().value;
			} else if (c > 0) {
				s.push(b);
				b = j.next().value;
			} else {
				if (has2(a, Expression.Matrix) || has2(b, Expression.Matrix)) {
					var last = addSimilar(a, b);
					if (last != null) {
						if (!last.equals(Expression.ZERO)) {
							s.push(last);
						}
					} else {

						s.push(a);
						s.push(b);
					}
				} else {
					var constantA = getConstant(a, true);
					var constantB = getConstant(b, true);
					var termA = getTerm(a, true) || Expression.ONE;
					var termB = getTerm(b, true) || Expression.ONE;
					var constant = (termA.equals(termB) ? constantA : constantA.multiply(termA.divide(termB))).add(constantB);
					var last = termB === Expression.ONE ? constant : (constant instanceof Expression.Addition ? new Expression.Multiplication(constant, termB) : constant.multiply(termB));
					dontMove = 0;
					if (!last.equals(Expression.ZERO)) {
						if (Expression.has(last, Expression.ExpressionPolynomialRoot)) {
							if (Expression.has(a, Expression.ExpressionPolynomialRoot)) {
								a = last;
								dontMove = 1;
							} else {
								b = last;
								dontMove = 2;
							}
						} else {
							s.push(last);
						}
					}
				}
				if (dontMove !== 1) {
					a = i.next().value;
				}
				if (dontMove !== 2) {
					b = j.next().value;
				}
			}
		}
		while (a != null) {
			s.push(a);
			a = i.next().value;
		}
		while (b != null) {
			s.push(b);
			b = j.next().value;
		}
		if (s.length === 0) {
			return Expression.ZERO;
		}
		var accumulator = s[s.length - 1];
		for (var k = s.length - 2; k >= 0; k -= 1) {
			var currentValue = s[k];
			accumulator = new Addition(accumulator, currentValue);
		}
		return accumulator;
	};

	var divideByInteger = function (e, f) {
		if (f.equals(Expression.ZERO)) {
			throw new TypeError("ArithmeticException");
		}
		var result = [];
		for (var iteratorx = e.summands()[globalThis.Symbol.iterator](), x = iteratorx.next().value; x != null; x = iteratorx.next().value) {
			var rest = Expression.ONE;
			var t = undefined;

			for (var iteratory = x.factors()[globalThis.Symbol.iterator](), y = iteratory.next().value; y != null; y = iteratory.next().value) {
				var z = y;
				if (z instanceof Integer || z instanceof Expression.Complex || z instanceof Expression.ExpressionPolynomialRoot) {
					if (t != undefined) {
						console.warn("!");
						t = t.multiply(z);
					} else {
						t = z;
					}
				} else {
					if (rest === Expression.ONE) {
						rest = z;
					} else {
						rest = z.multiply(rest);
					}
				}
			}
			if (!(t instanceof Expression.Complex)) {
				if (!(t instanceof Integer)) {
					if (!(t instanceof Expression.ExpressionPolynomialRoot)) {
						throw new RangeError();
					}
				}
			}
			var summand = null;
			if (t instanceof Expression.ExpressionPolynomialRoot) {
				summand = t.divide(f).multiply(rest);
			} else {
				summand = t.truncatingDivide(f).multiply(rest);
			}
			result.push(summand);
		}
		return _sum(result);
	};

	Expression.getCoefficients = function (e, v) {
		if (e.equals(Expression.ZERO)) {
			return [];
		}
		var result = [];
		for (var iteratorx = e.summands()[globalThis.Symbol.iterator](), x = iteratorx.next().value; x != null; x = iteratorx.next().value) {
			var d = Expression.ZERO;
			var c = Expression.ONE;
			for (var iteratory = x.factors()[globalThis.Symbol.iterator](), y = iteratory.next().value; y != null; y = iteratory.next().value) {
				var t = y;
				for (var iteratorve = getVariableInternal(t)[globalThis.Symbol.iterator](), ve = iteratorve.next().value; ve != null; ve = iteratorve.next().value) {
					if (ve.v.equals(v)) {
						d = d.add(ve.e);
					} else {
						c = c.multiply(ve.e === Expression.ONE ? ve.v : ve.v.pow(ve.e));
					}
				}
			}
			var degree = d.toNumber();
			result.push({
				degree: degree,
				coefficient: c
			});
		}
		result.sort(function (a, b) {
			return b.degree - a.degree;
		});
		var k = -1;
		for (var i = 0; i < result.length; i += 1) {
			var x = result[i];
			if (k === -1 || x.degree !== result[k].degree) {
				k += 1;
				result[k] = {
					degree: x.degree,
					coefficient: []
				};
			}
			result[k].coefficient.push(x.coefficient);
		}
		result.length = k + 1;
		for (var i = 0; i < result.length; i += 1) {
			result[i] = {
				degree: result[i].degree,
				coefficient: _sum(result[i].coefficient)
			};
		}
		return result;
	};

	var getFirstAdditionOperand = function (x) {
		var result = x;
		while (result instanceof Addition) {
			result = result.a;
		}
		return result;
	};

	var getLastMultiplicationOperand = function (x) {
		var result = x;
		while (result instanceof Multiplication) {
			result = result.b;
		}
		return result;
	};

	function VIterator(v) {
		if (v == undefined) {
			throw new TypeError();
		}
		this.value = undefined;
		this.v = v;
	}

	VIterator.prototype = Object.create(Iterator.prototype);
	VIterator.prototype.next = function () {
		this.value = this.v;
		this.v = undefined;
		return this;
	};

	function VariablesIterator(v, additions) {
		if (additions == undefined) {
			throw new TypeError();
		}
		this.value = undefined;
		this.v = v;
		this.additions = additions;
	}

	VariablesIterator.prototype = Object.create(Iterator.prototype);
	VariablesIterator.prototype.next = function () {
		var x = this.additions.next().value;
		var value = null;
		if (x == null) {
			value = null;
		} else if (x instanceof Expression.Symbol) {
			value = {
				v: new Exponentiation(this.v, x),
				e: Expression.ONE
			};
		} else if (x instanceof Expression.NthRoot) {
			value = {
				v: new Exponentiation(this.v, x),
				e: Expression.ONE
			};
		} else if (x instanceof Expression.Exponentiation) {
			value = {
				v: new Exponentiation(this.v, x),
				e: Expression.ONE
			};
		} else if (x instanceof Multiplication && x.a instanceof Integer) {
			value = {
				v: new Exponentiation(this.v, x.b),
				e: x.a
			};
		} else if (x instanceof Multiplication) {
			value = {
				v: new Exponentiation(this.v, getTerm(x)),
				e: getConstant(x)
			};
		} else if (x instanceof Integer) {
			value = {
				v: this.v,
				e: x
			};
		} else if (x instanceof Expression.Division && x.a instanceof Integer && x.b instanceof Integer) {
			value = {
				v: this.v,
				e: x
			};
		} else if (x instanceof Expression.Division && x.a instanceof NthRoot && x.b instanceof Integer) {

			value = {
				v: new Exponentiation(this.v, x.getNumerator()),
				e: Expression.ONE.divide(x.getDenominator())
			};
		} else if (x instanceof Expression.Division && x.a instanceof Multiplication && x.a.a instanceof Integer && x.b instanceof Integer) {
			if (this.v instanceof Integer) {
				value = {
					v: new Exponentiation(this.v, x.a.b),
					e: x.divide(x.a.b)
				};
			} else {
				value = {
					v: this.v,
					e: x
				};
			}
		} else {

			if (x instanceof Division && x.b instanceof Integer) {
				var t = getTerm(x.a);
				value = {
					v: new Exponentiation(this.v, t),
					e: x.divide(t)
				};
			} else {
				if (x instanceof Division && x.a instanceof Integer && x.b instanceof Expression.Symbol && (this.v instanceof Integer || this.v instanceof Expression.Symbol || isGoodPolynomial(this.v))) {
					var t = Expression.ONE.divide(x.b);
					value = {
						v: new Exponentiation(this.v, t),
						e: x.divide(t)
					};
				} else {
					throw new RangeError();
				}
			}
		}
		this.value = value;
		return this;
	};

	function NumeratorSummandsIterator(e) {
		this.value = undefined;
		this.internal = e.getNumerator().summands();
		this.denominator = e.getDenominator();
	}

	NumeratorSummandsIterator.prototype = Object.create(Iterator.prototype);
	NumeratorSummandsIterator.prototype.next = function () {
		var next = this.internal.next().value;
		this.value = next == null ? null : next.divide(this.denominator);
		return this;
	};

	var getVariableInternal = function (t) {
		if (t instanceof Expression.ExponentiationOfMinusOne) {
			return new VIterator({
				v: t,
				e: Expression.ONE
			});
		}
		if (t instanceof Expression.ExponentiationOfImaginaryUnit) {
			return new VIterator({
				v: t,
				e: Expression.ONE
			});
		}
		var v = getBase(t);
		var e = getExponent(t);

		if (enableEX) {
			if (!(e instanceof Integer)) {
				var additions = new NumeratorSummandsIterator(e);
				return new VariablesIterator(v, additions);
			}
		}

		return new VIterator({
			v: v,
			e: e
		});
	};

	var getVariable = function (e, options) {
		options = options == undefined ? null : options;

		if (options == null || !options.avoidNthRoots) {

			for (var iteratorx = e.summands()[globalThis.Symbol.iterator](), x = iteratorx.next().value; x != null; x = iteratorx.next().value) {
				for (var iteratory = x.factors()[globalThis.Symbol.iterator](), y = iteratory.next().value; y != null; y = iteratory.next().value) {
					if (y instanceof NthRoot) {

						return y;
					}
				}
			}

		}
		if (options != null && options.preferFunctions) {
			for (var iteratorx = e.summands()[globalThis.Symbol.iterator](), x = iteratorx.next().value; x != null; x = iteratorx.next().value) {
				for (var iteratory = x.factors()[globalThis.Symbol.iterator](), y = iteratory.next().value; y != null; y = iteratory.next().value) {
					if (y instanceof Expression.Function) {
						return y;
					}
				}
			}
		}

		var result = getVariableInternal(getLastMultiplicationOperand(getFirstAdditionOperand(e))).next().value.v;

		if (result instanceof Expression.Complex) {
			return undefined;
		}
		if (result instanceof Integer) {
			return undefined;
		}
		if (options != null && options.avoidNthRoots) {
			if (result instanceof NthRoot) {
				return undefined;
			}
		}
		return result;
	};

	Expression.getVariable = getVariable;

	var lastMaxSize = 1;
	var integerGCD = function (x, y) {
		if (x instanceof Expression.Multiplication) {

			x = getConstant(x, false);
		}
		if (y instanceof Expression.Multiplication) {

			y = getConstant(y, false);
		}
		if (x instanceof Expression.Complex && x.real.equals(Expression.ZERO)) {
			x = x.imaginary;
		}
		if (y instanceof Expression.Complex && y.real.equals(Expression.ZERO)) {
			y = y.imaginary;
		}
		if (x instanceof Expression.Integer && y instanceof Expression.Integer) {
			return Expression.Integer.fromBigInt(bigIntGCDWrapper(x.value, y.value));
		}
		var a = x;
		var b = y;
		while (!b.equals(Expression.ZERO)) {
			var r = a.remainder(b);
			a = b;
			b = r;
		}
		return a;
	};

	var complexGCD = function (a, b) {
		if (a instanceof Expression.ExpressionPolynomialRoot) {
			var x = a.root.getAlphaExpression();
			return complexGCD(Expression.getConstant(x.getNumerator()), b);
		}
		if (b instanceof Expression.ExpressionPolynomialRoot) {
			var x = b.root.getAlphaExpression();
			return complexGCD(a, Expression.getConstant(x.getNumerator()));
		}

		var x = integerGCD(a, b);
		if (x instanceof Expression.Complex) {

			if (x.real.compareTo(Expression.ZERO) === 0) {
				return x.imaginary;
			}
		}
		if (x instanceof Expression.Integer) {
			if (x.compareTo(Expression.ZERO) < 0) {
				x = x.negate();
			}
		}
		return x;
	};

	var nthRootCommonFactor = function (a, b) {
		if (a instanceof Expression.NthRoot && b instanceof Expression.NthRoot) {

			var lcm = a.n / Math.gcd(a.n, b.n) * b.n;

			var radicandsGCD = a.radicand.gcd(b.radicand);
			var min = Math.min(lcm / a.n, lcm / b.n);
			var g = Math.gcd(lcm, min);
			return radicandsGCD._pow(min / g)._nthRoot(lcm / g);
		}
		return null;
	};

	var gcd = function (a, b, v) {
		if (v == undefined) {

			if (getTerm(a) instanceof Expression.NthRoot && getTerm(b) instanceof Expression.NthRoot) {
				return gcd(getConstant(a), getConstant(b)).multiply(gcd(a.divide(getConstant(a)), b.divide(getConstant(b))));
			}

			return complexGCD(getConstant(a, true), getConstant(b, true));
		}

		var r = getReplacement(a, getReplacement(b, v));

		var r = getReplacement(a, getReplacement(b, v, "any"), "any");
		if (r instanceof Replacement) {
			var a1 = r.apply(a);
			var b1 = r.apply(b);
			var a2 = null;
			var b2 = null;
			var c2 = null;
			if (!a1.getDenominator().equals(Expression.ONE)) {
				if (!(a1.getDenominator() instanceof Expression.Integer)) {

					a2 = a1.getDenominator();
				}
				a1 = a1.getNumerator();
			}
			if (!b1.getDenominator().equals(Expression.ONE)) {
				if (!(b1.getDenominator() instanceof Expression.Integer)) {

					b2 = b1.getDenominator();
				}
				b1 = b1.getNumerator();
			}
			if (a2 != null && b2 != null && a2.equals(b2)) {
				c2 = a2;
				a2 = null;
				b2 = null;
			}
			if (a2 != null || b2 != null) {
				throw new TypeError();
			}

			var c = gcd(a1, b1, v);
			if (c2 != null) {
				c = c.divide(c2);
			}
			var c1 = r.undo(c);
			if (getTerm(c1) == null) {
				return c1;
			}
			c1 = getTerm(c1);
			console.log('c1', c1.toString(), getTerm(c1));
			return c1;
		}
		if (!r.equals(v)) {
			return substitute(substitute(a, v, r, inverseReplacement(r, v)).gcd(substitute(b, v, r, inverseReplacement(r, v))), v, inverseReplacement(r, v), r);
		}

		return Polynomial.polynomialGCD(Polynomial.toPolynomial(a, v), Polynomial.toPolynomial(b, v)).calcAt(v);
	};

	var getConjugateFactor = function (e) {
		var r = -1 / 0;
		for (var iteratorx = e.summands()[globalThis.Symbol.iterator](), x = iteratorx.next().value; x != null; x = iteratorx.next().value) {
			for (var iteratory = x.factors()[globalThis.Symbol.iterator](), y = iteratory.next().value; y != null; y = iteratory.next().value) {
				if (y instanceof NthRoot) {
					var degree = y.degree;
					if (r < degree) {
						r = degree;
					}
					if (!(y.a instanceof Integer)) {
						r = 1 / 0;
					}
				}
			}
		}
		var p = undefined;
		for (var iteratorx = e.summands()[globalThis.Symbol.iterator](), x = iteratorx.next().value; x != null; x = iteratorx.next().value) {
			for (var iteratory = x.factors()[globalThis.Symbol.iterator](), y = iteratory.next().value; y != null; y = iteratory.next().value) {
				if (y instanceof NthRoot) {
					var degree = y.degree;
					var i = y.a instanceof Integer ? y.a : null;
					if (i == null) {
						i = QuadraticInteger.toQuadraticInteger(y.a);
						if (i != null && p == undefined) {
							var pf = i.primeFactor();
							while (pf.toExpression() instanceof Expression.SquareRoot) {
								i = i.truncatingDivide(pf);
								pf = i.primeFactor();
							}
							i = pf;
						}
					}
					if (i == null) {
						throw new TypeError();
					}
					if (r === 1 / 0 && !(y.a instanceof Integer)) {
						r = degree;
					}
					if (r % degree === 0) {
						if (p == undefined) {
							p = i;
						}

						if (i != null) {
							var z = integerGCD(p, i);
							if (!z.isUnit()) {
								p = z;
							}
							if (z.isUnit() && !(z instanceof Integer) && (p.isUnit() || i.isUnit())) {
								p = z;
							}
						} else {
							throw new TypeError();
						}
					}
				}
			}
		}

		if (p != undefined) {
			if (p instanceof Integer) {
				p = p.primeFactor();
			}
		}

		return {
			p: p,
			degree: r
		};
	};

	var getConjugate = function (a) {
		var e = undefined;
		e = Expression.getComplexNumberParts(a);
		if (e != undefined && !e.imaginary.equals(Expression.ZERO)) {
			return e.real.subtract(e.imaginary.multiply(Expression.I));
		}
		e = Expression.getNthRootConjugate(a);
		if (e != undefined) {
			if (e.equals(a) && a instanceof Addition) {
				throw new TypeError();
			}
			return e;
		}
		return undefined;
	};

	Expression.getConjugate = getConjugate;

	Expression.getConjugateExpression = function (e) {
		try {
			var c = Expression.getConjugate(e);
			if (c != null) {
				return Expression.getConjugateExpression(c.multiply(e));
			}
			return e;
		} catch (error) {

			console.error(error);
		}
		return null;
	};

	var getPolynomialRelativeToNthRoot = function (e, p, r) {

		var polynomial = Polynomial.of();
		for (var iteratorx = e.summands()[globalThis.Symbol.iterator](), x = iteratorx.next().value; x != null; x = iteratorx.next().value) {
			var degree = 0;
			var coefficient = Expression.ONE;
			for (var iteratory = x.factors()[globalThis.Symbol.iterator](), y = iteratory.next().value; y != null; y = iteratory.next().value) {
				if (y instanceof NthRoot && (r === y.degree || r % y.degree === 0 && p instanceof Integer)) {
					var i = y.a instanceof Integer ? y.a : null;
					if (i == null) {
						i = QuadraticInteger.toQuadraticInteger(y.a);
					}
					if (i != null) {
						var j = 0;
						var a = i;
						if (p.isUnit()) {
							if (a.isUnit()) {
								j = 1;
								a = a.truncatingDivide(p);

								while (a.primeFactor().equals(p)) {
									j += 1;
									a = a.truncatingDivide(p);
								}
							} else {
								if (!(a instanceof Integer)) {

									var tmp = a.truncatingDivide(p);
									if (!(tmp instanceof Expression.Integer)) {
										if (Number.isNaN(Number(tmp.a.toString()) * Number(tmp.b.toString()))) {
											throw new TypeError();
										}
									}
									if (tmp instanceof Expression.Integer || Number(tmp.a.toString()) * Number(tmp.b.toString()) >= 0) {
										j = 1;
										a = tmp;
									}
								}
							}
						} else {

							while (a.isDivisibleBy(p) && j < y.degree) {
								a = a.truncatingDivide(p);
								j += 1;
							}
						}
						a = a.toExpression();
						coefficient = coefficient.multiply(a._nthRoot(y.degree));
						degree += j * (r / y.degree);
					} else {
						throw new TypeError();
					}
				} else {
					coefficient = coefficient.multiply(y);
				}
			}

			polynomial = polynomial.add(Polynomial.of(coefficient).shift(degree));
		}
		return polynomial;
	};

	Expression.getNthRootConjugate = function (e) {
		var expression = e;
		if (e instanceof Integer) {

			return null;
		}
		if (e instanceof NthRoot) {

			return e._pow(e.n - 1);
		}
		if (e instanceof Multiplication && e.a instanceof Integer) {

			return Expression.getNthRootConjugate(e.b);
		}

		if (e instanceof Addition && e.a instanceof Multiplication && e.a.a instanceof Integer && e.a.b instanceof NthRoot && e.a.b.n === 3 && e.b instanceof Multiplication && e.b.a instanceof Integer && e.b.b instanceof NthRoot && e.b.b.n === 3) {

			return e.a._pow(2).subtract(e.a.multiply(e.b)).add(e.b._pow(2));
		}

		var tmp = getConjugateFactor(e);
		var p = tmp.p;
		var r = tmp.degree;
		if (p == undefined) {
			return undefined;
		}
		var polynomial = getPolynomialRelativeToNthRoot(e, p, r);
		polynomial = polynomial.divideAndRemainder(Polynomial.of(polynomial.getContent()), "throw").quotient;
		var x = p.toExpression();
		var mod = Polynomial.of(Expression.ONE).shift(r).subtract(Polynomial.of(x));
		var conjugate2 = polynomial.modularInverse(mod).primitivePart();
		return conjugate2.calcAt(x._nthRoot(r));
	};

	Expression.collectLinearEquationVariables = function (e) {
		if (e instanceof Division) {
			throw new RangeError();
		}
		var list = [];
		for (var iteratorx = e.summands()[globalThis.Symbol.iterator](), x = iteratorx.next().value; x != null; x = iteratorx.next().value) {
			var v = undefined;
			var c = Expression.ONE;
			var NO_VARIABLE = "";
			for (var iteratory = x.factors()[globalThis.Symbol.iterator](), y = iteratory.next().value; y != null; y = iteratory.next().value) {
				if (y instanceof Expression.Symbol && v == undefined) {
					v = y;
				} else {
					if (!(y instanceof Integer) && !(y instanceof NthRoot)) {
						if (v == undefined) {
							v = NO_VARIABLE;
						}
					}
					c = c.multiply(y);
				}
			}
			if (v == undefined) {
				v = NO_VARIABLE;
			}
			var variable = v === NO_VARIABLE ? "" : v.toString();
			list.push({
				c: c,
				v: variable
			});
		}
		return list;
	};

	var has = function (e, Class) {
		if (e instanceof Class) {
			return true;
		}
		if (e instanceof BinaryOperation) {
			if (e instanceof Addition) {
				while (e instanceof Addition) {
					if (has(e.b, Class)) {
						return true;
					}
					e = e.a;
				}
				return has(e, Class);
			}
			if (has(e.b, Class)) {
				return true;
			}
			return has(e.a, Class);
		}
		if (e instanceof Negation) {
			return has(e.b, Class);
		}

		if (e instanceof Expression.Function) {
			return has(e.a, Class);
		}
		return false;
	};
	Expression.has = has;

	var has2 = function (e, Class) {
		do {
			var e1 = null;
			if (e instanceof Addition) {
				e1 = e.b;
				e = e.a;
			} else {
				e1 = e;
				e = null;
			}
			do {
				var e2 = null;
				if (e1 instanceof Multiplication) {
					e2 = e1.b;
					e1 = e1.a;
				} else {
					e2 = e1;
					e1 = null;
				}
				if (e2 instanceof Class) {
					return true;
				}
			} while (e1 != null);
		} while (e != null);
		return false;
	};

	var inverseReplacement = function (e, v) {
		var t = v;
		while (!e.equals(v)) {
			if (e instanceof Expression.Exponentiation && e.b instanceof Multiplication && v instanceof Exponentiation) {
				t = t.pow(e.b.a.inverse());
				e = e.pow(e.b.a.inverse());
			} else if (e instanceof Expression.Exponentiation) {
				t = t.pow(getExponent(e).inverse());
				e = getBase(e);
			} else if (e instanceof Addition) {
				if (!(e.b instanceof Integer)) {
					throw new RangeError();
				}
				t = t.subtract(e.b);
				e = e.a;
			} else if (e instanceof Multiplication) {
				if (!(e.a instanceof Integer)) {
					throw new RangeError();
				}
				t = t.divide(e.a);
				e = e.b;
			} else if (e instanceof Division) {
				if (!(e.b instanceof Integer)) {
					throw new RangeError();
				}
				t = t.multiply(e.b);
				e = e.a;
			} else {
				if ((Expression.E === e) || (e instanceof Integer && e.compareTo(Expression.ONE) > 0) && getBase(v).equals(e)) {
					t = t.pow(getExponent(v));
					e = v;
				} else {
					throw new TypeError();
				}
			}
		}
		return t;
	};

	var h = function (e, n, q) {
		for (var iteratorx = e.summands()[globalThis.Symbol.iterator](), x = iteratorx.next().value; x != null; x = iteratorx.next().value) {
			for (var iteratory = x.factors()[globalThis.Symbol.iterator](), y = iteratory.next().value; y != null; y = iteratory.next().value) {
				if (getBase(q).equals(getBase(y))) {
					n = n.lcm(getExponent(y).getDenominator());
				}
			}
		}
		return n;
	};

	Replacement._counter = 0;

	function Replacement(from) {
		this.from = getBase(from);
		this.to = new Expression.Symbol("$t" + (++Replacement._counter)).pow(getExponent(from).getDenominator());
	}

	Replacement.prototype.apply = function (e) {
		var from = this.from;
		var to = this.to;
		var variable = getVariable(from, {preferFunctions: true});
		var p1 = Polynomial.toPolynomial(from.subtract(to), variable);

		return Expression._map(function (x) {
			if (!Expression.has(x, Expression.Division)) {
				var p2 = Polynomial.toPolynomial(x, variable);
				return p2.divideAndRemainder(p1).remainder.calcAt(variable);
			}
			return x;
		}, e);
	};
	Replacement.prototype.undo1 = function (e) {
		var from = this.from;
		var to = this.to;
		var variable = getBase(this.to);
		var p1 = Polynomial.toPolynomial(from.subtract(to), variable);
		return Polynomial.toPolynomial(e, variable).divideAndRemainder(p1).remainder.calcAt(variable);
	};
	Replacement.prototype.undo = function (e) {
		var variable = getBase(this.to);
		var r = this.from.pow(getExponent(this.to).inverse());
		return Expression._map(function (x) {
			if (x.equals(variable)) {
				return r;
			}
			return x;
		}, e);
	};
	Replacement.prototype.equals = function () {
		return true;
	};

	var getReplacement = function (e, v, originalVariable) {
		if (v instanceof Replacement) {
			return v;
		}
		for (var iteratorx = e.summands()[globalThis.Symbol.iterator](), x = iteratorx.next().value; x != null; x = iteratorx.next().value) {
			for (var iteratory = x.factors()[globalThis.Symbol.iterator](), y = iteratory.next().value; y != null; y = iteratory.next().value) {
				if (y instanceof Expression.Exponentiation && (Expression.has(y.a, Expression.Symbol) || y.a instanceof Integer && y.a.compareTo(Expression.ONE) > 0) && y.b instanceof Expression.Division) {
					if (getBase(v).equals(y.a)) {

						v = new Expression.Exponentiation(y.a, getConstant(y.b.b).lcm(getExponent(v).getNumerator()).divide(getExponent(v).getDenominator()));
					} else if (getBase(v) instanceof Expression.Symbol) {
						if ((y.a instanceof Expression.Addition && y.a.a.divide(getBase(v)) instanceof Integer && y.a.b instanceof Integer) && (y.b instanceof Division && y.b.a instanceof Integer && y.b.b instanceof Integer)) {
							var n = y.b.getDenominator();
							n = h(e, n, y);

							var t = getBase(v).pow(n).subtract(y.a.b).divide(y.a.a.divide(getBase(v)));
							return t;
						} else {

							if (originalVariable === "any" || originalVariable != null && originalVariable.equals(y.a)) {
								return new Replacement(y);
							}
						}
					}
				}
			}
		}
		return v;
	};

	Expression._getReplacement = getReplacement;

	var substitute = function (e, a, b, inv) {
		if (e.equals(a)) {
			return b;
		}
		if (e instanceof Expression.Exponentiation) {
			if (e.equals(inv)) {
				return a;
			}
			if (getBase(e).equals(getBase(inv))) {
				return a.pow(getExponent(e).divide(getExponent(inv)));

			}
		}

		if (e instanceof Expression.Addition) {
			return substitute(e.a, a, b, inv).add(substitute(e.b, a, b, inv));
		}
		if (e instanceof Expression.Multiplication) {
			return substitute(e.a, a, b, inv).multiply(substitute(e.b, a, b, inv));
		}
		if (e instanceof Expression.Exponentiation) {
			var x = substitute(e.a, a, b, inv);
			var y = substitute(e.b, a, b, inv);

			if (x instanceof Expression.Exponentiation && getBase(x).equals(getBase(inv)) && getExponent(inv).getDenominator().remainder(Expression.TWO).equals(Expression.ZERO)) {

				return getBase(x).pow(getExponent(x).multiply(y));
			}
			return x.pow(y);
		}

		if (e instanceof Division) {
			return substitute(e.a, a, b, inv).divide(substitute(e.b, a, b, inv));
		}
		if (e instanceof Expression.Sin) {
			return substitute(e.a, a, b, inv).sin();
		}
		if (e instanceof Expression.Cos) {
			return substitute(e.a, a, b, inv).cos();
		}
		return e;
	};

	Expression._substitute = substitute;

	Expression.prototype.divideExpression = function (x) {
		var y = this;

		if (simplifyIdentityMatrixPower) {
			if (x instanceof Multiplication && x.b instanceof IdentityMatrix) {
				return x.b.equals(y) ? x.a : x.a.divide(y).multiply(x.b);
			} else if (x instanceof IdentityMatrix) {
				return Expression.ONE.divide(y).multiply(x);
			}
			if (y instanceof Multiplication && y.b instanceof IdentityMatrix) {
				return x.divide(y.a).multiply(y.b);
			} else if (y instanceof IdentityMatrix) {
				return x.multiply(y);
			}
		}

		if (has(y, MatrixSymbol)) {

			var tmp = getBase(y) instanceof MatrixSymbol ? y.pow(Expression.ONE.negate()) : new Expression.Exponentiation(y, Expression.ONE.negate());
			if (x.equals(Expression.ONE)) {
				if (y instanceof Multiplication) {

					if (Expression.callback != undefined) {
						Expression.callback(new Expression.Event("property-inverse-of-multiplication", {matrix: "{{0}}"}));
					}
					return x.multiply(Expression.ONE.divide(y.b).multiply(Expression.ONE.divide(y.a)));
				}
				if (y instanceof Addition && !has(y, Expression.Matrix)) {
					var f = Expression.simpleDivisor(y);
					if (f != null && !f.equals(Expression.ONE) && isScalar(f) && !gcd(f, y).equals(Expression.ONE)) {
						return x.multiply(Expression.ONE.divide(f).multiply(Expression.ONE.divide(y.divide(f))));
					}
				}
				return tmp;
			}

		}

		if (x instanceof Expression.Matrix && y instanceof Expression.Matrix) {

			return new Expression.Matrix(x.matrix.multiply(y.matrix.inverse()));
		}
		if (x instanceof Expression.Matrix && y instanceof Expression) {

			return x.multiply(y.inverse());
		}
		if (x instanceof Expression && y instanceof Expression.Matrix) {
			if (Expression.callback != undefined) {
				Expression.callback(new Expression.Event(y.matrix.getDeterminantEventType("inverse").type, y));
			}

			return new Expression.Matrix(y.matrix.inverse()).multiply(x);
		}

		if (y.equals(Expression.ZERO)) {

			throw new TypeError("ArithmeticException");
		}
		if (x.equals(Expression.ZERO)) {
			return Expression.ZERO;
		}
		if (y.equals(Expression.ONE)) {
			return x;
		}

		var term = getTerm(y);
		if ((term instanceof Expression.Exponentiation || term === Expression.E) && getBase(term) === Expression.E && (getExponent(term) instanceof Expression.ExpressionPolynomialRoot || getExponent(term) instanceof Expression.Integer)) {

			if (getTerm(x) instanceof Expression.Exponentiation && getExponent(getTerm(x)) instanceof Expression.ExpressionPolynomialRoot) {
				if ((x instanceof Expression.Exponentiation || x instanceof Expression.Multiplication) && (y instanceof Expression.Exponentiation || y instanceof Expression.Multiplication || y === Expression.E)) {
					return getExponent(getTerm(x)).subtract(getExponent(getTerm(y))).exp().multiply(getConstant(x).divide(getConstant(y)));
				}
			}
			if (getTerm(x, true) === Expression.E) {
				if ((x === Expression.E || x instanceof Expression.Exponentiation || x instanceof Expression.Multiplication) && (y instanceof Expression.Exponentiation || y instanceof Expression.Multiplication)) {
					return getExponent(getTerm(x, true)).subtract(getExponent(getTerm(y))).exp().multiply(getConstant(x, true).divide(getConstant(y)));
				}
			}
			if (getExponent(getTerm(y)).isNegative()) {
				return x.multiply(term.inverse()).divide(y.divide(term));
			}

		}

		if (true) {
			var e = getConjugate(y);
			if (e != undefined) {
				if (e.equals(Expression.ONE)) {

					if (Expression.isConstant(y)) {
						return x.multiply(Expression._map(function (x) {
							return x instanceof NthRoot ? Expression.toPolynomialRoot(x) : x;
						}, y).inverse());
					}

					throw new TypeError();
				}

				if (e instanceof Expression.Multiplication && e.a instanceof Expression.Complex) {
					e = e.a;
				}
				return x.multiply(e).divide(y.multiply(e));
			}
		}

		if (Expression.has(x, Expression.Complex)) {
			var tmp = Expression.getComplexNumberParts(x);
			if (tmp != undefined && !tmp.imaginary.equals(Expression.ZERO)) {
				var a = tmp.real;
				var b = tmp.imaginary;
				var g = (a.equals(Expression.ZERO) ? y : a.gcd(y)).gcd(b)._abs();
				if (!g.equals(Expression.ONE)) {
					x = a.divide(g).add(b.divide(g).multiply(Expression.I));
					y = y.divide(g);
				}
				if (y.isNegative()) {
					x = x.negate();
					y = y.negate();
				}
				if (y instanceof Expression.Integer && (a instanceof Expression.ExpressionPolynomialRoot && b instanceof Expression.ExpressionPolynomialRoot)) {
					return a.divide(y.multiply(g)).add(b.divide(y.multiply(g)).multiply(Expression.I));
				}
				return y.equals(Expression.ONE) ? x : new Division(x, y);
			}
		}

		if (!getConstant(y).equals(y) && x.divide(getConstant(x)).equals(y.divide(getConstant(y)))) {
			return getConstant(x).divide(getConstant(y));
		}

		var v = y instanceof Integer ? undefined : getVariable(x);

		if (has(v, MatrixSymbol) && isScalar(y)) {
			v = getVariable(y);
		}

		if (v != null) {
			var originalVariable = v;
			v = getVariable(v);
			var r = getReplacement(y, getReplacement(x, v, originalVariable), "any");
			if (r instanceof Replacement) {

				var a = r.apply(x);
				var b = r.apply(y);
				var c = a.divide(b);
				var n = r.undo1(c.getNumerator());
				var d = r.undo1(c.getDenominator());

				var g = n.gcd(d);
				if (!g.equals(Expression.ONE)) {
					n = n.divide(g);
					d = d.divide(g);
				}
				n = r.undo(n);
				d = r.undo(d);
				return d.equals(Expression.ONE) ? n : new Expression.Division(n, d);
			}
			if (!r.equals(v)) {
				var ir = inverseReplacement(r, v);
				var a = substitute(x, v, r, ir);
				var b = substitute(y, v, r, ir);

				var t = a.divide(b);
				a = substitute(t.getNumerator(), v, ir, r);
				b = substitute(t.getDenominator(), v, ir, r);
				return b.equals(Expression.ONE) ? a : new Expression.Division(a, b);
			}
		}

		var px = undefined;
		var py = undefined;
		if (v != undefined) {
			px = Polynomial.toPolynomial(x, v);
			py = Polynomial.toPolynomial(y, v);
			if (px.getDegree() === 0 && py.getDegree() === 0) {
				v = undefined;
			}
		}
		if (v == undefined) {
			var cx = getConstant(x, true);
			var cy = getConstant(y, true);
			if (cx instanceof Expression.ExpressionPolynomialRoot && !cy.equals(Expression.ONE)) {

				return cx.divide(cy).multiply(getTerm(x, true)).divide(getTerm(y, true) || Expression.ONE);
			}
			var g = complexGCD(cx, cy);
			if (!g.equals(Expression.ONE)) {
				x = divideByInteger(x, g);
				y = divideByInteger(y, g);
				return x.divide(y);
			}
		} else {

			var t = px.divideAndRemainder(py, "undefined");
			if (t != undefined && t.remainder.equals(Polynomial.ZERO)) {
				return t.quotient.calcAt(v);
			}

			var g = Polynomial.polynomialGCD(px, py);
			if (g.getDegree() !== 0 || !g.getLeadingCoefficient().equals(Expression.ONE)) {
				var x2 = px.divideAndRemainder(g, "throw").quotient;
				var y2 = py.divideAndRemainder(g, "throw").quotient;
				return x2.calcAt(v).divide(y2.calcAt(v));
			}
		}

		var lc = getConstant(getFirstAdditionOperand(y));
		if (lc.compareTo(Expression.ZERO) < 0) {
			return x.negate().divide(y.negate());
		}
		if (has(y, MatrixSymbol)) {
			return new Expression.Multiplication(x, new Expression.Exponentiation(y, Expression.ONE.negate()));
		}
		return new Division(x, y);
	};

	function Expression() {
		throw new TypeError("Do not call for better performance");
	}

	Expression.callback = undefined;
	Expression.Event = function (type, data, second) {
		console.warn(type)
		second = second == undefined ? undefined : second;
		this.type = type;
		this.data = data;
		this.second = second;
	};

	Expression.prototype.compare4Multiplication = function (y) {
		throw new TypeError(this.toString());
	};
	Expression.prototype.compare4MultiplicationInteger = function (x) {
		throw new TypeError();
	};
	Expression.prototype.compare4MultiplicationSymbol = function (x) {
		throw new TypeError();
	};
	Expression.prototype.compare4MultiplicationNthRoot = function (x) {
		throw new TypeError();
	};

	Expression.prototype.negate = function () {
		return Expression.ONE.negate().multiply(this);
	};
	Expression.prototype.add = function (y) {
		return y.addExpression(this);
	};
	Expression.prototype.subtract = function (y) {
		return this.add(y.negate());
	};
	Expression.prototype.divide = function (y) {

		if (!(y instanceof Expression.Matrix)) {
			if (this.equals(y)) {

				return Expression.ONE;
			}
			if (this.equals(y.negate())) {
				return Expression.ONE.negate();
			}
		}
		return y.divideExpression(this);
	};
	Expression.prototype.multiply = function (y) {
		return y.multiplyExpression(this);
	};
	Expression.prototype.pow = function (y) {
		return y.powExpression(this);
	};
	Expression.prototype.getDenominator = function () {

		return this instanceof Division ? this.b : Expression.ONE;
	};
	Expression.prototype.getNumerator = function () {

		return this instanceof Division ? this.a : this;
	};
	Expression.prototype.inverse = function () {
		return Expression.ONE.divide(this);
	};
	Expression.prototype.exp = function () {
		return Expression.E.pow(this);
	};

	var variables = function (e) {
		var result = [];
		for (var iteratorx = e.summands()[globalThis.Symbol.iterator](), x = iteratorx.next().value; x != null; x = iteratorx.next().value) {
			for (var iteratory = x.factors()[globalThis.Symbol.iterator](), y = iteratory.next().value; y != null; y = iteratory.next().value) {
				for (var iteratorve = getVariableInternal(y)[globalThis.Symbol.iterator](), ve = iteratorve.next().value; ve != null; ve = iteratorve.next().value) {
					if (!(ve.v instanceof Integer)) {
						result.push(ve.v);
					}
				}
			}
		}
		return result;
	};

	var getCommonVariable = function (x, y) {
		var a = variables(x);
		var b = variables(y);
		for (var i = 0; i < a.length; i += 1) {
			if (a[i] instanceof NthRoot) {
				return a[i];
			}
		}
		for (var i = 0; i < b.length; i += 1) {
			if (b[i] instanceof NthRoot) {
				return b[i];
			}
		}
		for (var i = 0; i < a.length; i += 1) {
			if (a[i] instanceof Addition) {

				a = a.concat(variables(a[i]));
				a[i] = null;
			}
		}
		for (var i = 0; i < b.length; i += 1) {
			if (b[i] instanceof Addition) {

				b = b.concat(variables(b[i]));
				b[i] = null;
			}
		}
		for (var i = 0; i < a.length; i += 1) {
			for (var j = 0; j < b.length; j += 1) {
				if (a[i] != null && b[j] != null) {
					if (a[i].equals(b[j])) {
						return a[i];
					}
				}
			}
		}
		return null;
	};

	Expression.prototype.gcd = function (x) {
		if (this.equals(Expression.ONE)) {
			return this;
		}

		if (this instanceof Integer && x instanceof Integer) {
			return integerGCD(this, x);
		}
		if (!(this instanceof Integer) && !(x instanceof Integer)) {

			var t1 = getTerm(this);
			var t2 = getTerm(x);
			if (t1 != null && t2 != null && t1.equals(t2)) {
				return getConstant(this).gcd(getConstant(x)).multiply(t2);
			}

			t1 = getTerm(getFirstAdditionOperand(this));
			t2 = getTerm(getFirstAdditionOperand(x));
			if (t1 != null && t2 != null && t1.equals(t2)) {
				var c1 = getConstant(getFirstAdditionOperand(this));
				var c2 = getConstant(getFirstAdditionOperand(x));
				if (c1 instanceof Integer && c2 instanceof Integer) {
					var alpha = c1.truncatingDivide(c2);
					if (alpha instanceof Expression.Integer && alpha.multiply(c2).equals(c1)) {
						return this.subtract(x.multiply(alpha)).gcd(x);
					}
					var alpha = c2.truncatingDivide(c1);
					if (alpha instanceof Expression.Integer && alpha.multiply(c1).equals(c2)) {
						return this.gcd(x.subtract(this.multiply(alpha)));
					}
				}
			}
		}
		if (this.equals(Expression.ZERO) || x.equals(Expression.ZERO)) {
			return this.add(x);
		}

		var result = gcd(this, x, getCommonVariable(this, x));
		return result;
	};

	Expression.prototype.lcm = function (x) {
		if (x.equals(Expression.ONE)) {
			return this;
		}
		if (this.equals(x)) {
			return this;
		}
		return this.divide(this.gcd(x)).multiply(x);
	};

	Expression.prototype.polynomialGCD = function (b) {
		var a = this;

		var v = getVariableInternal(getLastMultiplicationOperand(getFirstAdditionOperand(a))).next().value.v;
		if (v instanceof Expression.Symbol) {
			var r = getReplacement(a, getReplacement(b, v));
			if (!r.equals(v)) {
				return substitute(substitute(a, v, r, inverseReplacement(r, v)).polynomialGCD(substitute(b, v, r, inverseReplacement(r, v))), v, inverseReplacement(r, v), r);
			}

			return Polynomial.polynomialGCD(Polynomial.toPolynomial(a, v), Polynomial.toPolynomial(b, v)).calcAt(v);
		}
		return a.gcd(b);
	};

	var precedence = {
		binary: {
			".^": 5,
			"^": 5,
			"*": 3,
			"/": 3,
			"+": 2,
			"-": 2
		},
		unary: {
			"-": 5
		}
	};

	var Symbol = null;

	Expression.Symbol = function (symbol) {

		this.symbol = symbol;
	};

	Expression.Symbol.prototype = Object.create(Expression.prototype);

	Expression.Symbol.prototype.compare4Multiplication = function (y) {
		return y.compare4MultiplicationSymbol(this);
	};
	Expression.Symbol.prototype.compare4MultiplicationInteger = function (x) {
		return -1;
	};
	Expression.Symbol.prototype.compare4MultiplicationSymbol = function (x) {
		return x.symbol < this.symbol ? -1 : (this.symbol < x.symbol ? +1 : 0);
	};
	Expression.Symbol.prototype.compare4MultiplicationNthRoot = function (x) {
		return -1;
	};

	Expression.Symbol.prototype.toString = function (options) {
		if (this.symbol === '\u2147') {
			return 'e';
		}
		return this.symbol;
	};

	Expression.Symbol.prototype._pow = function (count) {
		if (count > 1) {
			return new Expression.Exponentiation(this, Expression.Integer.fromNumber(count));
		}
		return Expression.prototype._pow.call(this, count);
	};

	Expression.prototype.addInteger = function (x) {
		return this.addExpression(x);
	};
	Expression.prototype.multiplyInteger = function (x) {
		if (x === Expression.ONE) {
			return this;
		}
		return this.multiplyExpression(x);
	};
	Expression.prototype.divideInteger = function (x) {
		return this.divideExpression(x);
	};

	var simplifyIdentityMatrixPower = true;

	function Integer(value) {

		this.value = value;
	}

	Integer.prototype = Object.create(Expression.prototype);

	Integer.prototype.powExpression = function (x) {
		var y = this;
		if (x instanceof IdentityMatrix) {
			if (simplifyIdentityMatrixPower) {
				return new IdentityMatrix(x.symbol);
			}
		}
		if (x instanceof MatrixSymbol) {
			if (y.equals(Expression.ZERO)) {
				return Expression.ONE;
			}
			if (y.equals(Expression.ONE)) {
				return x;
			}
			return new Exponentiation(x, y);
		}

		if (x instanceof Exponentiation && getExponent(x) instanceof Integer && y instanceof Integer) {
			return getBase(x).pow(getExponent(x).multiply(y));
		}

		if (x instanceof Exponentiation && getTerm(getExponent(x)) instanceof Expression.Symbol) {
			return getBase(x).pow(getExponent(x).multiply(y));
		}

		if (y.compareTo(Expression.ZERO) < 0) {
			return Expression.ONE.divide(x.pow(y.negate()));
		}
		if (x instanceof Expression.Matrix) {
			if (y.compareTo(Expression.ONE) > 0) {
				if (!x.matrix.isDiagonal()) {
					if (Expression.callback != undefined) {
						Expression.callback(new Expression.Event("pow", x, new Expression.Matrix(Matrix.I(1).map(function () {
							return y;
						}))));
					}
				}
			}
			var powMatrix = function (matrix, n) {
				if (n.toNumber() > Number.MAX_SAFE_INTEGER) {
					return powMatrix(matrix, n.truncatingDivide(Expression.TWO)).pow(2).multiply(matrix.pow(n.remainder(Expression.TWO).toNumber()));
				}
				return matrix.pow(n.toNumber());
			};
			return new Expression.Matrix(powMatrix(x.matrix, y));
		}
		if (y.equals(Expression.ZERO)) {
			return Expression.ONE;
		}
		if (y.equals(Expression.ONE)) {
			return x;
		}

		if (x instanceof Expression.Symbol) {
			return new Exponentiation(x, y);
		}
		if (x instanceof Exponentiation) {
			var t = x.b.multiply(y);
			if (t.getNumerator() instanceof Integer && t.getDenominator() instanceof Integer) {
				var i = t.getNumerator().truncatingDivide(t.getDenominator());
				if (i.compareTo(Expression.ZERO) > 0) {
					return x.a.pow(i).multiply(x.a.pow(t.subtract(i)));
				}
			}
			return x.a.pow(x.b.multiply(y));
		}
		if (x instanceof Integer && (x.compareTo(Expression.ZERO) === 0 || x.compareTo(Expression.ONE) === 0 || x.compareTo(Expression.ONE.negate()) === 0)) {
			return y.remainder(Expression.TWO).compareTo(Expression.ZERO) === 0 ? x.multiply(x) : x;
		}
		if (x.equals(Expression.I)) {
			y = y.remainder(Expression.TWO.add(Expression.TWO));
			return Expression.pow(x, y.toNumber());
		}

		return Expression.pow(x, y.toNumber());
	};

	Integer.prototype.compare4Multiplication = function (y) {
		return y.compare4MultiplicationInteger(this);
	};
	Integer.prototype.compare4MultiplicationInteger = function (x) {
		return x.compareTo(this);

	};
	Integer.prototype.compare4MultiplicationSymbol = function (x) {
		return +1;
	};
	Integer.prototype.compare4MultiplicationNthRoot = function (x) {
		return +1;
	};

	Integer.prototype.negate = function () {
		return new Integer(SmallBigInt.unaryMinus(this.value));
	};
	Integer.prototype.isUnit = function () {
		return this.equals(Expression.ONE) || this.equals(Expression.ONE.negate());
	};
	Expression.prototype.toExpression = function () {
		return this;
	};
	Integer.prototype.compareTo = function (y) {
		if (y instanceof Expression.Integer) {
			var b = y.value;
			var a = this.value;
			return SmallBigInt.lessThan(a, b) ? -1 : (SmallBigInt.lessThan(b, a) ? +1 : 0);
		}
		return Expression.prototype.compareTo.call(this, y);
	};
	Integer.prototype.abs = function () {
		return SmallBigInt.toNumber(this.value) < 0 ? this.negate() : this;
	};
	Integer.prototype.sign = function () {
		return Math.sign(SmallBigInt.toNumber(this.value));
	};
	Integer.prototype.add = function (y) {
		if (y instanceof Integer) {
			return new Integer(SmallBigInt.add(this.value, y.value));
		}
		return y.addInteger(this);
	};
	Integer.prototype.addInteger = function (x) {
		if (this === Expression.ZERO) {
			return y;
		}
		return new Integer(SmallBigInt.add(x.value, this.value));
	};
	Integer.prototype.multiply = function (y) {
		if (y instanceof Integer) {
			return new Integer(SmallBigInt.multiply(this.value, y.value));
		}
		return y.multiplyInteger(this);
	};
	Integer.prototype.multiplyInteger = function (x) {
		if (x === Expression.ONE) {
			return this;
		}
		return new Integer(SmallBigInt.multiply(x.value, this.value));
	};
	Integer.prototype.divide = function (y) {
		return y.divideInteger(this);
	};

	Integer.prototype.divideInteger = function (x) {
		var y = this;
		var a = x.value;
		var b = y.value;

		if (SmallBigInt.toNumber(b) === 0) {

			throw new TypeError("ArithmeticException");
		}
		if (typeof b === "number" && b === 1) {
			return x;
		}
		var q = SmallBigInt.divide(a, b);
		var r = SmallBigInt.subtract(a, SmallBigInt.multiply(q, b));
		if (SmallBigInt.toNumber(r) === 0) {
			return new Integer(q);
		}
		var g = SmallBigInt.BigInt(bigIntGCDWrapper(r, b));

		a = SmallBigInt.divide(a, g);
		b = SmallBigInt.divide(b, g);

		if (SmallBigInt.toNumber(b) < 0) {
			a = SmallBigInt.unaryMinus(a);
			b = SmallBigInt.unaryMinus(b);
		}
		return new Division(new Integer(a), new Integer(b));
	};
	Integer.prototype.truncatingDivide = function (y) {
		if (y.equals(Expression.ONE)) {
			return this;
		}
		return y.truncatingDivideInteger(this);
	};

	function roundDivision(a, b) {
		if (b.compareTo(Expression.ZERO) < 0) {
			b = b.negate();
			a = a.negate();
		}
		var e = b.truncatingDivide(Expression.TWO);
		if (a.compareTo(Expression.ONE) < 0) {
			e = e.negate();
		}
		return a.add(e).truncatingDivide(b);
	}

	Integer.prototype.roundDivision = function (b) {
		return roundDivision(this, b);
	};
	Integer.prototype.truncatingDivideInteger = function (x) {
		var y = this;
		return new Integer(SmallBigInt.divide(x.value, y.value));
	};
	Integer.prototype.isDivisibleBy = function (y) {
		return y.isDivisibleByInteger(this);
	};
	Integer.prototype.isDivisibleByInteger = function (x) {
		return x.remainder(this).equals(Expression.ZERO);
	};
	Integer.prototype.remainder = function (y) {
		if (y instanceof Integer) {
			var r = SmallBigInt.remainder(this.value, y.value);
			return r === 1 ? Expression.ONE : new Integer(r);
		}
		return y.remainderInteger(this);
	};
	Integer.prototype.remainderInteger = function (x) {
		var y = this;
		var r = SmallBigInt.remainder(x.value, y.value);
		return r === 1 ? Expression.ONE : new Integer(r);
	};
	Integer.prototype.primeFactor = function () {
		return integerPrimeFactor(this);
	};
	Integer.prototype.toNumber = function () {
		return SmallBigInt.toNumber(this.value);
	};
	Integer.prototype.toBigInt = function () {
		return this.value;
	};
	Integer.prototype.toString = function (options) {
		return this.value.toString();
	};
	Integer.prototype.valueOf = function () {
		console.error("!");

		return this;
	};
	Integer.prototype.leftShift = function (n) {
		return new Integer(SmallBigInt.leftShift(this.value, n));
	};
	Integer.prototype.asUintN = function (n) {
		return new Integer(SmallBigInt.asUintN(n, this.value));
	};

	Integer.fromNumber = function (n) {
		return new Integer(SmallBigInt.BigInt(n));
	};
	Integer.fromString = function (s) {
		return new Integer(SmallBigInt.BigInt(s));
	};
	Integer.fromBigInt = function (i) {
		return new Integer(SmallBigInt.BigInt(i));
	};

	Expression.ZERO = Integer.fromNumber(0);
	Expression.ONE = Integer.fromNumber(1);
	Expression.TWO = Integer.fromNumber(2);
	Expression.TEN = Integer.fromNumber(10);

	Expression.Matrix = function (matrix) {

		this.matrix = matrix;
	};

	Expression.Matrix.fromArray = function (rows) {
		return new Expression.Matrix(Matrix.padRows(rows, null));
	};

	Expression.Matrix.prototype = Object.create(Expression.prototype);

	Expression.Matrix.prototype.augment = function (other) {
		if (other instanceof Expression.IdentityMatrix) {
			return new Expression.Matrix(this.matrix.augment(Matrix.I(this.matrix.cols())));
		}
		return new Expression.Matrix(this.matrix.augment(other.matrix));
	};

	Expression.Matrix.prototype.equals = function (x) {

		if (x === Expression.ZERO) {
			return this.matrix.isSquare() && this.matrix.eql(this.matrix.map(function (e, i, j) {
				return Expression.ZERO;
			}));
		}

		if (!(x instanceof Expression.Matrix)) {
			return false;
		}
		return this.matrix.eql(x.matrix);
	};

	Expression.Matrix.prototype.compare4Multiplication = function (y) {
		if (y instanceof Expression.Matrix) {
			return 0;
		}
		if (y instanceof MatrixSymbol) {

			if (this.matrix.isSquare() && this.matrix.isDiagonal()) {
				var element = this.matrix.e(0, 0);
				if (this.matrix.eql(Matrix.Zero(this.matrix.rows(), this.matrix.cols()).map(function (e, i, j) {
					return i === j ? element : Expression.ZERO;
				}))) {
					return +1;
				}
			}
			return -1;
		}
		return +1;
	};
	Expression.Matrix.prototype.compare4MultiplicationNthRoot = function (x) {
		return +1;
	};

	Expression.Matrix.prototype.multiply = function (y) {
		return y.multiplyMatrix(this);
	};
	Expression.prototype.multiplyMatrix = function (x) {
		var t = getIdentityMatrixCoefficient(this);
		if (t != undefined) {
			return new Expression.Matrix(x.matrix.scale(t));
		}
		if (x.equals(Expression.ZERO)) {
			return x;
		}
		return this.multiplyExpression(x);
	};
	Expression.Matrix.prototype.multiplyExpression = function (x) {
		var t = getIdentityMatrixCoefficient(x);
		if (t != undefined) {
			return new Expression.Matrix(this.matrix.scale(t));
		}
		return Expression.prototype.multiplyExpression.call(this, x);
	};
	Expression.Matrix.prototype.multiplyMatrix = function (x) {
		if (Expression.callback != undefined) {
			Expression.callback(new Expression.Event("multiply", x, this));
		}
		return new Expression.Matrix(x.matrix.multiply(this.matrix));
	};
	Expression.Matrix.prototype.compare4MultiplicationSymbol = function (x) {
		return +1;
	};
	Expression.Matrix.prototype.multiplyDivision = Expression.Matrix.prototype.multiplyExpression;
	Expression.Matrix.prototype.add = function (y) {
		return y.addMatrix(this);
	};
	Expression.Matrix.prototype.addMatrix = function (x) {
		if (Expression.callback != undefined) {
			Expression.callback(new Expression.Event("add", x, this));
		}
		return new Expression.Matrix(x.matrix.add(this.matrix));
	};

	var isScalar = function (x) {
		if (x instanceof Integer) {
			return true;
		}
		if (x instanceof Expression.Complex) {
			return true;
		}
		if (x instanceof MatrixSymbol) {
			return false;
		}
		if (x instanceof Expression.ExpressionWithPolynomialRoot) {
			return isScalar(x.e);
		}
		if (x instanceof Expression.Symbol) {
			return true;
		}
		if (x instanceof BinaryOperation) {
			return isScalar(x.a) && isScalar(x.b);
		}
		if (x instanceof Negation) {
			return isScalar(x.b);
		}
		if (x instanceof Expression.Function) {
			return isScalar(x.a);
		}
		if (x instanceof Expression.NonSimplifiedExpression) {
			return isScalar(x.unwrap());
		}
		return false;
	};

	Expression.isScalar = isScalar;

	var getIdentityMatrixCoefficient = function (x) {
		var t = undefined;
		if (x instanceof Multiplication && x.b instanceof IdentityMatrix) {
			t = x.a;
		} else if (x instanceof IdentityMatrix) {
			t = Expression.ONE;
		} else if (isScalar(x)) {
			t = x;
		} else if (x instanceof Addition) {
			if (Expression.has(x, IdentityMatrix)) {
				var ca = getIdentityMatrixCoefficient(x.a);
				var cb = getIdentityMatrixCoefficient(x.b);
				if (ca != undefined && cb != undefined) {
					t = ca.add(cb);
				}
			}
		}
		return t;
	};

	Expression.prototype.addMatrix = function (x) {
		var t = getIdentityMatrixCoefficient(this);
		if (t != undefined) {

			if (x.matrix.isSquare()) {
				return new Expression.Matrix(Matrix.I(x.matrix.rows()).scale(t)).add(x);
			} else {
				throw new RangeError("NonSquareMatrixException");
			}
		}
		return this.addExpression(x);
	};
	Expression.Matrix.prototype.addExpression = function (x) {
		var t = getIdentityMatrixCoefficient(x);
		if (t != undefined) {

			if (this.matrix.isSquare()) {
				return this.add(new Expression.Matrix(Matrix.I(this.matrix.rows()).scale(t)));
			} else {
				throw new RangeError("NonSquareMatrixException");
			}
		}
		return Expression.prototype.addExpression.call(this, x);
	};

	Expression.Matrix.prototype.toString = function (options) {
		return this.matrix.toString(setTopLevel(true, options));
	};

	Expression.Matrix.prototype.isExact = function () {
		return this.matrix.isExact();
	};

	function BinaryOperation(a, b) {

		this.a = a;
		this.b = b;
	}

	BinaryOperation.prototype = Object.create(Expression.prototype);

	BinaryOperation.prototype.isNegation = function () {

		return (this instanceof Multiplication && this.a instanceof Integer && this.a.equals(Expression.ONE.negate()));
	};

	var setTopLevel = function (isTopLevel, options) {
		return options == undefined ? {isTopLevel: isTopLevel} : Object.assign({}, options, {isTopLevel: isTopLevel});
	};

	Expression.setTopLevel = setTopLevel;

	BinaryOperation.prototype.toString = function (options) {

		var a = this.a;
		var b = this.b;
		var isSubtraction = false;

		if (this instanceof Addition && b.isNegative()) {
			isSubtraction = true;
			b = b.negateCarefully();
		}
		var fa = a.getPrecedence(options) + (a.isRightToLeftAssociative() ? -1 : 0) < this.getPrecedence(options);
		var fb = this.getPrecedence(options) + (this.isRightToLeftAssociative() ? -1 : 0) >= b.getPrecedence(options);
		if (options != undefined && options.isTopLevel != undefined && options.isTopLevel === false) {
			fa = fa || a.isUnaryPlusMinus();
		}
		fb = fb || b.isUnaryPlusMinus();
		fb = fb || (this.unwrap() instanceof Exponentiation && b.unwrap() instanceof Exponentiation);
		fa = fa || (this.unwrap() instanceof Exponentiation && a.unwrap() instanceof Expression.Function);
		var s = isSubtraction ? "-" : this.getS();

		if (this.isNegation()) {

			return "-" + (fb ? "(" : "") + b.toString(setTopLevel(fb, options)) + (fb ? ")" : "");
		}
		return (fa ? "(" : "") + a.toString(setTopLevel(fa || options == undefined || options.isTopLevel, options)) + (fa ? ")" : "") + s + (fb ? "(" : "") + b.toString(setTopLevel(fb, options)) + (fb ? ")" : "");
	};

	Expression.prototype.unwrap = function () {
		return this;
	};

	function Exponentiation(a, b) {
		BinaryOperation.call(this, a, b);
	}

	Exponentiation.prototype = Object.create(BinaryOperation.prototype);

	Exponentiation.prototype.compare4Multiplication = function (y) {
		return y.compare4MultiplicationExponentiation(this);
	};
	Exponentiation.prototype.compare4MultiplicationInteger = function (x) {
		return -1;
	};

	Exponentiation.prototype.compare4MultiplicationExponentiation = function (x) {
		var y = this;
		return getBase(x).compare4Multiplication(getBase(y)) || getExponent(x).compare4Multiplication(getExponent(y));
	};
	BinaryOperation.prototype.compare4MultiplicationExponentiation = function () {
		return -1;
	};

	function Multiplication(a, b) {
		BinaryOperation.call(this, a, b);
	}

	Multiplication.prototype = Object.create(BinaryOperation.prototype);

	Multiplication.prototype.multiply = function (y) {
		return y.multiplyExpression(this);
	};

	var compare4Multiplication2 = function (x, y) {

		if (x instanceof NthRoot && y instanceof NthRoot) {
			var test = x.multiply(y);

			if (test instanceof Expression.Multiplication) {
				if (test.equals(new Expression.Multiplication(x, y))) {
					return -1;
				}
				if (test.equals(new Expression.Multiplication(y, x))) {
					return +1;
				}
			}
			return 0;
		}

		if (x instanceof Integer && y instanceof Exponentiation) {
			return -1;
		}
		if (x instanceof Exponentiation && y instanceof Integer) {
			return +1;
		}
		if (x instanceof Expression.Complex && y instanceof Exponentiation) {
			return -1;
		}
		if (x instanceof Exponentiation && y instanceof Expression.Complex) {
			return +1;
		}

		return compare4Multiplication(getBase(x), getBase(y));
	};

	function Negation(b) {

		this.b = b;
	}

	Negation.prototype = Object.create(Expression.prototype);

	Expression.prototype.equalsNegation = function (x) {
		return false;
	};
	Negation.prototype.equalsNegation = function (b) {
		return this.b.equals(b.b);
	};
	Negation.prototype.equals = function (b) {
		return b.equalsNegation();
	};
	Negation.prototype.toString = function (options) {
		var b = this.b;
		var fb = this.getPrecedence() + (this.isRightToLeftAssociative() ? -1 : 0) >= b.getPrecedence();
		fb = fb || b.isUnaryPlusMinus();

		return "-" + (fb ? "(" : "") + b.toString(setTopLevel(fb, options)) + (fb ? ")" : "");
	};

	function Subtraction(a, b) {
		BinaryOperation.call(this, a, b);
	}

	Subtraction.prototype = Object.create(BinaryOperation.prototype);

	Subtraction.prototype.getS = function () {
		return "-";
	};

	function Addition(a, b) {
		BinaryOperation.call(this, a, b);
	}

	Addition.prototype = Object.create(BinaryOperation.prototype);
	Addition.prototype.multiply = function (y) {
		return y.multiplyAddition(this);
	};
	var _multiplyAddition = function (value, addition, fromLeft) {

		var result = [];
		for (var iterators = addition.summands()[globalThis.Symbol.iterator](), s = iterators.next().value; s != null; s = iterators.next().value) {
			var v = fromLeft ? value.multiply(s) : s.multiply(value);
			result.push(v);
		}
		return _sum(result);
	};
	var _sum = function (summands) {
		var k = summands.length;
		if (k === 0) {
			return Expression.ZERO;
		}
		while (k > 1) {
			for (var i = 0; 2 * i < k; i += 1) {
				summands[i] = 2 * i + 1 < k ? summands[2 * i + 1].add(summands[2 * i]) : summands[2 * i];
			}
			k = Math.ceil(k / 2);
		}
		return summands[0];
	};
	Expression._sum = _sum;
	Expression.prototype.multiplyAddition = function (x) {
		return _multiplyAddition(this, x, false);

	};
	Addition.prototype.multiplyExpression = function (x) {
		return _multiplyAddition(x, this, true);

	};

	function Division(a, b) {
		BinaryOperation.call(this, a, b);
	}

	Division.prototype = Object.create(BinaryOperation.prototype);
	Division.prototype.multiply = function (y) {
		return y.multiplyDivision(this);
	};
	Expression.prototype.multiplyDivision = function (x) {
		return x.a.multiply(this).divide(x.b);
	};
	Division.prototype.multiplyDivision = function (x) {
		return x.a.multiply(this.a).divide(x.b.multiply(this.b));
	};
	Division.prototype.multiplyExpression = function (x) {
		return x.multiply(this.a).divide(this.b);
	};
	Division.prototype.add = function (y) {
		return y.addDivision(this);
	};
	Expression.prototype.addDivision = function (x) {
		return x.a.add(this.multiply(x.b)).divide(x.b);
	};
	Division.prototype.addDivision = function (x) {
		if (x.b.equals(this.b)) {
			return x.a.add(this.a).divide(this.b);
		}

		return x.a.multiply(this.b).add(x.b.multiply(this.a)).divide(x.b.multiply(this.b));
	};
	Division.prototype.addExpression = function (x) {
		return x.multiply(this.b).add(this.a).divide(this.b);
	};
	Division.prototype.divide = function (y) {
		return this.a.divide(this.b.multiply(y));
	};
	Division.prototype.divideExpression = function (x) {
		return x.multiply(this.b).divide(this.a);
	};

	Division.prototype.multiplyAddition = function (x) {
		return x.multiply(this.a).divide(this.b);
	};

	Expression.prototype.equals = function (b) {
		throw new RangeError();
	};
	Expression.prototype.equalsInteger = function (x) {
		if (this instanceof Expression.ExpressionWithPolynomialRoot || this instanceof Expression.ExpressionPolynomialRoot) {
			return this.equals(x);
		}
		return false;
	};
	var _isNumberTypeUsedForSmall = SmallBigInt.BigInt(0) === 0;
	Integer.prototype.equals = function (y) {

		if (y === Expression.ZERO) {
			if (_isNumberTypeUsedForSmall) {
				return typeof this.value === "number" && this.value === 0;
			}
		}
		if (y === Expression.ONE) {
			if (_isNumberTypeUsedForSmall) {
				return typeof this.value === "number" && this.value === 1;
			}
		}
		return y.equalsInteger(this);
	};
	Integer.prototype.equalsInteger = function (x) {
		return x.compareTo(this) === 0;

	};
	Expression.Symbol.prototype.equals = function (b) {
		return b instanceof Expression.Symbol && this.symbol === b.symbol;
	};
	BinaryOperation.prototype.equals = function (b) {
		if (b instanceof Addition && Expression.has(b, Expression.ExpressionPolynomialRoot)) {

			return this.subtract(b).equals(Expression.ZERO);
		}
		if (b instanceof Addition && this instanceof Multiplication && Expression.has(this, Expression.ExpressionPolynomialRoot) || this instanceof Addition && b instanceof Multiplication && Expression.has(b, Expression.ExpressionPolynomialRoot)) {

			return this.subtract(b).equals(Expression.ZERO);
		}
		if (this instanceof Addition && b instanceof Addition) {

			var x = this;
			var y = b;
			var i = x.summands();
			var j = y.summands();
			var a = i.next().value;
			var b = j.next().value;
			while (a != null && b != null) {
				if (!a.equals(b)) {
					return false;
				}
				a = i.next().value;
				b = j.next().value;
			}
			return a != null ? false : (b != null ? false : true);
		}
		if (b instanceof Expression.ExpressionWithPolynomialRoot || b instanceof Expression.ExpressionPolynomialRoot) {

			return b.equals(this);
		}
		return b instanceof BinaryOperation && this.getS() === b.getS() && this.a.equals(b.a) && this.b.equals(b.b);
	};

	function MatrixSymbol(symbol) {
		Expression.Symbol.call(this, symbol);
	}

	MatrixSymbol.prototype = Object.create(Expression.Symbol.prototype);

	Exponentiation.prototype.inverse = function () {
		return this.pow(Expression.ONE.negate());
	};
	MatrixSymbol.prototype.inverse = function () {
		return this.pow(Expression.ONE.negate());
	};
	MatrixSymbol.prototype.compare4Multiplication = function (y) {
		return y.compare4MultiplicationMatrixSymbol(this);
	};
	Expression.prototype.compare4MultiplicationMatrixSymbol = function (x) {
		return +1;
	};
	Addition.prototype.compare4MultiplicationMatrixSymbol = function (x) {
		return -1;
	};
	Expression.Matrix.prototype.compare4MultiplicationMatrixSymbol = function (x) {
		return x instanceof IdentityMatrix ? +1 : -1;
	};
	MatrixSymbol.prototype.compare4MultiplicationMatrixSymbol = function (x) {
		var c = Expression.Symbol.prototype.compare4MultiplicationSymbol.call(this, x);
		return c === +1 ? -1 : c;
	};
	MatrixSymbol.prototype.compare4MultiplicationSymbol = function (x) {
		return -1;
	};
	MatrixSymbol.prototype.equals = function (b) {
		return b instanceof MatrixSymbol && Expression.Symbol.prototype.equals.call(this, b);
	};
	MatrixSymbol.prototype.transpose = function () {

		return new Expression.Exponentiation(this, new Expression.Symbol("T"));
	};

	Expression.MatrixSymbol = MatrixSymbol;

	function IdentityMatrix(symbol) {
		MatrixSymbol.call(this, symbol);
	}

	IdentityMatrix.prototype = Object.create(MatrixSymbol.prototype);

	IdentityMatrix.prototype.multiplyAddition = function (x) {
		if (isScalar(x)) {
			return new Multiplication(x, this);
		}
		return Expression.prototype.multiplyAddition.call(this, x);
	};

	IdentityMatrix.prototype.addMatrix = function (x) {
		return x.add(new Expression.Matrix(Matrix.I(x.matrix.rows())));
	};
	IdentityMatrix.prototype.add = function (y) {
		return y.addIdentityMatrix(this);
	};
	Expression.prototype.addIdentityMatrix = function (x) {
		return this.addExpression(x);
	};
	Expression.Matrix.prototype.addIdentityMatrix = function (x) {
		return new Expression.Matrix(Matrix.I(this.matrix.rows())).add(this);
	};

	IdentityMatrix.prototype.multiplyDivision = function (x) {
		if (isScalar(x)) {
			return new Multiplication(x, this);
		}
		return Expression.prototype.multiplyExpression.call(this, x);
	};

	IdentityMatrix.prototype.compare4MultiplicationMatrixSymbol = function (x) {
		var y = this;
		return x instanceof IdentityMatrix ? (x.symbol < y.symbol ? -1 : (y.symbol < x.symbol ? +1 : 0)) : +1;
	};

	IdentityMatrix.prototype.augment = function (other) {
		return new Expression.Matrix(Matrix.I(other.matrix.cols()).augment(other.matrix));
	};

	Expression.IdentityMatrix = IdentityMatrix;

	BinaryOperation.prototype.getS = function () {
		throw new TypeError("abstract");
	};
	Exponentiation.prototype.getS = function () {
		return "^";
	};
	Multiplication.prototype.getS = function () {
		return "*";
	};
	Negation.prototype.getS = function () {
		return "-";
	};
	Addition.prototype.getS = function () {
		return "+";
	};
	Division.prototype.getS = function () {
		return "/";
	};

	Expression.Function = function (name, a) {

		this.name = name;
		this.a = a;
	};
	Expression.Function.prototype = Object.create(Expression.prototype);
	Expression.Function.prototype.toString = function (options) {

		return this.name + "(" + this.a.toString(setTopLevel(true, options)) + ")";
	};
	Expression.Function.prototype.equals = function (b) {
		return b instanceof Expression.Function && this.name === b.name && this.a.equals(b.a);
	};

	Negation.prototype.isUnaryPlusMinus = function () {
		return true;
	};
	BinaryOperation.prototype.isUnaryPlusMinus = function () {
		return this.isNegation();
	};
	Expression.Function.prototype.isUnaryPlusMinus = function () {
		return false;
	};
	Expression.prototype.isUnaryPlusMinus = function () {
		return false;
	};
	Integer.prototype.isUnaryPlusMinus = function () {
		return this.compareTo(Expression.ZERO) < 0;
	};

	Negation.prototype.getPrecedence = function () {
		return precedence.unary["-"];
	};
	BinaryOperation.prototype.getPrecedence = function () {
		return this.isNegation() ? precedence.unary["-"] : precedence.binary[this.getS()];
	};
	Expression.Function.prototype.getPrecedence = function () {
		return precedence.unary["-"];
	};
	Expression.prototype.getPrecedence = function () {
		return 1000;
	};
	Integer.prototype.getPrecedence = function () {
		return this.compareTo(Expression.ZERO) < 0 ? precedence.unary["-"] : 1000;
	};

	Expression.prototype.isNegative = function () {
		var x = this;
		if (x instanceof Integer) {
			return x.compareTo(Expression.ZERO) < 0;
		}
		if (x instanceof Expression.Complex) {
			return x.real.compareTo(Expression.ZERO) < 0 || (x.real.compareTo(Expression.ZERO) === 0 && x.imaginary.compareTo(Expression.ZERO) < 0);
		}
		if (x instanceof Addition) {
			var e = x;
			do {
				e = e.a;
			} while (e instanceof Addition);
			return e.isNegative();

		}
		if (x instanceof Multiplication) {
			return x.a.isNegative() !== x.b.isNegative();
		}
		if (x instanceof Division) {
			return x.a.isNegative() !== x.b.isNegative();
		}
		if (x instanceof Negation) {

			return true;
		}
		if (x instanceof Expression.Radians) {
			return x.value.isNegative();
		}
		return false;
	};

	Expression.prototype.negateCarefully = function () {
		if (this instanceof Integer) {
			return this.negate();
		}
		if (this instanceof Addition) {
			return new Addition(this.a.negateCarefully(), this.b.negateCarefully());
		}
		if (this instanceof Multiplication) {
			return this.b.isNegative() ? new Multiplication(this.a, this.b.negateCarefully()) : (this.a.negateCarefully().equals(Expression.ONE) ? this.b : new Multiplication(this.a.negateCarefully(), this.b));
		}
		if (this instanceof Division) {
			return this.b.isNegative() ? new Division(this.a, this.b.negateCarefully()) : new Division(this.a.negateCarefully(), this.b);
		}
		if (this instanceof Negation) {
			return this.b;
		}
		return this.negate();
	};

	function NthRoot(name, a, n) {
		Expression.Function.call(this, name, a);
		this.n = n;
		this.degree = n;
		this.radicand = a;

		console.assert(name === (n === 2 ? "sqrt" : n + "-root"));
	}

	NthRoot.prototype = Object.create(Expression.Function.prototype);

	NthRoot.prototype.compare4Multiplication = function (y) {
		return y.compare4MultiplicationNthRoot(this);
	};
	NthRoot.prototype.compare4MultiplicationInteger = function (x) {
		return -1;
	};
	NthRoot.prototype.compare4MultiplicationSymbol = function (x) {
		return +1;
	};
	NthRoot.prototype.compare4MultiplicationNthRoot = function (x) {
		return x.n < this.n ? -1 : (x.n > this.n ? +1 : 0);
	};

	NthRoot.prototype.toString = function (options) {
		var fa = this.a.getPrecedence() <= this.getPrecedence();
		return (fa ? "(" : "") + this.a.toString(setTopLevel(fa || options == undefined || options.isTopLevel, options)) + (fa ? ")" : "") + "^" + (this.n === 2 ? "0.5" : "(1/" + this.n + ")");
	};

	var isCommutative = function (e) {
		return !Expression.has(e, Expression.Matrix) && !Expression.has(e, Expression.MatrixSymbol);
	};

	NthRoot.prototype.getDegree = function () {
		console.error('deprecated');
		return this.n;
	};
	NthRoot.prototype.multiplyExpression = function (x) {
		if (x instanceof Multiplication && isCommutative(this) && this.a instanceof Expression.Integer) {
			for (var iteratory = x.factors()[globalThis.Symbol.iterator](), y = iteratory.next().value; y != null; y = iteratory.next().value) {
				if (y instanceof NthRoot && y.a instanceof Expression.Integer && compare4Multiplication2(y, this) === 0) {
					var multiplied = false;
					var result = Expression.ONE;
					for (var iteratory1 = x.factors()[globalThis.Symbol.iterator](), y1 = iteratory1.next().value; y1 != null; y1 = iteratory1.next().value) {
						var y2 = y1;
						if (!multiplied && y === y1) {
							y2 = y.multiply(this);
							multiplied = true;
						}
						result = result.multiply(y2);
					}
					return result;
				}
			}
		}
		return Expression.prototype.multiplyExpression.call(this, x);
	};

	NthRoot.prototype.equals = function (b) {
		if (b instanceof Expression.ExpressionWithPolynomialRoot || b instanceof Expression.ExpressionPolynomialRoot) {
			return b.equals(this);
		}
		return Expression.Function.prototype.equals.call(this, b);
	};

	NthRoot.prototype._pow = function (count) {
		var g = Math.gcd(this.n, count);
		if (g > 1) {
			if (this.n === g) {
				return this.a._pow(count / g);
			}
			return this.a._nthRoot(this.n / g)._pow(count / g);
		}
		return Expression.prototype._pow.call(this, count);
	};

	function isPerfectCube(n) {
		return SmallBigInt.toNumber(SmallBigInt.subtract(SmallBigInt.exponentiate(n._integerNthRoot(3).toBigInt(), SmallBigInt.BigInt(3)), n.toBigInt())) === 0;
	}

	function isPerfectSquare(n) {
		return SmallBigInt.toNumber(SmallBigInt.subtract(SmallBigInt.exponentiate(n._integerNthRoot(2).toBigInt(), SmallBigInt.BigInt(2)), n.toBigInt())) === 0;
	}

	var makeRoot = function (i, n) {
		return n === 1 ? i : (n === 2 ? new SquareRoot(i) : new NthRoot(n + "-root", i, n));
	};
	NthRoot.makeRoot = makeRoot;

	Expression.prototype._nthRoot = function (n) {
		if (typeof n === "number") {
			if (n < 1 || n > Number.MAX_SAFE_INTEGER || Math.floor(n) !== n) {
				throw new RangeError("NotSupportedError");
			}
		} else {
			if (!(this instanceof Expression.Matrix)) {
				throw new RangeError("NotSupportedError");
			}
		}
		var x = this;

		if (n === 2) {
			if (x instanceof Addition) {
				if ((x.a instanceof SquareRoot || x.a instanceof Multiplication && x.a.a instanceof Integer && x.a.b instanceof SquareRoot) && x.b instanceof Integer) {

					var u = x.a;
					var v = x.b;

					var tt = v.multiply(v).subtract(u.multiply(u));
					if (tt instanceof Integer && !isPerfectSquare(tt.abs())) {
						tt = null;
					}
					var t = tt instanceof Integer && tt.compareTo(Expression.ZERO) >= 0 ? tt.squareRoot() : undefined;
					if (t != undefined && (t instanceof Integer)) {
						var aa = v.add(t);
						var a = aa.compareTo(Expression.ZERO) >= 0 ? aa.squareRoot().divide(Expression.TWO.squareRoot()) : undefined;
						if (a != undefined) {
							var b = u.divide(Expression.TWO.multiply(a));
							return a.add(b);
						}
					}
				}

				if ((x.a instanceof SquareRoot || x.a instanceof Multiplication && x.a.a instanceof Integer && x.a.b instanceof SquareRoot) && (x.b instanceof SquareRoot || x.b instanceof Multiplication && x.b.a instanceof Integer && x.b.b instanceof SquareRoot)) {
					var a = x.a;
					var b = x.b;
					var aa = a.multiply(a);
					var bb = b.multiply(b);
					var g = aa.gcd(bb).squareRoot();
					if (!g.equals(Expression.ONE)) {
						var v = a.divide(g).add(b.divide(g)).squareRoot().multiply(g.squareRoot());
						if (typeof hit === "function") {
							hit({rootFromAddition: x.toString()});
						}
						return v;
					}
				}
				if (Expression._isPositive(x)) {
					var tmp = getConjugateFactor(x);
					if (tmp.p != null) {
						var t = tmp.p.toExpression()._nthRoot(tmp.degree);
						var polynomial = getPolynomialRelativeToNthRoot(x, tmp.p, tmp.degree);
						var u = polynomial.getCoefficient(1).multiply(t.toExpression());
						var v = polynomial.getCoefficient(0);
						var D = v.multiply(v).subtract(u.multiply(u));
						var f1 = function (aa) {
							var tmp = aa.divide(getConstant(aa));
							var c = Expression.getConjugate(tmp);
							return c != null && c.multiply(tmp) instanceof Integer && isPerfectSquare(c.multiply(tmp).abs());
						};
						if (D instanceof Integer || f1(D)) {
							var sD = D.squareRoot();
							var aa = v.add(sD);
							if (aa instanceof Integer || f1(aa)) {

								var a = aa.squareRoot().divide(Expression.TWO.squareRoot());
								var b = u.divide(Expression.TWO.multiply(a));
								return a.add(b);
							}
						}
					}
				} else if (Expression._isPositive(x.negate()) && n === 2) {
					return Expression.I.multiply(x.negate()._nthRoot(2));
				}
			}
		}
		if (n === 3) {
			if (x instanceof Addition) {
				if ((x.a instanceof SquareRoot && x.a.a instanceof Integer || x.a instanceof Multiplication && x.a.a instanceof Integer && x.a.b instanceof SquareRoot) && x.b instanceof Integer) {

					var u = x.a;
					var v = x.b;
					var d = u.multiply(u).subtract(v.multiply(v));
					if (isPerfectCube(d)) {

						var t = new Expression.Symbol('t');

						var NINE = Expression.Integer.fromNumber(9);
						var TWENTY_SEVEN = Expression.Integer.fromNumber(27);
						var eq = Expression.pow(NINE.multiply(t).add(v.subtract(t)), 2).multiply(v.subtract(t)).subtract(TWENTY_SEVEN.multiply(t).multiply(Expression.pow(u, 2)));
						var p = Polynomial.toPolynomial(eq, t);
						p = p.scale(p.getContent().inverse());
						var t = p.doRationalRootTest();
						if (t != null) {
							var a = t._nthRoot(3);
							var b = u.divide(u.abs()).multiply(v.subtract(t).divide(Expression.Integer.fromNumber(3).multiply(a))._nthRoot(2));
							return a.add(b);
						}
					}
				}
			}
		}

		if (x instanceof NthRoot) {
			if (typeof hit === "function") {
				hit({rootFromRoot: ""});
			}
			return x.a._nthRoot(x.n * n);
		}
		if (x instanceof Division || x instanceof Multiplication) {
			if (n % 2 !== 0 || x.a instanceof Integer && x.a.compareTo(Expression.ZERO) > 0 || x.b instanceof Integer && x.b.compareTo(Expression.ZERO) > 0 || x.a instanceof Integer && isConstant(x.b) || isConstant(x) || isPositive(x.a) || isPositive(x.b) ||

				isPositive(x.b.negate())) {
				if (x instanceof Division) {
					return x.a._nthRoot(n).divide(x.b._nthRoot(n));
				}
				if (x instanceof Multiplication) {
					return x.a._nthRoot(n).multiply(x.b._nthRoot(n));
				}
			}
		}
		var qi = x instanceof Integer ? x : null;
		var qq = QuadraticInteger.toQuadraticInteger(x);

		if (qq == null && x instanceof Expression.Addition) {
			if (x.a instanceof Multiplication && x.b instanceof Multiplication) {
				var g = x.a.pow(Expression.TWO).gcd(x.b.pow(Expression.TWO)).squareRoot();
				if (!g.equals(Expression.ONE)) {
					return g._nthRoot(n).multiply(x.divide(g)._nthRoot(n));
				}
			}
		}

		if (qq != null) {
			if (n !== 2 && n % 2 === 0) {

				var tmp = x.squareRoot();
				if (!(tmp instanceof Expression.SquareRoot)) {
					return tmp._nthRoot(n / 2);
				}
			}
			if ((n === 2 || n === 3) && qq.isValid()) {

				if (qq.isPositive()) {
					qi = qq;

					if (qq.norm != null && Math.abs(Number(qq.norm().toString())) > Number.MAX_SAFE_INTEGER) {
						if (n !== 3) {
							qi = null;
						}
					}

				} else {
					return Expression.ONE.negate()._nthRoot(n).multiply(this.negate()._nthRoot(n));
				}

			}
		}
		if (qi != null) {
			x = qi;
			if (x instanceof Integer && x.compareTo(Expression.ZERO) < 0) {
				if (n % 2 === 0) {
					if (n === 2) {
						return Expression.I.multiply(this.negate()._nthRoot(n));
					}
					throw new RangeError("NotSupportedError");
				}
				return this.negate()._nthRoot(n).negate();
			}
			if (x.equals(Expression.ZERO)) {
				return this;
			}
			var roots = [];
			var i = x;
			while (!i.equals(Expression.ONE)) {
				var d = i.primeFactor();
				if (d instanceof QuadraticInteger) {
					if (n !== 2 && n !== 3) {
						throw new TypeError();
					}

					if (Number(d.a.toString()) < 0 && Number(d.b.toString()) > 0 || Number(d.a.toString()) > 0 && Number(d.b.toString()) < 0) {
						var a = (n % 2 === 0 ? d.abs() : d);
						return x.toExpression().divide(a.toExpression()._pow(n))._nthRoot(n).multiply(a.toExpression());
					}

					var s = d.norm();

					if (Number(d.b.toString()) !== 0 && Number(d.a.toString()) !== 0 && Number(s.toString()) >= 0 && isPerfectSquare(Integer.fromBigInt(s))) {
						if (n === 2) {
							return x.toExpression().divide(d.toExpression())._nthRoot(2).multiply(d.toExpression()._nthRoot(2));
						}
					}
				}
				var ctz = i instanceof Expression.Integer && d instanceof Expression.Integer ? primeFactor._countTrailingZeros(i.value, d.value) : -1;
				var e = 0;
				if (ctz !== -1) {
					e = ctz;
					i = i.truncatingDivide(d._pow(ctz));
				} else {
					if (i.isUnit()) {

						while (!i.equals(Expression.ONE)) {
							i = i.truncatingDivide(d);
							e += 1;
						}
					} else {
						while (i.isDivisibleBy(d)) {
							i = i.truncatingDivide(d);
							e += 1;
						}
					}
				}

				d = d.toExpression();
				var nn = n;
				if (d instanceof NthRoot) {
					nn *= d.n;
					d = d.a;
				}
				var t = Math.gcd(nn, e);
				nn /= t;
				e /= t;

				while (e !== 0) {

					var g = e >= nn ? nn : 1;

					var e1 = Math.floor(e / g);
					var k = Math.floor(nn / g);
					roots.push(Object.freeze({
						degree: k,
						radicand: Expression.pow(d, e1)
					}));

					e = e - g * e1;
				}
			}
			var y = Expression.ONE;
			roots.sort(function (a, b) {
				return a.degree - b.degree;
			});
			var k = -1;
			for (var i = 0; i < roots.length; i += 1) {
				if (k === -1 || roots[i].degree !== roots[k].degree) {
					k += 1;
					roots[k] = roots[i];
				} else {
					roots[k] = Object.freeze({
						degree: roots[i].degree,
						radicand: roots[k].radicand.multiply(roots[i].radicand)
					});
				}
			}
			roots.length = k + 1;

			var f = null;
			for (var jj = 0; jj < roots.length; jj += 1) {
				var degree = roots[jj].degree;
				if (degree !== 1) {
					var radicand = roots[jj].radicand;

					var x = makeRoot(radicand, degree);
					if (y !== Expression.ONE) {
						y = new Expression.Multiplication(y, x);
					} else {
						y = x;
					}
				} else {
					f = roots[jj].radicand;
				}
			}
			if (f != null) {
				y = f.multiply(y);
			}
			return y;
		}
		if (x instanceof Expression.Matrix) {
			if (typeof hit === "function") {
				hit(n === 2 ? {squareRoot: "matrix"} : {nthRoot: "Matrix^(1/" + n + ")"});
			}
			var eigenvalues = Expression.getEigenvalues(x.matrix);
			var N = typeof n === "number" ? Expression.Integer.fromNumber(n) : n;
			if (eigenvalues.length === x.matrix.cols()) {
				var eigenvectors = Expression.getEigenvectors(x.matrix, eigenvalues);
				if (eigenvectors.filter(function (v) {
					return v != null;
				}).length === x.matrix.cols()) {
					if (!x.matrix.isDiagonal()) {
						if (Expression.callback != undefined) {
							Expression.callback(new Expression.Event("nth-root-using-diagonalization", x));
						}
						if (Expression.callback != undefined) {
							Expression.callback(new Expression.Event("diagonalize", x));
						}
					}
					var tmp = Expression.diagonalize(x.matrix, eigenvalues, eigenvectors);
					var L = tmp.L;
					var SL = L.map(function (e, i, j) {
						return i === j ? e.pow(Expression.ONE.divide(N)) : e;
					});
					return new Expression.Matrix(tmp.T.multiply(SL).multiply(tmp.T_INVERSED));
				} else {
					if (!x.matrix.isJordanMatrix()) {
						if (Expression.callback != undefined) {
							Expression.callback(new Expression.Event("nth-root-using-Jordan-normal-form", x));
						}
						if (Expression.callback != undefined) {
							Expression.callback(new Expression.Event("Jordan-decomposition", x));
						}
					} else {
						if (Expression.callback != undefined) {
							Expression.callback(new Expression.Event("Jordan-matrix-nth-root", x));
						}
					}
					var rootOfJordanForm = function (J, N) {
						var tmp = J.map(function (e, i, j) {
							if (i > j) {
								return Expression.ZERO;
							}
							if (i === j) {
								return J.e(i, j).pow(Expression.ONE.divide(N));
							}
							if (J.e(i, i + 1).equals(Expression.ZERO)) {
								return Expression.ZERO;
							}
							if (!J.e(i, i + 1).equals(Expression.ONE)) {
								throw new TypeError("assertion");
							}

							var m = j - i;
							for (var k = 0; k < m; k += 1) {
								if (!J.e(j - 1 - k, j - k).equals(Expression.ONE)) {
									return Expression.ZERO;
								}
							}

							var f = Expression.ONE;
							for (var k = 0; k < m; k += 1) {
								f = f.multiply(Expression.ONE.divide(N).subtract(Expression.Integer.fromNumber(k))).divide(Expression.Integer.fromNumber(k + 1));
							}
							return f.divide(J.e(i, i)._pow(m)).multiply(J.e(i, i).pow(Expression.ONE.divide(N)));
						});

						return tmp;
					};
					var tmp = Expression.getFormaDeJordan(x.matrix, eigenvalues);
					var JN = rootOfJordanForm(tmp.J, N);

					return new Expression.Matrix(tmp.P.multiply(JN).multiply(tmp.P_INVERSED));
				}
			}

		}

		if (x instanceof Exponentiation && x.a instanceof Integer && x.a.compareTo(Expression.ZERO) > 0) {

			if (x.b instanceof Expression.Symbol) {
				if (x.a instanceof Expression.Integer && integerPrimeFactor(x.a).equals(x.a)) {

					return new Expression.Exponentiation(x.a, x.b.divide(Expression.Integer.fromNumber(n)));
				}
			} else {
				return x.a.pow(x.b.divide(Expression.Integer.fromNumber(n)));
			}

		}

		if (x instanceof Exponentiation && x.a === Expression.E) {
			return x.a.pow(x.b.divide(Expression.Integer.fromNumber(n)));
		}
		if (x instanceof Exponentiation && getBase(x) instanceof Expression.Logarithm && getBase(x).a instanceof Expression.Integer) {
			return x.a.pow(x.b.divide(Expression.Integer.fromNumber(n)));
		}
		if (x instanceof IdentityMatrix) {
			if (simplifyIdentityMatrixPower) {
				return x;
			}
		}

		if (x instanceof Expression.Symbol) {
			return new Expression.Exponentiation(x, Expression.ONE.divide(Expression.Integer.fromNumber(n)));
		}
		if (x instanceof Exponentiation && (x.a instanceof Expression.Symbol || isGoodPolynomial(x.a)) && (n % 2 === 1 || (x.b.getNumerator() instanceof Integer && x.b.getNumerator().remainder(Expression.TWO).equals(Expression.ONE)))) {

			var b = x.b.divide(Expression.Integer.fromNumber(n));
			return b.equals(Expression.ONE) ? x.a : new Expression.Exponentiation(x.a, b);
		}

		var v = getVariableInternal(getLastMultiplicationOperand(getFirstAdditionOperand(x))).next().value.v;
		if (v instanceof Expression.Symbol || (v instanceof Expression.Logarithm && v.a instanceof Expression.Integer) && (n === 2 || n === 3 || true)) {
			var p = Polynomial.toPolynomial(x, v);
			var c = p.getContent();
			if (c.isNegative()) {
				c = c.negate();
			}
			if (isPositive(c) && !c.equals(Expression.ONE)) {
				return x.divide(c)._nthRoot(n).multiply(c._nthRoot(n));
			}
			if (p.getDegree() === 1 && p.getCoefficient(0) instanceof Integer && !p.getCoefficient(0).equals(Expression.ZERO) && p.getCoefficient(1) instanceof Integer) {

				if (p.getCoefficient(1).compareTo(Expression.ZERO) > 0) {
					var N = n instanceof Expression.Symbol ? n : Expression.Integer.fromNumber(n);
					return new Expression.Exponentiation(x, Expression.ONE.divide(N));
				} else {

					if (n % 2 !== 0) {
						return Expression.ONE.negate()._nthRoot(n).multiply(new Expression.Exponentiation(x.negate(), Expression.ONE.divide(Expression.Integer.fromNumber(n))));
					}
				}
			}
			if (p.getDegree() > 1 && !p.getCoefficient(0).equals(Expression.ZERO)) {

				var N = p.getDegree();
				var sf = p.getSquareFreePolynomial();
				if (sf.getDegree() === 1) {

					var t = sf.calcAt(v);
					if (x.equals(t._pow(N))) {

						if (N >= n && (n % 2 !== 0 || Expression._isPositive(v))) {
							return t.pow(Expression.ONE).multiply(t._pow(N - n)._nthRoot(n));
						}

						if (n % 2 !== 0 || Expression._isPositive(v)) {
							return new Expression.Exponentiation(t, Expression.Integer.fromNumber(N).divide(Expression.Integer.fromNumber(n)));
						}
					}
				}

				if (p.getDegree() > 1 && p.getSquareFreePolynomial().equals(p) && n === 2) {
					return new Expression.Exponentiation(x, Expression.ONE.divide(Expression.Integer.fromNumber(n)));
				}
				if (p.getDegree() > 1 && n === 3) {
					var d = simpleDivisor(x);
					if (!x.equals(d)) {
						return x.divide(d)._nthRoot(n).multiply(d._nthRoot(n));
					}
				}
			}
		}

		if (n % 2 !== 0 && x instanceof Expression.ExponentiationOfMinusOne) {
			return getBase(x).pow(getExponent(x).divide(Expression.Integer.fromNumber(n)));
		}

		if (x instanceof Addition && x.b instanceof NthRoot && x.a instanceof NthRoot) {
			var g = nthRootCommonFactor(x.a, x.b);
			if (!g.equals(Expression.ONE)) {
				return g._nthRoot(n).multiply(x.divide(g)._nthRoot(n));
			}
		}

		if (x instanceof Exponentiation && n === 3 && getExponent(x).equals(Integer.fromNumber(3))) {
			return getBase(x);
		}
		if (x instanceof Exponentiation && n === 2 && getExponent(x).equals(Integer.fromNumber(2))) {
			if (isPositive(getBase(x))) {
				return getBase(x);
			}
			if (isPositive(getBase(x).negate())) {
				return getBase(x).negate();
			}
		}

		if (n === 2 && !(x.getDenominator() instanceof Expression.Integer)) {
			var sd = simpleDivisor(x.getDenominator());
			if (sd.complexConjugate().multiply(sd).equals(x.getDenominator())) {
				return x.getNumerator()._nthRoot(n).divide(sd.abs());
			}
		}

		var sd = x instanceof Expression.Division ? x : simpleDivisor(x);
		if (!sd.equals(x)) {

			console.log(sd.toString());
			if (isPositive(sd) && (!(sd instanceof Addition) || !(x.divide(sd) instanceof Addition))) {
				if (!(sd._nthRoot(n) instanceof NthRoot)) {
					return sd._nthRoot(n).multiply(x.divide(sd)._nthRoot(n));
				}
			}
		}

		var allowComplexSqrt = true;
		var isComplexNumber = function (x) {
			return Expression.isConstant(x) && !Expression.has(x, Expression.Sin) && !Expression.has(x, Expression.Cos);
		};
		if (typeof n === "number" && !isPositive(x) && allowComplexSqrt && isComplexNumber(x) && n === 2) {

			var tmp = Expression.getComplexNumberParts(x);
			var a = tmp.real;
			var b = tmp.imaginary;

			var tmp2 = a._pow(2).add(b._pow(2)).squareRoot();
			var gamma = a.add(tmp2).divide(Expression.TWO).squareRoot();
			var delta = Expression.Integer.fromNumber(b.sign()).multiply(a.negate().add(tmp2).divide(Expression.TWO).squareRoot());
			var result = gamma.add(delta.multiply(Expression.I));
			return result;
		}
		if (typeof n === "number" && (isPositive(x) || allowComplexSqrt && isComplexNumber(x) && n === 2)) {
			var tmp = Expression.toPolynomialRoot(makeRoot(x, n));
			if (tmp != undefined) {
				return tmp;
			}
		}
		if (typeof n === "number" && isPositive(x.negate())) {
			var tmp = Expression.toPolynomialRoot(makeRoot(x.negate(), n));
			if (tmp != undefined) {
				return tmp.negate();
			}
		}

		if (getBase(x) instanceof Expression.Symbol && getBase(x).symbol.startsWith('$t') && typeof n === "number") {
			return getBase(x).pow(getExponent(x).divide(Expression.Integer.fromNumber(n)));
		}

		if (Expression.isReal(x) && typeof n === "number") {
			if (isPositive(x)) {
				return new Expression.Exponentiation(x, Expression.Integer.fromNumber(n).inverse());
			} else {

			}
		}

		if (n === 2 && !(this instanceof Expression.Exponentiation)) {
			var d = this instanceof Expression.Division ? this : simpleDivisor(this);
			if (d.complexConjugate().multiply(d).equals(this)) {
				return d.abs();
			}
		}

		if (n === 2 && !(this instanceof Expression.Exponentiation)) {
			console.log(this.toString());

			if (Expression.has(this, Expression.Symbol)) {
				return new Expression.Exponentiation(x, Expression.Integer.fromNumber(n).inverse());
			}
			return NthRoot.makeRoot(this, n);
		}

		throw new RangeError("NotSupportedError");
	};

	function SquareRoot(a) {
		NthRoot.call(this, "sqrt", a, 2);
	}

	SquareRoot.prototype = Object.create(NthRoot.prototype);

	SquareRoot.prototype.divideInteger = function (x) {

		return x.multiply(this).divide(this.a);
	};

	Expression.prototype.squareRoot = function () {
		return this._nthRoot(2);
	};

	Expression.Rank = function (matrix) {
		Expression.Function.call(this, "rank", matrix);
	};
	Expression.Rank.prototype = Object.create(Expression.Function.prototype);

	Expression.prototype.rank = function () {
		var x = this;
		if (!(x instanceof Expression.Matrix)) {
			throw new RangeError("NotSupportedError:matrixArgExpected");
		}

		if (Expression.callback != undefined) {
			Expression.callback(new Expression.Event("rank", x));
		}

		var cases = [];
		var rank = undefined;
		Matrix.toRowEchelonWithCallback(x.matrix, Matrix.GaussMontante, "", undefined, function (result) {
			var condition = result.condition;
			if (!condition.isTrue()) {
				var resultMatrix = result.matrix;
				cases.push(new ExpressionWithCondition(Integer.fromNumber(resultMatrix.rank()), condition));
			} else {
				rank = result.matrix.rank();
			}
		});
		if (cases.length !== 0) {
			return new Expression.Cases(cases);
		}

		return Integer.fromNumber(rank);
	};
	Expression.Determinant = function (matrix) {
		Expression.Function.call(this, "det", matrix);
	};
	Expression.Determinant.prototype = Object.create(Expression.Function.prototype);

	function isSquareMatrix(x) {
		if (x instanceof Expression.Matrix && x.matrix.isSquare()) {
			return true;
		}
		if (x instanceof Expression.Exponentiation && x.a instanceof Expression.MatrixSymbol && isIntegerOrN(x.b)) {
			return true;
		}
		return false;
	}

	Expression.prototype.determinant = function () {
		var x = this;
		if (x instanceof Expression.Multiplication && (isSquareMatrix(x.a) || isSquareMatrix(x.b))) {

			if (Expression.callback != undefined) {
				Expression.callback(new Expression.Event("property-determinant-of-multiplication", {matrix: "{{0}}"}));
			}
			return x.a.determinant().multiply(x.b.determinant());
		}
		if (x instanceof Expression.Exponentiation && x.a instanceof Expression.MatrixSymbol && isIntegerOrN(x.b)) {

			if (Expression.callback != undefined) {
				Expression.callback(new Expression.Event("property-determinant-of-multiplication", {matrix: "{{0}}"}));
			}
			return x.a.determinant().pow(x.b);
		}
		if (x instanceof Expression.MatrixSymbol) {
			return new Expression.Determinant(x);
		}
		if (isMatrixSymbolTranspose(x)) {
			return x.transpose().determinant();
		}
		if (!(x instanceof Expression.Matrix)) {
			throw new RangeError("NotSupportedError:matrixArgExpected");
		}

		if (Expression.callback != undefined) {
			Expression.callback(new Expression.Event(x.matrix.getDeterminantEventType("determinant").type, x));
		}
		return x.matrix.determinant();
	};

	function isMatrix(x) {
		if (x instanceof Expression.Matrix) {
			return true;
		}
		if (x instanceof Expression.MatrixSymbol) {
			return true;
		}

		return false;
	}

	Expression.prototype.trace = function () {
		var x = this;
		if (x instanceof Expression.Addition && isMatrix(x.a) && isMatrix(x.b)) {
			return x.a.trace().add(x.b.trace());
		}
		if (x instanceof Expression.Multiplication && isScalar(x.a) && isMatrix(x.b)) {
			return x.a.multiply(x.b.trace());
		}
		if (x instanceof Expression.MatrixSymbol) {
			return new Expression.Function("trace", x);
		}
		if (isMatrixSymbolTranspose(x)) {
			return x.transpose().trace();
		}
		if (!(x instanceof Expression.Matrix)) {

			throw new RangeError("NotSupportedError:matrixArgExpected");
		}
		return x.matrix.trace();
	};
	Expression.RowReduce = function (matrix) {
		Expression.Function.call(this, "row-reduce", matrix);
	};
	Expression.RowReduce.prototype = Object.create(Expression.Function.prototype);
	Expression.prototype.rowReduce = function () {
		var x = this;
		if (!(x instanceof Expression.Matrix)) {
			throw new RangeError("NotSupportedError:matrixArgExpected");
		}

		if (Expression.callback != undefined) {
			Expression.callback(new Expression.Event("row-reduce".type, x));
		}

		return new Expression.Matrix(x.matrix.toRowEchelon(Matrix.GaussJordan, "", null).matrix);
	};
	Expression.Transpose = function (matrix) {
		Expression.Function.call(this, "transpose", matrix);
	};
	Expression.Transpose.prototype = Object.create(Expression.Function.prototype);
	Expression.prototype.transpose = function () {
		var x = this;
		if (x instanceof Expression.Multiplication) {

			if (Expression.callback != undefined) {
				Expression.callback(new Expression.Event("property-transpose-of-multiplication", {matrix: "{{0}}"}));
			}
			return x.b.transpose().multiply(x.a.transpose());
		}
		if (x instanceof Expression.Addition) {
			return x.a.transpose().add(x.b.transpose());
		}
		if (isScalar(x)) {
			return x;
		}
		if (!(getBase(x) instanceof MatrixSymbol) && x instanceof Expression.Exponentiation && x.b.equals(Expression.ONE.negate())) {

			return x.a.transpose().pow(x.b);
		}
		if (x instanceof Expression.Exponentiation && x.b.equals(new Expression.Symbol("T"))) {

			return x.a;
		}
		if (getBase(x) instanceof MatrixSymbol) {
			var e = getExponent(x).multiply(new Expression.Symbol("T"));

			var p = Polynomial.toPolynomial(e, new Expression.Symbol("T"));
			if (p.getDegree() >= 2) {
				e = e.subtract(p.getCoefficient(2).multiply(new Expression.Symbol("T")._pow(2))).add(p.getCoefficient(2));
			}
			return new Expression.Exponentiation(getBase(x), e);
		}
		if (!(x instanceof Expression.Matrix)) {
			throw new RangeError("NotSupportedError");
		}
		return new Expression.Matrix(x.matrix.transpose());
	};
	Expression.Adjugate = function (matrix) {
		Expression.Function.call(this, "adjugate", matrix);
	};
	Expression.Adjugate.prototype = Object.create(Expression.Function.prototype);
	Expression.prototype.adjugate = function () {
		var x = this;
		var property = function () {

			if (Expression.callback != undefined) {
				Expression.callback(new Expression.Event("property-adjugate-of-multiplication", {matrix: "{{0}}"}));
			}
		};
		if (x instanceof Expression.Multiplication && (isSquareMatrix(x.a) || isSquareMatrix(x.b))) {
			property();
			return x.b.adjugate().multiply(x.a.adjugate());
		}
		if (x instanceof Expression.Exponentiation && x.a instanceof Expression.MatrixSymbol && isIntegerOrN(x.b)) {
			property();
			return x.a.adjugate().pow(x.b);
		}
		if (isMatrixSymbolTranspose(x)) {
			property();
			return x.transpose().adjugate().transpose();
		}
		if (x instanceof Expression.MatrixSymbol) {

			return x.determinant().multiply(x.inverse());

		}
		if (!(x instanceof Expression.Matrix)) {
			throw new RangeError("NotSupportedError:matrixArgExpected");
		}
		if (Expression.callback != undefined) {
			Expression.callback(new Expression.Event("adjugate", x));
		}
		if (x.matrix.rows() === 1 && x.matrix.cols() === 1) {
			return new Expression.Matrix(Matrix.I(1));
		}
		var det = x.matrix.determinant();
		if (Expression.isScalar(det) && !det.equals(Expression.ZERO)) {
			return new Expression.Matrix(x.matrix.inverse().scale(det));
		}

		var C = x.matrix.map(function (element, i, j, matrix) {
			return ((i + j) - 2 * Math.floor((i + j) / 2) === 1 ? Expression.ONE.negate() : Expression.ONE).multiply(matrix.minorMatrix(i, j).determinant());
		});
		var CT = new Expression.Matrix(C.transpose());
		return CT;
	};

	Expression.NoAnswerExpression = function (matrix, name, second) {
		Expression.Function.call(this, name, matrix);
		this.second = second;
	};
	Expression.NoAnswerExpression.prototype = Object.create(Expression.Function.prototype);

	Expression.prototype.transformNoAnswerExpression = function (name, second) {
		second = second == undefined ? undefined : second;

		if (name.startsWith('polynomial-')) {
			var p = this;
			return new Expression.NoAnswerExpression(new Expression.Matrix(Matrix.I(1).map(function () {
				return p;
			})), name, second != undefined ? new Expression.Matrix(Matrix.I(1).map(function () {
				return second;
			})) : second);
		}

		if (!(this instanceof Expression.Matrix)) {
			throw new RangeError("NotSupportedError");
		}
		if (name === "solve") {
			if (Expression.callback != undefined) {
				Expression.callback(new Expression.Event("solve", this));
			}
		}
		return new Expression.NoAnswerExpression(this, name, second);
	};

	Expression.NoAnswerExpression.prototype.multiply = function () {
		throw new RangeError("NotSupportedError");
	};
	Expression.NoAnswerExpression.prototype.add = function () {
		throw new RangeError("NotSupportedError");
	};

	Expression.NoAnswerExpression.prototype.toString = function (options) {
		if (this.second == undefined) {
			return Expression.Function.prototype.toString.call(this, options);
		}
		return this.a.toString(setTopLevel(true, options)) + " " + this.name + " " + this.second.toString(setTopLevel(true, options));
	};

	Expression.ElementWisePower = function (a, b) {
		BinaryOperation.call(this, a, b);
	};
	Expression.ElementWisePower.prototype = Object.create(BinaryOperation.prototype);
	Expression.ElementWisePower.prototype.getS = function () {
		return ".^";
	};
	Expression.prototype.elementWisePower = function (e) {
		if (!(this instanceof Expression.Matrix)) {
			throw new RangeError("NotSupportedError");
		}
		return new Expression.Matrix(this.matrix.map(function (element, i, j) {
			return element.pow(e);
		}));
	};

	Expression.prototype.isRightToLeftAssociative = function () {
		var x = this;
		if (x instanceof Integer) {
			return x.compareTo(Expression.ZERO) < 0;
		}
		if (x instanceof Negation) {
			return true;
		}
		if (x instanceof BinaryOperation) {
			if (x.isNegation()) {
				return true;
			}
			return x instanceof Exponentiation;
		}
		return false;
	};

	var integerPrimeFactor = function (n) {
		return Integer.fromBigInt(primeFactor(n.value));
	};

	var simpleDivisor = function (e) {
		if (e instanceof Division) {
			throw new RangeError();
		}
		if (e instanceof Expression.Matrix) {
			throw new RangeError();
		}
		if (e instanceof Expression.Symbol) {
			return e;
		}
		if (e instanceof Integer) {
			var x = e;
			var i = x.compareTo(Expression.ZERO) < 0 ? x.negate() : x;
			if (i.compareTo(Expression.ONE) > 0) {
				return integerPrimeFactor(i);
			}
			return null;
		}
		if (e instanceof Expression.Complex) {

			var f = e.primeFactor();
			if (!f.equals(e) && e.divide(f) instanceof Expression.Integer) {
				f = f.multiply(Expression.I);
			}
			return f;

		}

		var v = getVariableInternal(getLastMultiplicationOperand(getFirstAdditionOperand(e))).next().value.v;

		if (v instanceof NthRoot && v.a instanceof Integer && v.n === 2) {
			var p = getPolynomialRelativeToNthRoot(e, v.a, v.n);
			var f = p.getContent();
			if (!f.equals(Expression.ONE) && !f.equals(Expression.ONE.negate())) {
				return simpleDivisor(f);
			}
		}
		if (v != undefined) {
			v = getVariable(v);
			var r = getReplacement(e, v);
			if (!r.equals(v)) {
				return substitute(simpleDivisor(substitute(e, v, r, inverseReplacement(r, v))), v, inverseReplacement(r, v), r);
			}

			var np = Polynomial.toPolynomial(e, v);

			var content = np.getContent();
			var t = simpleDivisor(content);
			if (t != null) {
				return t;
			}
			var c = getConstant(np.getLeadingCoefficient());
			if (c instanceof Expression.Complex && c.real.equals(Expression.ZERO)) {
				return Expression.I;
			}

			if (np.getCoefficient(0).equals(Expression.ZERO)) {
				return v;
			}

			if (np.getDegree() >= 2) {

				var root = np.doRationalRootTest();
				if (root != null) {
					var t = v.multiply(root.getDenominator()).subtract(root.getNumerator());
					return t;
				}
			}

			if (np.getDegree() >= 2 && np._hasIntegerLikeCoefficients()) {

				var t = np.factorize();
				if (t != null) {

					return simpleDivisor(t.calcAt(v));
				}
			}

			if (np.getDegree() >= 2 && !np._hasIntegerLikeCoefficients()) {

				var t = np.squareFreeFactors();
				if (t.a0.getDegree() !== 0) {

					return t.a0.scale(t.a0.getLeadingCoefficient().inverse()).calcAt(v);
				}
			}

			e = np.calcAt(v);
			if (e.isNegative()) {
				e = e.negate();
			}
			return e;
		}
		throw new RangeError();
	};
	Expression.simpleDivisor = simpleDivisor;

	Expression.everyDivisor = function (e, callback) {
		if (e.equals(Expression.ZERO)) {
			return true;
		}
		if (!callback(Expression.ONE)) {
			return false;
		}
		var divisors = [];
		var rec = function (start, n, s) {
			if (n >= 0) {
				var x = divisors[n];
				for (var i = start; i <= x.e; i += 1) {
					if (!rec(0, n - 1, s.multiply(Expression.pow(x.d, i)))) {
						return false;
					}
				}
			} else {
				if (!callback(s)) {
					return false;
				}
			}
			return true;
		};
		while (!e.equals(Expression.ONE) && !e.equals(Expression.ONE.negate())) {
			var d = simpleDivisor(e);
			if (divisors.length === 0 || !divisors[divisors.length - 1].d.equals(d)) {
				divisors.push({
					d: d,
					e: 0
				});
			}
			divisors[divisors.length - 1].e += 1;
			if (!rec(divisors[divisors.length - 1].e, divisors.length - 1, Expression.ONE)) {
				return false;
			}
			e = e.divide(d);
		}
		return true;
	};

	Expression.Integer = Integer;
	Expression.NthRoot = NthRoot;
	Expression.SquareRoot = SquareRoot;
	Expression.Negation = Negation;
	Expression.Subtraction = Subtraction;
	Expression.BinaryOperation = BinaryOperation;
	Expression.Exponentiation = Exponentiation;
	Expression.Multiplication = Multiplication;
	Expression.Addition = Addition;
	Expression.Division = Division;

	Expression.pow = function (x, count) {
		return x._pow(count);
	};
	Expression.prototype._pow = function (count) {
		return pow(this, count, Expression.ONE);
	};
	Expression.Integer.prototype._pow = function (count) {

		if (typeof count === "number" && Math.floor(count) === count && count >= 0 && count <= Number.MAX_SAFE_INTEGER) {
			return new Integer(SmallBigInt.exponentiate(this.value, SmallBigInt.BigInt(count)));
		}
		return Expression.prototype._pow.call(this, count);
	};
	Expression.Integer.prototype._nthRoot = function (n) {

		if (typeof n === "number" && n === 2 && this.equals(this.abs()) && isPerfectSquare(this)) {
			return this._integerNthRoot(2);
		}
		if (typeof n === "number" && n === 3 && isPerfectCube(this)) {
			return this._integerNthRoot(3);
		}

		if (typeof n === "number" && n === 2 && this.equals(this.abs())) {

			var x = this;
			var a = Expression.ONE;
			var s = Expression.ONE;
			while (!isPerfectSquare(x)) {
				var f = Integer.fromBigInt(primeFactor(x.toBigInt()));
				var multiplicity = primeFactor._countTrailingZeros(x.toBigInt(), f.toBigInt());
				x = x.divide(f._pow(multiplicity));
				if (multiplicity % 2 === 1) {

					s = s.multiply(f);
					multiplicity -= 1;
				}
				a = a.multiply(f._pow(multiplicity / 2));
			}
			return x.squareRoot().multiply(a).multiply(new SquareRoot(s));
		}
		return Expression.prototype._nthRoot.call(this, n);
	};
	Expression.Integer.prototype._isPerfectSquare = function () {
		if (this.sign() < 0) {
			return false;
		}
		return isPerfectSquare(this);
	};
	Integer.prototype._integerNthRoot = function (n) {
		return new Integer(SmallBigInt.BigInt(primeFactor._integerNthRoot(this.toBigInt(), n)));
	};
	Integer.prototype.bitLength = function () {
		return primeFactor._bitLength(this.toBigInt());
	};
	Integer.prototype.modInverse = function (p) {
		return Expression.Integer.fromBigInt(primeFactor._modInverse(this.toBigInt(), p.toBigInt()));
	};
	Integer.prototype.modulo = function modulo(p) {
		var r = this.remainder(p);
		return r.compareTo(Expression.ZERO) < 0 ? r.add(p) : r;
	};
	Integer.prototype.roundMod = function (m) {
		var c = this;
		var r1 = c.modulo(m);
		var r2 = r1.subtract(m);
		return r2.add(r1).compareTo(Expression.ZERO) < 0 ? r1 : r2;
	};

	Expression.Equality = function (a, b) {
		BinaryOperation.call(this, a, b);
	};

	Expression.Equality.prototype = Object.create(BinaryOperation.prototype);
	Expression.Equality.prototype.getS = function () {
		return "=";
	};

	Expression.Inequality = function (a, b, sign) {
		BinaryOperation.call(this, a, b);
		this.sign = sign;
	};

	Expression.Inequality.prototype = Object.create(BinaryOperation.prototype);
	Expression.Inequality.prototype.getS = function () {
		return this.sign;
	};

	function AdditionIterator(e) {
		if (e == undefined) {
			throw new TypeError();
		}
		this.value = undefined;
		this.e = e;
	}

	AdditionIterator.prototype = Object.create(Iterator.prototype);
	AdditionIterator.prototype.next = function () {
		this.value = this.e instanceof Addition ? this.e.b : this.e;
		this.e = this.e instanceof Addition ? this.e.a : undefined;
		return this;
	};

	function MultiplicationIterator(e) {
		if (e == undefined) {
			throw new TypeError();
		}
		this.value = undefined;
		this.e = e;
	}

	MultiplicationIterator.prototype = Object.create(Iterator.prototype);
	MultiplicationIterator.prototype.next = function () {
		this.value = this.e instanceof Multiplication ? this.e.b : this.e;
		this.e = this.e instanceof Multiplication ? this.e.a : null;
		return this;
	};

	Expression.prototype.summands = function () {
		return new AdditionIterator(this);
	};

	Expression.prototype.factors = function () {
		return new MultiplicationIterator(this);
	};

	var splitX = function (e) {
		var scalar = undefined;
		var l = undefined;
		var r = undefined;
		var xx = undefined;
		for (var iteratorx = e.summands()[globalThis.Symbol.iterator](), x = iteratorx.next().value; x != null; x = iteratorx.next().value) {

			var state = 0;
			for (var iteratory = x.factors()[globalThis.Symbol.iterator](), y = iteratory.next().value; y != null; y = iteratory.next().value) {
				var factor = y;
				var factorBase = getBase(y);
				var factorExponent = getExponent(y);

				var s = factorBase instanceof Expression.Symbol ? factorBase.toString() : "";
				if (s === "X" && state === 0) {
					state = 1;
					xx = factor;
				} else {
					if (isScalar(factor)) {
						scalar = scalar == undefined ? factor : factor.multiply(scalar);
					} else {
						if (state === 0) {
							r = r == undefined ? factor : factor.multiply(r);
						}
						if (state === 1) {
							l = l == undefined ? factor : factor.multiply(l);
						}
					}
				}
			}
		}
		scalar = scalar == undefined ? Expression.ONE : scalar;
		return {
			s: scalar,
			l: l,
			r: r,
			x: xx
		};
	};
	Expression.splitX = splitX;
	var groupX = function (a, b) {
		var tmp1 = splitX(a);
		var tmp2 = splitX(b);
		var s1 = tmp1.s;
		var l1 = tmp1.l;
		var r1 = tmp1.r;
		var s2 = tmp2.s;
		var l2 = tmp2.l;
		var r2 = tmp2.r;
		if (r1 == undefined && r2 == undefined && tmp1.x.equals(tmp2.x)) {
			l1 = l1 == undefined ? new IdentityMatrix("I") : l1;
			l2 = l2 == undefined ? new IdentityMatrix("I") : l2;
			return new Multiplication(s1.multiply(l1).add(s2.multiply(l2)), tmp1.x);
		}
		if (l1 == undefined && l2 == undefined && tmp1.x.equals(tmp2.x)) {
			r1 = r1 == undefined ? new IdentityMatrix("I") : r1;
			r2 = r2 == undefined ? new IdentityMatrix("I") : r2;
			return new Multiplication(tmp1.x, s1.multiply(r1).add(s2.multiply(r2)));
		}
		return undefined;
	};

	var getExpressionWithX = function (e) {
		if (e instanceof Division) {
			if (e.getDenominator() instanceof Expression.Integer) {
				e = e.getNumerator();
			} else {
				return {
					withX: undefined,
					withoutX: undefined
				};
			}
		}

		var withX = undefined;
		var withoutX = undefined;
		for (var iteratorx = e.summands()[globalThis.Symbol.iterator](), x = iteratorx.next().value; x != null; x = iteratorx.next().value) {
			var summand = x;
			var hasX = false;
			for (var iteratory = x.factors()[globalThis.Symbol.iterator](), y = iteratory.next().value; y != null; y = iteratory.next().value) {
				var factor = y;
				var factorBase = getBase(factor);

				if (factorBase instanceof Addition && getExponent(factor).isNegative()) {

					var q = null;
					for (var iteratorx1 = e.summands()[globalThis.Symbol.iterator](), x1 = iteratorx1.next().value; x1 != null; x1 = iteratorx1.next().value) {
						if (x1 !== x) {
							q = q == null ? x1 : q.add(x1);
						}
					}
					var exponent = getExponent(factor).negate();
					var e1 = q.multiply(factorBase.pow(exponent)).add(x.multiply(new Expression.Exponentiation(factorBase, exponent)));
					var z2 = e1.transformEquality(Expression.ZERO);

					var variable = getExponent(z2.a) instanceof Expression.Symbol ? z2.a : getBase(z2.a);
					var tmp = Polynomial.toPolynomial(factorBase, variable).divideAndRemainder(Polynomial.toPolynomial(z2.a.subtract(z2.b), variable)).remainder.calcAt(variable);
					var d = tmp instanceof Expression.Matrix ? tmp.determinant() : null;
					if (!Expression.isConstant(d)) {
						return {
							withX: undefined,
							withoutX: undefined
						};
					}
					if (d.equals(Expression.ZERO)) {
						return {
							withX: Expression.ZERO,
							withoutX: Expression.ONE
						};
					}
					return getExpressionWithX(e1);
				}

				if (factorBase instanceof MatrixSymbol && getExponent(factor).isNegative()) {
					var exponent = getExponent(factor).negate();

					var e1 = x.b.equals(factor) ? e.multiply(factorBase.pow(exponent)) : (Array.from(factorBase.pow(exponent).multiply(x).factors()).length < Array.from(x.factors()).length ? factorBase.pow(exponent).multiply(e) : null);

					if (e1 != null) {
						return getExpressionWithX(e1);
					}
				}
				if (factorBase instanceof Expression.Division) {
					if (factorBase.getDenominator() instanceof Expression.Integer) {
						return getExpressionWithX(factorBase.getDenominator().multiply(e));
					}
				}

				if (!(factorBase instanceof Integer) && !(factorBase instanceof Expression.Symbol)) {
					if (!(factorBase instanceof Expression.Matrix)) {
						if (!(factorBase instanceof NthRoot)) {
							if (factorBase instanceof Expression.Determinant && factorBase.a.toString() === "X") {
								return {
									withX: null,
									withoutX: null
								};
							}
							if (factorBase instanceof Expression.Function && factorBase.name === 'trace' && factorBase.a.toString() === "X") {
								return {
									withX: null,
									withoutX: null
								};
							}
							if (Expression.has(factorBase, Expression.MatrixSymbol)) {
								throw new RangeError("NotSupportedError");
							}
						}
					}
				}
				if (factorBase instanceof Expression.Symbol) {
					var s = factorBase.toString();
					if (s === "X") {
						if (hasX) {

							return {
								withX: null,
								withoutX: null
							};
						}
						hasX = true;
					}
				}
			}
			if (hasX) {
				if (withX != undefined) {
					withX = groupX(withX, summand);
					if (withX == null) {

						return {
							withX: null,
							withoutX: null
						};
					}

				} else {
					withX = summand;
				}
			}
			if (!hasX) {
				withoutX = withoutX == undefined ? summand.negate() : withoutX.subtract(summand);
			}
		}
		return {
			withX: withX,
			withoutX: withoutX
		};
	};

	var isConstant = function (e) {
		if (e instanceof Expression.BinaryOperation) {
			return isConstant(e.b) && isConstant(e.a);
		} else if (e instanceof Expression.Integer) {
			return true;
		} else if (e instanceof Expression.PolynomialRootSymbol) {
			return true;
		} else if (e instanceof Expression.ExpressionWithPolynomialRoot) {
			return isConstant(e.e);
		} else if (e instanceof Expression.ExpressionPolynomialRoot) {
			return true;
		} else if (e instanceof Expression.Symbol) {
			return e === Expression.E || e === Expression.PI;
		} else if (e instanceof Expression.Complex) {
			return true;
		} else if (e instanceof Expression.NthRoot) {
			return isConstant(e.a);
		} else if (e instanceof Expression.Sin || e instanceof Expression.Cos || e instanceof Expression.Arctan) {
			return isConstant(e.a);
		} else if (e instanceof Expression.Radians) {
			return isConstant(e.value);

		} else if (e instanceof Expression.Logarithm) {
			return isConstant(e.a);
		} else if (e === Expression.E || e === Expression.PI) {
			return true;
		}
		return false;
	};

	Expression.isConstant = isConstant;

	Expression.getMultivariatePolynomial = function (e) {
		if (e instanceof Expression.Division) {
			return undefined;
		}

		var v = getVariableInternal(getLastMultiplicationOperand(getFirstAdditionOperand(e))).next().value.v;
		if (v instanceof NthRoot || v instanceof Integer || v instanceof Expression.Complex) {
			v = undefined;
		}
		if (v == undefined) {

			return undefined;
		}

		if (v instanceof Expression.Addition) {
			v = getVariableInternal(getLastMultiplicationOperand(getFirstAdditionOperand(v))).next().value.v;
		}

		var r = getReplacement(e, v);
		if (!r.equals(v)) {
			e = substitute(e, v, r, inverseReplacement(r, v));
			if (e instanceof Expression.Division && e.b instanceof Expression.Integer) {
				e = e.a;
			}
		}

		var p = Polynomial.toPolynomial(e, v);
		if (p.getDegree() === 0) {
			console.warn('Expression.getMultivariatePolynomial');
			return undefined;
		}

		for (var i = 0; i <= p.getDegree(); i += 1) {
			var c = p.getCoefficient(i);
			if (!isConstant(c)) {
				var pc = Expression.getMultivariatePolynomial(c);
				if (pc == undefined) {
					return undefined;
				}
			}
		}
		return {
			p: p.map(function (c) {
				return substitute(c, v, inverseReplacement(r, v), r);
			}),
			v: inverseReplacement(r, v)
		};
	};
	Expression.isSingleVariablePolynomial = function (e) {
		var tmp = Expression.getMultivariatePolynomial(e);
		if (tmp == null) {
			return false;
		}
		var p = tmp.p;

		for (var i = 0; i <= p.getDegree(); i += 1) {
			var c = p.getCoefficient(i);
			if (!isConstant(c)) {
				return false;
			}
		}
		return true;
	};

	Expression.prototype.transformEquality = function (b) {
		var e = this.subtract(b);
		var tmp = getExpressionWithX(e);
		var withX = tmp.withX;
		var withoutX = tmp.withoutX;
		if (withX == undefined) {
			if (e.getDenominator() instanceof Integer && !(e.getNumerator() instanceof Expression.Matrix) && !Expression.has(e, Expression.MatrixSymbol) && !e.equals(Expression.ZERO)) {
				if (typeof e.upgrade === "function") {
					e = e.upgrade();
				}

				var tmpv = new Expression.Symbol('x');
				var tmp = {
					p: Polynomial.toPolynomial(e.getNumerator(), tmpv),
					v: tmpv
				};
				if (tmp.p.getDegree() === 0 || Expression.has(e, Expression.Function)) {
					tmp = Expression.getMultivariatePolynomial(e.getNumerator());
				}
				if (tmp != undefined && tmp.v instanceof Expression.Symbol) {
					var p = tmp.p;
					var v = tmp.v;
					var m = Matrix.Zero(1, p.getDegree() + 1).map(function (e, i, j) {
						return p.getCoefficient(p.getDegree() - j);
					});
					return new Expression.NoAnswerExpression(new Expression.Matrix(m), "polynomial-roots", {
						polynomial: p,
						variable: v
					});
				}
			}
			if (e instanceof Expression.Matrix) {
				if (this instanceof Expression.Matrix && (b instanceof Expression.Matrix || b instanceof Expression.IdentityMatrix)) {
					return Expression.SystemOfEquations.from([{
						left: this,
						right: b
					}]);
				}

			}
			if (true) {

				return Expression.SystemOfEquations.from([{
					left: this,
					right: b
				}]);
			}
			throw new RangeError("NotSupportedError");
		}

		if (withoutX == undefined) {
			withoutX = Expression.ZERO;
		}

		var left = withX;
		var right = withoutX;

		var isToTheLeft = false;
		var x = withX;
		for (var iteratory = x.factors()[globalThis.Symbol.iterator](), y = iteratory.next().value; y != null; y = iteratory.next().value) {
			var factor = y;
			var factorBase = getBase(factor);

			var isX = false;
			if (factorBase instanceof Expression.Symbol) {
				var s = factorBase.toString();
				if (s === "X") {
					isX = true;
					isToTheLeft = true;
				}
			}
			if (!isX) {
				if (factor instanceof Expression.Matrix && (!(factor.matrix.cols() === factor.matrix.rows()) || factor.determinant().equals(Expression.ZERO))) {

					return Expression.SystemOfEquations.from([{
						left: withX,
						right: withoutX
					}]);
				}
				var f = factor.inverse();

				if (isToTheLeft) {
					right = f.multiply(right);

				} else {
					right = right.multiply(f);

				}
			} else {
				left = factor;
			}
		}

		if (left instanceof Expression.Exponentiation && getExponent(left).equals(Expression.ONE.negate())) {
			if (right instanceof Expression.Matrix && !right.determinant().equals(Expression.ZERO)) {
				left = left.inverse();
				right = right.inverse();

			}
		}
		return new Expression.Equality(left, right);
	};

	Expression.prototype.transformInequality = function (b, sign) {
		var a = this;

		return new Expression.Inequality(a, b, sign);
	};

	Expression.simplifications = [];
	Expression.prototype.simplifyExpression = function () {
		var e = this;
		for (var i = 0; i < Expression.simplifications.length; i += 1) {
			e = Expression.simplifications[i](e);
		}
		return e;
	};

	Expression.prototype.isExact = function () {

		if (this instanceof Integer) {
			return true;
		}
		if (this instanceof Multiplication) {
			return this.a.isExact() && this.b.isExact();
		}
		if (this instanceof Addition) {
			return this.a.isExact() && this.b.isExact();
		}
		if (this instanceof Exponentiation) {
			return getBase(this).isExact() && getExponent(this).isExact();
		}

		if (!Expression.has(this, Expression.PolynomialRootSymbol) && !Expression.has(this, Expression.ExpressionPolynomialRoot)) {
			return true;
		}
		return false;
	};

	Expression.PI = new Expression.Symbol("\u03C0");
	Expression.E = new Expression.Symbol("\u2147");
	Expression.I = new Expression.Symbol("\u2148");

	Expression.CIRCLE = new Expression.Symbol("○");
	Expression.INFINITY = new Expression.Symbol("∞");

	Expression.prototype.addPosition = function () {
		return this;
	};

	Expression.SystemOfEquations = function (equations) {
		throw new TypeError();
		this.equations = equations;
	};
	Expression.SystemOfEquations.from = function (equations) {
		return new Expression.NoAnswerExpression({matrix: null}, "system-of-equations", {equations: equations});
	};

	Expression.ExponentiationOfMinusOne = function (x, y) {
		Expression.Exponentiation.call(this, x, y);
	};
	Expression.ExponentiationOfMinusOne.prototype = Object.create(Expression.Exponentiation.prototype);
	Expression.ExponentiationOfMinusOne.prototype.divideExpression = function (x) {
		return x.multiply(this);
	};

	Expression.ExponentiationOfImaginaryUnit = function (x, y) {
		Expression.Exponentiation.call(this, x, y);
	};
	Expression.ExponentiationOfImaginaryUnit.prototype = Object.create(Expression.Exponentiation.prototype);
	Expression.ExponentiationOfImaginaryUnit.prototype.divideExpression = function (x) {
		var c = getConjugate(getBase(this)).pow(getExponent(this));
		return x.multiply(c).divide(this.multiply(c));
	};

	Expression.ExponentiationOfQuadraticInteger = function (x, y) {
		Expression.Exponentiation.call(this, x, y);
	};
	Expression.ExponentiationOfQuadraticInteger.prototype = Object.create(Expression.ExponentiationOfImaginaryUnit.prototype);
	Expression.ExponentiationOfQuadraticInteger.prototype.divideExpression = function (x) {
		return Expression.Exponentiation.prototype.divideExpression.call(this, x);
	};

	Expression.Division.prototype.negate = function () {
		return new Expression.Division(this.a.negate(), this.b);
	};

	Expression.Polynomial = function (polynomial) {
		this.polynomial = polynomial;
	};
	Expression.Polynomial.prototype = Object.create(Expression.prototype);
	Expression.Polynomial.prototype.gcd = function (other) {
		if (other instanceof Expression.Polynomial) {
			return new Expression.Polynomial(Polynomial.polynomialGCD(this.polynomial, other.polynomial));
		}
		if (other.equals(Expression.ZERO)) {
			return this;
		}
		throw new TypeError();
	};
	Expression.Polynomial.prototype.equals = function (y) {
		return y.equalsPolynomial(this);
	};
	Expression.Polynomial.prototype.equalsPolynomial = function (x) {

		return x.polynomial.equals(this.polynomial);
	};
	Expression.prototype.equalsPolynomial = function (x) {
		return (x.polynomial.equals(Polynomial.ZERO) && this.equals(Expression.ZERO)) || (x.polynomial.getDegree() === 0 && this.equals(x.polynomial.getCoefficient(0)));
	};
	Expression.Polynomial.prototype.multiply = function (p) {
		if (p === Expression.ONE) {
			return this;
		}
		return p.multiplyPolynomial(this);
	};
	Expression.Polynomial.prototype.multiplyPolynomial = function (x) {
		return new Expression.Polynomial(x.polynomial.multiply(this.polynomial));
	};
	Expression.Division.prototype.multiplyPolynomial = function (p) {
		return this.multiplyExpression(p);
	};
	Expression.Integer.prototype.multiplyPolynomial = function (p) {
		return new Expression.Polynomial(p.polynomial.scale(this));
	};
	Expression.Polynomial.prototype.multiplyInteger = function (x) {
		return new Expression.Polynomial(this.polynomial.scale(x));
	};
	Expression.Polynomial.prototype.divide = function (l) {
		if (l.equals(Expression.ONE)) {
			return this;
		}
		if (l.equals(Expression.ONE.negate())) {
			return this.negate();
		}
		if (l instanceof Expression.Integer) {
			return new Expression.Polynomial(this.polynomial.scale(l.inverse()));
		}
		return l.dividePolynomial(this);
	};

	Expression.Division.prototype.dividePolynomial = function (p) {
		return this.divideExpression(p);
	};
	Expression.Polynomial.prototype.dividePolynomial = function (x) {
		var y = this;
		var a = x.polynomial;
		var b = y.polynomial;
		if (a.getDegree() < 0 && b.getDegree() >= 0) {
			return new Expression.Polynomial(a);
		}

		var tmp = a.divideAndRemainder(b);
		if (tmp.remainder.equals(Polynomial.ZERO)) {
			return new Expression.Polynomial(tmp.quotient);
		}
		var ca = a.getContent();
		if (!ca.getDenominator().equals(Expression.ONE)) {
			return y.multiply(ca.getDenominator()).dividePolynomial(x.multiply(ca.getDenominator()));
		}
		var cb = b.getContent();
		if (!cb.getDenominator().equals(Expression.ONE)) {
			return y.multiply(cb.getDenominator()).dividePolynomial(x.multiply(cb.getDenominator()));
		}
		var gcd = Polynomial.polynomialGCD(a, b);

		if (y.polynomial.equals(gcd)) {
			return new Expression.Polynomial(x.polynomial.divideAndRemainder(gcd).quotient);
		}
		return new Expression.Division(new Expression.Polynomial(x.polynomial.divideAndRemainder(gcd).quotient), new Expression.Polynomial(y.polynomial.divideAndRemainder(gcd).quotient));
	};
	Expression.Polynomial.prototype.negate = function () {
		return new Expression.Polynomial(this.polynomial.negate());
	};
	Expression.Polynomial.prototype.add = function (y) {
		return y.addPolynomial(this);
	};
	Expression.Polynomial.prototype.addPolynomial = function (x) {
		return new Expression.Polynomial(x.polynomial.add(this.polynomial));
	};
	Expression.prototype.addPolynomial = function (x) {
		if (this.equals(Expression.ZERO)) {
			return x;
		}
		throw new RangeError();
	};
	Expression.Polynomial.prototype.getPrecedence = function () {
		var d = this.polynomial.getDegree();
		var count = 0;
		for (var i = 0; i <= d; i += 1) {
			if (!this.polynomial.getCoefficient(i).equals(Expression.ZERO)) {
				count += 1;
			}
		}
		return (count < 2 ? (this.polynomial.getLeadingCoefficient().equals(Expression.ONE) ? new Expression.Symbol("x") : new Expression.Multiplication(Expression.ONE, Expression.ONE)) : new Expression.Addition(Expression.ONE, Expression.ONE)).getPrecedence();
	};
	Expression.Polynomial.prototype.modulo = function (p) {
		if (p instanceof Expression.Polynomial) {
			return new Expression.Polynomial(this.polynomial.divideAndRemainder(p.polynomial).remainder);
		}
		throw new TypeError();
	};
	Expression.Polynomial.prototype.modInverse = function (p) {
		if (p instanceof Expression.Polynomial) {
			return new Expression.Polynomial(this.polynomial.primitivePart().modularInverse(p.polynomial).primitivePart().scale(this.polynomial.getContent().inverse()));
		}
		throw new TypeError();
	};
	Expression.Polynomial.prototype.isDivisibleBy = function (other) {
		if (other instanceof Expression.Polynomial) {
			return this.polynomial.isDivisibleBy(other.polynomial);
		}
		throw new TypeError();
	};

	Expression.unique = function (array) {
		var result = [];
		for (var i = 0; i < array.length; i += 1) {
			var value = array[i];
			var found = false;
			for (var j = 0; j < result.length; j += 1) {
				if (result[j] === value) {
					found = true;
				}
			}
			if (!found) {
				result.push(value);
			}
		}
		return result;
	};

	Expression.Multiplication.prototype.compare4Multiplication = function (y) {
		var x = this;
		if (y instanceof Addition) {
			return 0 - y.compare4Multiplication(x);
		}
		var i = x.factors();
		var j = y.factors();
		var a = i.next().value;
		var b = j.next().value;
		while (a != null && b != null) {
			var c = a.compare4Multiplication(b);
			if (c !== 0) {
				return c;
			}
			a = i.next().value;
			b = j.next().value;
		}
		return a != null ? +1 : (b != null ? -1 : 0);
	};

	Expression.Multiplication.compare4Addition = function (x, y) {
		var i = x.factors();
		var j = y.factors();
		var a = i.next().value;
		var b = j.next().value;
		while (a != null && b != null) {
			var c = a.compare4Addition(b);
			if (c !== 0) {
				return c;
			}
			a = i.next().value;
			b = j.next().value;
		}
		return a != null ? +1 : (b != null ? -1 : 0);
	};

	Expression.Multiplication.prototype.compare4MultiplicationSymbol = function (x) {
		return 0 - this.compare4Multiplication(x);
	};

	Expression.Function.prototype.compare4Addition = function (y) {
		if (y instanceof Expression.Function) {
			return this.name < y.name ? -1 : (y.name < this.name ? +1 : this.a.compare4Addition(y.a));
		}
		if (y instanceof Multiplication) {
			var x = this;
			return Multiplication.compare4Addition(x, y);
		}
		if (y instanceof Addition) {
			var x = this;
			return Addition.compare4Addition(x, y);
		}
		return +1;
	};

	Expression.NthRoot.prototype.compare4Addition = function (y) {
		return y.compare4AdditionNthRoot(this);
	};
	Expression.prototype.compare4AdditionNthRoot = function (x) {
		return Expression.Function.prototype.compare4Addition.call(x, this);
	};
	Expression.NthRoot.prototype.compare4AdditionNthRoot = function (x) {
		return (this.n - x.n) || x.a.compare4Addition(this.a);
	};

	Expression.prototype.compare4AdditionSymbol = function (x) {
		var y = this;
		if (y instanceof Expression.Function) {
			return -1;
		}
		return Expression.prototype.compare4Addition.call(x, y);
	};

	Expression.Symbol.prototype.compare4Addition = function (y) {
		return y.compare4AdditionSymbol(this);
	};
	Expression.Symbol.prototype.compare4AdditionSymbol = function (x) {
		var y = this;
		return x.symbol < y.symbol ? -1 : (y.symbol < x.symbol ? +1 : 0);
	};

	Expression.Function.prototype.compare4Multiplication = function (y) {
		if (y instanceof Expression.NthRoot) {
			return +1;
		}
		if (y instanceof Expression.Function) {
			return this.name < y.name ? -1 : (y.name < this.name ? +1 : getBase(this.a).compare4Multiplication(getBase(y.a)) || getExponent(this.a).compare4AdditionSymbol(getExponent(y.a)));
		}
		if (y instanceof Expression.MatrixSymbol) {
			return -1;
		}
		if (y instanceof Expression.Addition) {
			return 0 - y.compare4Multiplication(this);
		}
		return +1;
	};

	Expression.Function.prototype.compare4MultiplicationInteger = function (x) {
		return 0 - this.compare4Multiplication(x);
	};

	Expression.Function.prototype.compare4MultiplicationSymbol = function (x) {
		return -1;
	};

	Expression.Function.prototype.compare4MultiplicationNthRoot = function (x) {
		return 0 - this.compare4Multiplication(x);
	};

	Expression.Function.prototype.pow = function (y) {
		if (this instanceof Expression.NthRoot) {
			return Expression.prototype.pow.call(this, y);
		}
		if (y instanceof Expression.Integer) {
			if (y.compareTo(Expression.ONE) > 0) {
				return new Expression.Exponentiation(this, y);
			}
			return Expression.prototype.pow.call(this, y);
		}
		if (isIntegerOrN(y) && y instanceof Expression.Symbol) {
			return new Expression.Exponentiation(this, y);
		}
		throw new RangeError("NotSupportedError");
	};

	function ExpressionWithCondition(e, condition) {
		this.e = e;
		this.condition = condition;
	}

	ExpressionWithCondition.prototype = Object.create(Expression.prototype);
	ExpressionWithCondition.prototype.toString = function () {
		return this.e.toString() + '; ' + this.condition.toString();
	};
	ExpressionWithCondition.prototype.toMathML = function (options) {
		return this.e.toMathML(options) + '<mtext>; </mtext>' + this.condition.toMathML(options);
	};

	ExpressionWithCondition.prototype.multiplyExpression = ExpressionWithCondition.prototype.multiplyMatrix = function (x) {

		return new ExpressionWithCondition(x.multiply(this.e), this.condition);
	};
	ExpressionWithCondition.prototype.multiply = function (y) {
		return y.multiplyExpressionWithCondition(this);
	};
	ExpressionWithCondition.prototype.multiplyExpressionWithCondition = function (x) {
		throw new TypeError("T0D0:");
	};
	Expression.prototype.multiplyExpressionWithCondition = function (x) {

		return new ExpressionWithCondition(x.e.multiply(this), x.condition);
	};

	ExpressionWithCondition.prototype.add = function (y) {
		return y.addExpressionWithCondition(this);
	};
	ExpressionWithCondition.prototype.addExpressionWithCondition = function (x) {
		throw new TypeError("T0D0:");
	};
	Expression.prototype.addExpressionWithCondition = function (x) {

		return new ExpressionWithCondition(x.e.add(this), x.condition);
	};

	Expression.ExpressionWithCondition = ExpressionWithCondition;

	self.Expression = Expression;

	Addition.prototype.compare4MultiplicationNthRoot = function (x) {

		return 0 - this.compare4Multiplication(x);
	};
	Multiplication.prototype.compare4MultiplicationNthRoot = function (x) {
		return -1;
	};

	function Cases(cases) {
		this.cases = cases;
	}

	Cases.prototype = Object.create(Expression.prototype);

	Cases.prototype._cross = function (x, f) {
		var y = this;
		var result = [];
		for (var i = 0; i < x.cases.length; i += 1) {
			for (var j = 0; j < y.cases.length; j += 1) {
				var condition = x.cases[i].condition.and(y.cases[j].condition);

				if (!condition.isFalse()) {
					var e = f(x.cases[i].e, y.cases[j].e);
					result.push(new ExpressionWithCondition(e, condition));
				}
			}
		}
		return new Expression.Cases(result);
	};

	Cases.prototype.multiply = function (y) {
		return y.multiplyCases(this);
	};
	Cases.prototype.multiplyCases = function (x) {
		return this._cross(x, function (a, b) {
			return a.multiply(b);
		});
	};
	Cases.prototype.toString = function () {
		var s = '';
		for (var i = 0; i < this.cases.length; i += 1) {
			s += '(' + this.cases[i].toString() + ')' + ',';
		}
		return '{{' + s.slice(0, -1) + '}}';
	};
	Expression.prototype.multiplyCases = function (x) {
		var y = this;
		return new Cases(x.cases.map(function (c) {
			return c.multiply(y);
		}));
	};

	Cases.prototype.multiplyExpression = Cases.prototype.multiplyMatrix = function (x) {
		return new Cases(this.cases.map(function (c) {
			return x.multiply(c);
		}));
	};

	Cases.prototype.add = function (y) {
		return y.addCases(this);
	};
	Cases.prototype.addCases = function (x) {
		return this._cross(x, function (a, b) {
			return a.add(b);
		});
	};
	Expression.prototype.addCases = function (x) {
		var y = this;
		return new Cases(x.cases.map(function (c) {
			return c.add(y);
		}));
	};

	Cases.prototype.equals = function (b) {
		var a = this;
		if (a === b) {
			return true;
		}
		if (!(b instanceof Cases)) {

			return false;
		}

		throw new TypeError();

	};

	Cases.prototype.toMathML = function (printOptions) {
		var s = '';
		s += '<mrow>';
		s += '<mo>{</mo>';

		s += '<mtable columnalign="left">';
		for (var i = 0; i < this.cases.length; i += 1) {
			var x = this.cases[i];
			s += '<mtr>';
			s += '<mtd>';
			s += x.e.toMathML(printOptions);
			s += '</mtd>';
			s += '<mtd>';

			s += x.condition.toMathML(printOptions);
			s += '</mtd>';
			s += '</mtr>';
		}
		s += '</mtable>';
		s += '</mrow>';
		return s;
	};

	Expression.Cases = Cases;

	Expression.Factorial = function (n) {
		this.n = n;
	};
	Expression.Factorial.prototype = Object.create(Expression.prototype);

	Expression.prototype.factorial = function () {

		var n = this;
		if (!(n instanceof Expression.Integer)) {
			throw new TypeError("NotSupportedError");
		}
		if (n.compareTo(Expression.ZERO) < 0) {
			throw new TypeError("NotSupportedError");
		}
		var f = Expression.ONE;
		for (var i = n; i.compareTo(Expression.ONE) >= 0; i = i.subtract(Expression.ONE)) {
			f = f.multiply(i);
		}
		return f;
	};

	Expression.prototype._abs = function () {
		return this.isNegative() ? this.negate() : this;
	};

	Expression.Comma = function (a, b) {
		BinaryOperation.call(this, a, b);
	};
	Expression.Comma.prototype = Object.create(BinaryOperation.prototype);
	Expression.Comma.prototype.getS = function () {
		return ",\u200B ";
	};
	Expression.prototype.transformComma = function (b) {
		var a = this;
		var equations = function (e) {
			if (e instanceof Expression.Equality) {
				return [{
					left: e.a,
					right: e.b
				}];
			}
			if (e instanceof Expression.NoAnswerExpression && e.name === 'system-of-equations') {
				return e.second.equations;
			}
			if (e instanceof Expression.Inequality) {
				return [{
					left: e.a,
					right: e.b,
					sign: e.sign
				}];
			}
			if (e instanceof Expression.NoAnswerExpression && e.name === 'polynomial-roots') {
				var ee = e.second.polynomial.calcAt(e.second.variable);

				return [{
					left: ee,
					right: Expression.ZERO
				}];
			}
			return null;
		};
		var ae = equations(a);
		var be = equations(b);

		if (ae != null && be != null) {
			return Expression.SystemOfEquations.from(ae.concat(be));
		}
		if (ae == null && be == null) {
			return new Expression.List((a instanceof Expression.List ? a.list : [a]).concat(b instanceof Expression.List ? b.list : [b]));
		}

		if (ae == null && be != null) {
			if (b instanceof Expression.NoAnswerExpression && b.name === 'polynomial-roots') {
				if (b.second.polynomial.getDegree() === 1) {

					return Expression._substitute(a, b.second.variable, b.second.polynomial.getroots()[0], null);
				}
			}
		}

		throw new TypeError("NotSupportedError");
	};

	Expression.List = function (list) {
		this.list = list;
	};
	Expression.List.prototype = Object.create(Expression.prototype);
	Expression.List.prototype.min = function () {
		return this.list.reduce(function (result, value) {
			return result.compareTo(value) > 0 ? value : result;
		});
	};
	Expression.List.prototype.max = function () {
		return this.list.reduce(function (result, value) {
			return result.compareTo(value) < 0 ? value : result;
		});
	};
	Expression.List.prototype.gcd = function () {
		return this.list.reduce(function (result, value) {
			return result.gcd(value);
		});
	};

	function atan2(y, x) {
		if (x.equals(Expression.ZERO)) {
			if (y.equals(Expression.ZERO)) {
				throw new RangeError();
			}
			var a = Expression.PI.divide(Expression.TWO);
			if (!y.isNegative()) {
				return a;
			}
			return a.negate();
		}
		var a = y.divide(x).arctan();
		if (!x.isNegative()) {
			return a;
		}
		if (!y.isNegative()) {
			return a.add(Expression.PI);
		}
		return a.subtract(Expression.PI);
	}

	Expression.prototype.complexArgument = function () {
		var c = Expression.getComplexNumberParts(this);
		if (c == undefined) {
			throw new TypeError();
		}
		return atan2(c.imaginary, c.real);
	};

	Expression.Logarithm = function (argument) {
		Expression.Function.call(this, "log", argument);
	};
	Expression.Logarithm.prototype = Object.create(Expression.Function.prototype);
	Expression.prototype.logarithm = function () {
		var arg = this;
		if (arg instanceof Expression.Integer) {
			if (arg.compareTo(Expression.ZERO) <= 0) {
				if (arg.compareTo(Expression.ZERO) === 0) {
					throw new TypeError("ArithmeticException");
				}
				if (arg.equals(Expression.ONE.negate())) {

					return Expression.I.multiply(Expression.PI);
				}
				return arg.abs().logarithm().add(arg.divide(arg.abs()).logarithm());
			}
			if (arg.compareTo(Expression.ONE) === 0) {
				return Expression.ZERO;
			}
			var p = integerPrimeFactor(arg);
			if (p.equals(arg)) {
				return new Expression.Logarithm(arg);
			}
			var ctz = primeFactor._countTrailingZeros(arg.toBigInt(), p.toBigInt());
			return p.logarithm().multiply(Integer.fromNumber(ctz)).add(arg.truncatingDivide(p._pow(ctz)).logarithm());
		}
		if (arg instanceof Expression.Division) {
			var n = arg.getNumerator();
			var d = arg.getDenominator();
			if (d instanceof Integer || isConstant(n)) {
				return n.logarithm().subtract(d.logarithm());
			}
		}
		if (arg instanceof Expression.Multiplication) {
			var c = arg.a;
			if (isConstant(c)) {
				return c.logarithm().add(arg.divide(c).logarithm());
			}
			var c = getConstant(arg);
			if (c instanceof Integer && !c.equals(Expression.ONE)) {
				return c.logarithm().add(arg.divide(c).logarithm());
			}
			if (arg.b instanceof Expression.MatrixSymbol) {
				return arg.a.logarithm().add(arg.b.logarithm());
			}
		}
		if (arg instanceof Expression.ExpressionWithPolynomialRoot) {
			arg = arg.upgrade();
		}
		if (arg instanceof Expression.ExpressionPolynomialRoot) {
			var g = arg.root.upgrade().getAlpha().polynomial.getGCDOfTermDegrees();
			if (g > 1) {
				return arg._pow(g).logarithm().divide(Expression.Integer.fromNumber(g));
			}
		}

		if (arg instanceof Expression.Symbol) {
			if (arg === Expression.E) {
				return Expression.ONE;
			}
			return new Expression.Logarithm(arg);
		}
		if (arg instanceof Expression.NthRoot) {
			var a = arg.a;
			var n = arg.n;
			if (a instanceof Expression.Integer && a.compareTo(Expression.ONE) > 0) {
				return a.logarithm().divide(Expression.Integer.fromNumber(n));
			}
			if (isPositive(a)) {
				return a.logarithm().divide(Expression.Integer.fromNumber(n));
			}
		}
		if (arg instanceof Expression.Exponentiation) {
			var b = getBase(arg);
			var e = getExponent(arg);
			if (b === Expression.E) {
				return e;
			}
			if (b instanceof Expression.MatrixSymbol && e instanceof Integer) {
				return b.logarithm().multiply(e);
			}
			if (b instanceof Expression.Integer) {
				return b.logarithm().multiply(e);
			}
		}
		if (arg instanceof Expression.Matrix) {
			var matrix = arg.matrix;
			if (matrix.isDiagonal()) {
				return new Expression.Matrix(matrix.map(function (e, i, j) {
					return i === j ? e.logarithm() : Expression.ZERO;
				}));
			}
			var eigenvalues = Expression.getEigenvalues(matrix);
			if (eigenvalues.length === matrix.cols()) {
				var eigenvectors = Expression.getEigenvectors(matrix, eigenvalues);
				if (eigenvectors.filter(function (v) {
					return v != null;
				}).length === matrix.cols()) {
					if (Expression.callback != undefined) {
						Expression.callback(new Expression.Event("logarithm-using-diagonalization", new Expression.Matrix(matrix)));
					}
					var tmp = Expression.diagonalize(matrix, eigenvalues, eigenvectors);

					return new Expression.Matrix(tmp.T).multiply(new Expression.Matrix(tmp.L).logarithm()).multiply(new Expression.Matrix(tmp.T_INVERSED));
				} else {
					var tmp = Expression.getFormaDeJordan(matrix, eigenvalues);

					var J = tmp.J;
					var logarithmOfJordanBlockMatrix = function (B) {
						var K = B.map(function (e, i, j) {
							return i !== j ? e.divide(B.e(i, i)) : Expression.ZERO;
						});
						var S = B.map(function (e, i, j) {
							return i === j ? e.logarithm() : Expression.ZERO;
						});
						var n = B.cols();
						for (var i = 1; i < n; i += 1) {
							var x = K.pow(i).scale(Expression.ONE.divide(Expression.Integer.fromNumber(i)));
							S = i % 2 === 1 ? S.add(x) : S.subtract(x);
						}
						return S;
					};
					var LJ = logarithmOfJordanBlockMatrix(J);

					if (Expression.callback != undefined) {
						Expression.callback(new Expression.Event("logarithm-using-Jordan-canonical-form", new Expression.Matrix(matrix)));
					}

					return new Expression.Matrix(tmp.P).multiply(new Expression.Matrix(LJ)).multiply(new Expression.Matrix(tmp.P_INVERSED));
				}
			}
		}
		if (arg instanceof Expression.Addition) {
			var c = getConstant(arg);
			if (!c.equals(Expression.ONE)) {
				return c.logarithm().add(arg.divide(c).logarithm());
			}
			if (arg.a instanceof Expression.Symbol && arg.b instanceof Expression.Integer) {
				return new Expression.Logarithm(arg);
			}
			var v = getVariableInternal(getLastMultiplicationOperand(getFirstAdditionOperand(arg))).next().value.v;
			if (v instanceof Expression.Symbol) {
				var p = Polynomial.toPolynomial(arg, v);
				var c = p.getContent();
				if (c.isNegative()) {
					c = c.negate();
				}
				if (isPositive(c) && !c.equals(Expression.ONE)) {
					return arg.divide(c).logarithm().add(c.logarithm());
				}

				var sf = p.getSquareFreePolynomial();
				var n = Math.floor(p.getDegree() / sf.getDegree());
				if (n > 1 && sf.calcAt(v)._pow(n).equals(arg)) {
					return Expression.Integer.fromNumber(n).multiply(sf.calcAt(v).logarithm());
				}
			}
			if (isGoodPolynomial(arg)) {
				return new Expression.Logarithm(arg);
			}
		}
		var qi = QuadraticInteger.toQuadraticInteger(arg);
		if (qi != null && (Number(qi.a.toString()) > 0 || Number(qi.b.toString()) > 0) && qi.D > 0 && (qi.isValid() || qi.D === 5 || qi.D === 37)) {
			var f = qi.primeFactor();
			if (f.toExpression().equals(Expression.TWO)) {
				qi = qi.truncatingDivide(f);
				f = qi.primeFactor();
			}
			if (!f.equals(qi)) {
				return f.toExpression().logarithm().add(arg.divide(f.toExpression()).logarithm());
			}
			if (Number(qi.a.toString()) > 0 && Number(qi.b.toString()) > 0) {

				return new Expression.Logarithm(arg);
			}
			if (Number(qi.a.toString()) < 0 || Number(qi.b.toString()) < 0) {
				var xc = qi.conjugate().toExpression();
				if (xc.isNegative()) {
					xc = xc.negate();
				}
				return arg.multiply(xc).logarithm().subtract(xc.logarithm());
			}
		}
		if (arg instanceof Addition && arg.b instanceof NthRoot && arg.a instanceof NthRoot) {
			var g = nthRootCommonFactor(arg.a, arg.b);
			if (!g.equals(Expression.ONE) && isPositive(g)) {
				return g.logarithm().add(arg.divide(g).logarithm());
			}
		}

		var c = Expression.getComplexNumberParts(arg);
		if (c != undefined && !c.imaginary.equals(Expression.ZERO)) {
			var phi = atan2(c.imaginary, c.real);

			return arg.divide(Expression.I.multiply(phi).exp()).logarithm().add(Expression.I.multiply(phi));
		}
		if (Expression.isConstant(arg)) {
			var sd = simpleDivisor(arg);
			if (!sd.equals(arg)) {
				return sd.logarithm().add(arg.divide(sd).logarithm());
			}
		}
		throw new TypeError("NotSupportedError");
	};

	NthRoot.prototype.compare4MultiplicationExponentiation = Exponentiation.prototype.compare4MultiplicationExponentiation;
	Expression.Symbol.prototype.compare4MultiplicationExponentiation = Exponentiation.prototype.compare4MultiplicationExponentiation;

	Expression.prototype.complexConjugate = function () {
		throw new TypeError("NotSupportedError");
	};
	Expression.Integer.prototype.complexConjugate = function () {
		return this;
	};

	Expression.Division.prototype.complexConjugate = function () {
		return this.getNumerator().complexConjugate().divide(this.getDenominator().complexConjugate());
	};
	Expression.Multiplication.prototype.complexConjugate = function () {
		return this.a.complexConjugate().multiply(this.b.complexConjugate());
	};
	Expression.Addition.prototype.complexConjugate = function () {
		return this.a.complexConjugate().add(this.b.complexConjugate());
	};
	Expression.Function.prototype.complexConjugate = function () {
		if (this.a instanceof Integer || Expression.isReal(this)) {
			return this;
		}
		throw new TypeError("NotSupportedError");
	};
	Expression.Matrix.prototype.complexConjugate = function () {
		var a = this;
		return new Expression.Matrix(a.matrix.map(function (x) {
			return x.complexConjugate();
		}));
	};
	Expression.Symbol.prototype.complexConjugate = function () {
		if (this === Expression.E || this === Expression.PI || Expression.isReal(this)) {
			return this;
		}
		return new Expression.ComplexConjugate(this);
	};
	Expression.IdentityMatrix.prototype.complexConjugate = function () {
		return this;
	};

	Expression.Exponentiation.prototype.complexConjugate = function () {

		if (getBase(this) === Expression.E) {
			return getBase(this).pow(getExponent(this).complexConjugate());
		}

		if (isIntegerOrN(getExponent(this))) {
			return getBase(this).complexConjugate().pow(getExponent(this));
		}
		if (isMatrixSymbolTranspose(this)) {

			return new Expression.Exponentiation(getBase(this).complexConjugate(), getExponent(this));
		}
		if (Expression.isReal(this)) {
			return this;
		}
		throw new TypeError("NotSupportedError");
	};
	Expression.Logarithm.prototype.complexConjugate = function () {
		return this.a.complexConjugate().logarithm();
	};

	Expression.ComplexConjugate = function (a) {
		Expression.Function.call(this, "conjugate", a);
	};
	Expression.ComplexConjugate.prototype = Object.create(Expression.Function.prototype);

	Expression.ComplexConjugate.prototype.complexConjugate = function () {
		return this.a;
	};

	Expression.ComplexArgument = function (a) {
		Expression.Function.call(this, "arg", a);
	};
	Expression.ComplexArgument.prototype = Object.create(Expression.Function.prototype);

	Expression.AugmentedMatrix = function (A, B) {
		Expression.Function.call(this, "augment", null);
		this.a = A;
		this.b = B;
	};
	Expression.AugmentedMatrix.prototype = Object.create(Expression.Function.prototype);
	Expression.AugmentedMatrix.prototype.toString = function (options) {

		return '(' + this.a.toString(options) + '|' + this.b.toString(options) + ')';
	};
	Expression.AugmentedMatrix.prototype.toMathML = function (options) {

		return '<mrow>' + '<mo>(</mo>' + this.a.toMathML(options) + '<mo>|</mo>' + this.b.toMathML(options) + '<mo>)</mo>' + '</mrow>';
	};

	Expression.Abs = function (a) {
		Expression.Function.call(this, "abs", a);
	};
	Expression.Abs.prototype = Object.create(Expression.Function.prototype);
	Expression.Abs.prototype.toMathML = function (options) {

		return '<mrow>' + '<mo stretchy="false">|</mo>' + this.a.toMathML(options) + '<mo stretchy="false">|</mo>' + '</mrow>';
	};
	Expression.Abs.prototype.complexConjugate = function () {
		return this;
	};
	Expression.Abs.prototype.pow = function (y) {
		if (y instanceof Expression.Integer) {
			return this.a.pow(y).abs()
		}
		return Expression.Function.prototype.pow.call(this, y);
	};

	Expression.Matrix.prototype.pseudoinverse = function () {
		if (this.matrix.isSquare()) {
			var det = this.matrix.determinant();
			if (Expression.isConstant(det) && !det.equals(Expression.ZERO)) {
				return new Expression.Matrix(this.matrix.inverse());
			}
		}
		if (Expression.callback != undefined) {

			Expression.callback(new Expression.Event("pseudoinverse", this));
		}
		var tmp = Expression.SVD(this.matrix);

		return new Expression.Matrix(tmp.Vstar.conjugateTranspose().multiply(tmp.Sigma.map(function (e) {
			return e.equals(Expression.ZERO) ? Expression.ZERO : e.inverse();
		}).transpose()).multiply(tmp.U.conjugateTranspose()));
	};
	Expression.Pseudoinverse = function (matrix) {
		Expression.Function.call(this, "pseudoinverse", matrix);
	};
	Expression.Pseudoinverse.prototype = Object.create(Expression.Function.prototype);

	Expression.prototype.factor = function () {
		var e = this;

		var v = new Expression.Symbol('x');
		var p = Polynomial.toPolynomial(e, v);
		var factors = [];

		function factorInternal(p, m) {
			var factor = null;
			while (p.getDegree() > 1 && (factor = p.factorize()) != null && !factor.equals(p)) {
				factorInternal(factor, m);
				p = p.divideAndRemainder(factor, "throw").quotient;
			}
			if (p.getDegree() >= 0) {
				factors.push({
					factor: p,
					multiplicity: m
				});
			}
		}

		for (var iteratore = p.getSquareFreeFactorization()[globalThis.Symbol.iterator](), e = iteratore.next().value; e != null; e = iteratore.next().value) {
			factorInternal(e.factor, e.multiplicity);
		}
		return factors.map(function (f) {
			return f.multiplicity === 1 ? new Expression.Polynomial(f.factor) : new Expression.Exponentiation(new Expression.Polynomial(f.factor), Expression.Integer.fromNumber(f.multiplicity));
		}).reduce(function (p, x) {
			return new Expression.Multiplication(p, x);
		});
	};

	function Derivative(e, variable) {
		Expression.Symbol.call(this, e);
		this.variable = variable;
	}

	Derivative.prototype = Object.create(Expression.Symbol.prototype);

	Expression.Derivative = Derivative;

	Expression.prototype.derivative = function (variable) {
		variable = variable == undefined ? undefined : variable;

		if (variable == undefined) {
			throw new RangeError();
		}
		var e = this;
		if (e instanceof Expression.Matrix) {
			return new Expression.Matrix(e.matrix.map(function (e) {
				return e.derivative(variable);
			}));
		}
		if (e instanceof Expression.Exponentiation) {
			if (getBase(e) === Expression.E) {
				return e.multiply(getExponent(e).derivative(variable));
			}
			if (getExponent(e) instanceof Expression.Integer) {
				return getExponent(e).multiply(getBase(e).pow(getExponent(e).subtract(Expression.ONE))).multiply(getBase(e).derivative(variable));
			}
			if (getExponent(e).equals(variable) && Expression.isConstant(getBase(e))) {
				return e.multiply(getBase(e).logarithm());
			}
		}
		if (e instanceof Expression.Symbol) {
			if (e.symbol.toLowerCase() === e.symbol) {
				return e.equals(variable) ? Expression.ONE : Expression.ZERO;
			}

			return new Expression.Derivative(e);
		}
		if (e instanceof Expression.Multiplication) {
			return e.a.derivative(variable).multiply(e.b).add(e.a.multiply(e.b.derivative(variable)));
		}
		if (e instanceof Expression.Addition) {
			return e.a.derivative(variable).add(e.b.derivative(variable));
		}
		if (e instanceof Expression.Division) {
			var f = e.getNumerator();
			var g = e.getDenominator();
			return g.multiply(f.derivative(variable)).subtract(f.multiply(g.derivative(variable))).divide(g.multiply(g));
		}
		if (e instanceof Expression.Sin) {
			return e.a.cos().multiply(e.a.derivative(variable));
		}
		if (e instanceof Expression.Cos) {
			return e.a.sin().negate().multiply(e.a.derivative(variable));
		}
		if (e instanceof Expression.Logarithm) {

			return e.a.derivative(variable).divide(e.a);
		}
		if (Expression.isConstant(e)) {
			return Expression.ZERO;
		}

		throw new RangeError("NotSupportedError");
	};

	Expression.KroneckerProduct = function (a, b) {
		BinaryOperation.call(this, a, b);
	};
	Expression.KroneckerProduct.prototype = Object.create(BinaryOperation.prototype);
	Expression.KroneckerProduct.prototype.getS = function () {
		return "\u2297";
	};
	Expression.prototype.KroneckerProduct = function (B) {
		function kroneckerProduct(A, B) {
			return Matrix.Zero(A.rows() * B.rows(), A.cols() * B.cols()).map(function (e, i, j) {
				return A.e(Math.floor(i / B.rows()), Math.floor(j / B.cols())).multiply(B.e(i % B.rows(), j % B.cols()));
			});
		}

		var A = this;
		if (A instanceof Expression.Matrix && B instanceof Expression.Matrix) {
			return new Expression.Matrix(kroneckerProduct(A.matrix, B.matrix));
		}
		throw new RangeError("NotSupportedError");
	};

	Expression.prototype.LLL = function () {

		var a = this;
		if (a instanceof Expression.Matrix) {
			return new Expression.Matrix(LLLAdapter(a.matrix));
		}
		throw new RangeError("NotSupportedError:matrixArgExpected");
	};

	function HNF(M) {
		var num = Expression.Integer.fromBigInt;

		var n = M.rows();
		var m = M.cols();
		var A = M.rowVectors();
		var k = 0;
		for (var j = 0; j < m; j++) {
			for (var i = k + 1; i < n; i++) {
				if (!A[i].e(j).equals(Expression.ZERO)) {

					var uvg = gcdext(A[k].e(j).toBigInt(), A[i].e(j).toBigInt());
					var u = num(uvg[0]);
					var v = num(uvg[1]);
					var g = num(uvg[2]);

					var B = A[k].scale(u).subtract(A[i].scale(v.negate()));
					A[i] = A[i].scale(A[k].e(j).divide(g)).subtract(A[k].scale(A[i].e(j).divide(g)));
					A[k] = B;
				}
			}
			if (k < n && !A[k].e(j).equals(Expression.ZERO)) {
				k = k + 1;
			}
		}

		k = 0;
		for (var j = 0; j < m && k < n; j += 1) {
			if (A[k].e(j).isNegative()) {
				A[k] = A[k].scale(Expression.ONE.negate());
			}
			var b = A[k].e(j);
			if (b.equals(Expression.ZERO)) {
				continue;
			}
			for (var i = 0; i < k; i += 1) {
				var q = A[i].e(j).truncatingDivide(b);

				if (b.multiply(q).compareTo(A[i].e(j)) > 0) {
					q = q.subtract(Expression.ONE);
				}

				A[i] = A[i].subtract(A[k].scale(q));
			}
			k = k + 1;
		}
		return Matrix.fromVectors(A).transpose();
	}

	globalThis.HNF = HNF;

	Expression.prototype.HNF = function () {

		var a = this;
		if (a instanceof Expression.Matrix) {
			return new Expression.Matrix(HNF(a.matrix));
		}
		throw new RangeError("NotSupportedError:matrixArgExpected");
	};
}

function IntervalArithmetic() {
	addMath(BigFloat, 2);
	addMath(BigDecimal, 10);

	var BASE = 2;

	function MakeMath(BigFloat, BASE) {
		function BigFloatMath() {
		}

		BigFloatMath.nextAfter = function (a, rounding) {
			if (rounding == undefined) {
				throw new RangeError();
			}
			if (rounding.roundingMode !== 'floor' && rounding.roundingMode !== 'ceil') {
				throw new RangeError();
			}
			var t = BigFloat.round(a, rounding);
			if (!BigFloat.equal(a, t)) {
				return t;
			}
			var _nextAfter = function (a, k, v, rounding) {
				var small = BigFloat.multiply(BigFloat(rounding.roundingMode === 'floor' ? -1 : 1), exponentiateBase(-k));
				var aim = BigFloat.multiply(BigFloat.abs(v), small);
				return BigFloat.add(a, aim, rounding);
			};
			if (rounding.maximumFractionDigits != undefined) {
				return _nextAfter(a, rounding.maximumFractionDigits, BigFloat(1), rounding);
			}
			if (rounding.maximumSignificantDigits != undefined) {

				return _nextAfter(a, rounding.maximumSignificantDigits, a, rounding);
			}
			throw new RangeError();
		};

		var exponentiateBase = function (n) {
			var BIG_DECIMAL_BASE = BigFloat.round(BigFloat(BASE), {
				maximumSignificantDigits: 1,
				roundingMode: 'half-even'
			});
			var a = BIG_DECIMAL_BASE;
			if (n < 0) {
				return BigFloat.divide(BigFloat(1), exponentiateBase(-n), null);
			}
			var y = BigFloat(1);
			while (n >= 1) {
				if (0 === n % 2) {
					a = BigFloat.multiply(a, a);
					n = n / 2;
				} else {
					y = y == undefined ? a : BigFloat.multiply(a, y);
					n = n - 1;
				}
			}
			return y;
		};
		return BigFloatMath;
	}

	var BigFloatMath = MakeMath(BigFloat, 2);
	var BigDecimalMath = MakeMath(BigDecimal, 10);

	function Interval(a, b) {
		if (BigFloat.greaterThan(a, b)) {
			throw new TypeError();
		}
		this.a = a;
		this.b = b;
	}

	Interval._rounding = function (baseRounding, roundingMode) {
		if (baseRounding == null) {
			return null;
		}
		return baseRounding.maximumFractionDigits != undefined ? {
			maximumFractionDigits: baseRounding.maximumFractionDigits,
			roundingMode: roundingMode
		} : {
			maximumSignificantDigits: baseRounding.maximumSignificantDigits,
			roundingMode: roundingMode
		};
	};
	Interval.unaryMinus = function (x) {
		return new Interval(BigFloat.unaryMinus(x.b), BigFloat.unaryMinus(x.a));
	};
	Interval.add = function (x, y, rounding) {
		rounding = rounding == undefined ? null : rounding;

		return new Interval(BigFloat.add(x.a, y.a, Interval._rounding(rounding, 'floor')), BigFloat.add(x.b, y.b, Interval._rounding(rounding, 'ceil')));
	};
	Interval.subtract = function (x, y, rounding) {
		rounding = rounding == undefined ? null : rounding;

		return new Interval(BigFloat.subtract(x.a, y.b, Interval._rounding(rounding, 'floor')), BigFloat.subtract(x.b, y.a, Interval._rounding(rounding, 'ceil')));
	};
	Interval._multiply = function (x1, x2, y1, y2, f) {
		var sign = BigFloat.sign;
		var sx1 = sign(x1);
		var sx2 = sign(x2);
		var sy1 = sign(y1);
		var sy2 = sign(y2);
		if (sx1 >= 0) {
			if (sy1 >= 0) {
				return f(x1, y1, x2, y2);
			}
			if (sy2 <= 0) {
				return f(x2, y1, x1, y2);
			}

			return f(x2, y1, x2, y2);
		}
		if (sx2 <= 0) {
			if (sy2 <= 0) {
				return f(x2, y2, x1, y1);
			}
			if (sy1 >= 0) {
				return f(x1, y2, x2, y1);
			}

			return f(x1, y2, x1, y1);
		}
		if (sy1 >= 0) {
			return f(x1, y2, x2, y2);
		}
		if (sy2 <= 0) {
			return f(x2, y1, x1, y1);
		}

		var interval1 = f(x1, y2, x1, y1);
		var interval2 = f(x2, y1, x2, y2);
		return new Interval(BigFloat.min(interval1.a, interval2.a), BigFloat.max(interval1.b, interval2.b));
	};
	Interval.multiply = function (x, y, rounding) {
		rounding = rounding == undefined ? null : rounding;

		var floorRounding = Interval._rounding(rounding, 'floor');
		var ceilRounding = Interval._rounding(rounding, 'ceil');
		if (BigFloat.equal(x.a, x.b) && BigFloat.equal(y.a, y.b)) {
			var product = BigFloat.multiply(x.a, y.a);
			return new Interval(BigFloat.round(product, floorRounding), BigFloat.round(product, ceilRounding));
		}
		var f = function (a, b, c, d) {
			return new Interval(BigFloat.multiply(a, b, floorRounding), BigFloat.multiply(c, d, ceilRounding));
		};
		return Interval._multiply(x.a, x.b, y.a, y.b, f);
	};
	Interval.divide = function (x, y, rounding) {
		var floorRounding = Interval._rounding(rounding, 'floor');
		var ceilRounding = Interval._rounding(rounding, 'ceil');
		if (BigFloat.sign(y.a) <= 0 && BigFloat.sign(y.b) >= 0) {
			if (BigFloat.equal(y.a, y.b)) {
				throw new RangeError();
			}
			return "CANNOT_DIVIDE";
		}
		if (BigFloat.equal(x.a, x.b) && BigFloat.equal(y.a, y.b)) {

			var q = BigFloat.divide(x.a, y.a, floorRounding);
			var r = BigFloat.subtract(x.a, BigFloat.multiply(y.a, q));
			return new Interval(q, !BigFloat.equal(r, BigFloat(0)) ? BigFloatMath.nextAfter(q, ceilRounding) : q);
		}
		var f = function (a, d, c, b) {

			return new Interval(BigFloat.divide(a, b, floorRounding), BigFloat.divide(c, d, ceilRounding));
		};
		return Interval._multiply(x.a, x.b, y.a, y.b, f);
	};
	Interval.sqrt = function (x, rounding) {
		if (BigFloat.sign(x.a) < 0 && BigFloat.sign(x.b) >= 0) {
			return "CANNOT_DIVIDE";
		}
		if (BigFloat.equal(x.a, x.b)) {
			var ya = BigFloat.sqrt(x.a, Interval._rounding(rounding, 'floor'));
			var yb = BigFloat.equal(BigFloat.multiply(ya, ya), x.b) ? ya : BigFloatMath.nextAfter(ya, Interval._rounding(rounding, 'ceil'));
			return new Interval(ya, yb);
		}
		return Interval._map(x, function (x, rounding) {
			return BigFloat.sqrt(x, rounding);
		}, rounding);
	};
	Interval.exp = function (x, rounding) {
		return Interval._map(x, BigFloat.exp, rounding);
	};
	Interval.log = function (x, rounding) {
		if (BigFloat.sign(x.a) <= 0 && BigFloat.sign(x.b) > 0) {
			return "CANNOT_DIVIDE";
		}
		if (BigFloat.equal(x.a, x.b) && BigFloat.equal(x.b, BigFloat(1))) {
			return new Interval(BigFloat(0), BigFloat(0));
		}
		return Interval._map(x, BigFloat.log, rounding);
	};
	Interval.atan = function (x, rounding) {
		return Interval._map(x, BigFloat.atan, rounding);
	};
	Interval._mapValue = function (value, callback, rounding) {
		var c = callback(value, Interval._rounding(rounding, 'floor'));

		var a = c;
		var b = c;
		if (!BigFloat.equal(value, BigFloat(0))) {
			b = BigFloatMath.nextAfter(c, Interval._rounding(rounding, 'ceil'));
		}
		return new Interval(a, b);
	};
	Interval._map = function (x, callback, rounding) {
		if (BigFloat.equal(x.a, x.b)) {
			return Interval._mapValue(x.a, callback, rounding);
		}
		var a = callback(x.a, Interval._rounding(rounding, 'floor'));
		var b = callback(x.b, Interval._rounding(rounding, 'ceil'));
		return new Interval(a, b);
	};
	Interval._trigonometry = function (x, which, rounding) {
		if (BigFloat.equal(x.a, x.b)) {
			return Interval._mapValue(x.a, which === 'sin' ? BigFloat.sin : BigFloat.cos, rounding);
		}
		var anyRounding = Object.assign({}, Interval._rounding(rounding, 'floor'), {roundingMode: 'half-even'});
		var tau = BigFloat.multiply(BigFloat(8), BigFloat.atan(BigFloat(1), anyRounding));
		if (!BigFloat.lessThan(BigFloat.subtract(x.b, x.a), tau)) {
			return new Interval(BigFloat(-1), BigFloat(+1));
		}
		var f = function (x, rounding) {
			return which === 'sin' ? BigFloat.sin(x, rounding) : BigFloat.cos(x, rounding);
		};
		var middle = BigFloat.divide(BigFloat.add(x.a, x.b), BigFloat(2), anyRounding);
		var extremumPoint = function (q) {
			var shift = BigFloat.multiply(BigFloat.divide(BigFloat(q), BigFloat(4), anyRounding), tau);
			var k = BigFloat.round(BigFloat.divide(BigFloat.subtract(middle, shift, anyRounding), tau, anyRounding), {
				maximumFractionDigits: 0,
				roundingMode: 'half-even'
			});
			return BigFloat.add(BigFloat.multiply(tau, k), shift);
		};
		var minimumPoint = extremumPoint(which === 'sin' ? 3 : 2);
		var maximumPoint = extremumPoint(which === 'sin' ? 1 : 0);
		var floorRounding = Interval._rounding(rounding, 'floor');
		var ceilRounding = Interval._rounding(rounding, 'ceil');
		var fmin = BigFloat.lessThan(minimumPoint, x.a) ? f(x.a, floorRounding) : (BigFloat.greaterThan(minimumPoint, x.b) ? f(x.b, floorRounding) : BigFloat(-1));
		var fmax = BigFloat.lessThan(maximumPoint, x.a) ? f(x.a, ceilRounding) : (BigFloat.greaterThan(maximumPoint, x.b) ? f(x.b, ceilRounding) : BigFloat(+1));

		return new Interval(fmin, fmax);
	};
	Interval.sin = function (x, rounding) {
		return Interval._trigonometry(x, 'sin', rounding);
	};
	Interval.cos = function (x, rounding) {
		return Interval._trigonometry(x, 'cos', rounding);
	};

	Interval.fromIntegers = function (a, b) {
		var a1 = BigFloat(a);
		var b1 = BigFloat(b);

		console.assert(!BigFloat.lessThan(b1, a1));
		return new Interval(a1, b1);
	};
	Interval.abs = function (x) {
		if (BigFloat.lessThan(x.a, BigFloat(0))) {
			if (BigFloat.lessThan(x.b, BigFloat(0))) {
				return new Interval(BigFloat.unaryMinus(x.b), BigFloat.unaryMinus(x.a));
			} else {
				return new Interval(BigFloat(0), BigFloat.max(BigFloat.unaryMinus(x.a), x.b));
			}
		}
		return x;
	};
	Interval.exponentiate = function (x, n, contextRounding) {
		var y = undefined;
		while (n >= 1) {
			if (n === 2 * Math.floor(n / 2)) {
				x = Interval.multiply(x, x, contextRounding);
				n = Math.floor(n / 2);
			} else {
				y = y == undefined ? x : Interval.multiply(x, y, contextRounding);
				n -= 1;
			}
		}
		return y;
	};

	Interval.formatToDecimal = function (x, rounding) {

		var signA = BigFloat.sign(x.a);
		var signB = BigFloat.sign(x.b);
		var sign = (signA || signB) === (signB || signA) ? (signA || signB) : 0;
		x = Interval.abs(x);
		var stringify = function (a, roundingMode) {
			if (rounding.fractionDigits != undefined) {
				return a.toFixed(rounding.fractionDigits, roundingMode);
			}
			return a.toPrecision(rounding.significantDigits, roundingMode);
		};
		var a = stringify(x.a, "half-up");
		var b = BigFloat.equal(x.a, x.b) ? a : stringify(x.b, "half-down");
		var isZero = function (a) {
			return !/[^0\.]/.test(a);
		};
		if (a === b && (sign !== 0 || isZero(a) && isZero(b))) {
			return (sign < 0 ? '-' : (sign > 0 && isZero(a) && isZero(b) ? '+' : '')) + a;
		}
		return undefined;
	};
	Interval.prototype.toString = function () {
		return "[" + this.a.toString() + ";" + this.b.toString() + "]";
	};

	var calcAt = function (polynomial, x, contextRounding) {
		var result = evaluateExpression(Expression.ZERO, contextRounding);
		for (var i = polynomial.getDegree(); i >= 0; i--) {
			result = Interval.multiply(result, x, contextRounding);
			var tmp = evaluateExpression(polynomial.getCoefficient(i), contextRounding);
			if (tmp === "CANNOT_DIVIDE" || tmp == undefined) {
				return tmp;
			}
			result = Interval.add(result, tmp, contextRounding);
		}
		return result;
	};

	var evaluateExpression = function (e, contextRounding) {
		if (e instanceof Expression.Integer) {
			var n = e.value;
			return Interval.fromIntegers(n, n);
		} else if (e instanceof Expression.NthRoot) {
			var a = e.a;
			var n = e.n;
			var y = evaluateExpression(a, contextRounding);
			if (y === "CANNOT_DIVIDE" || y == undefined) {
				return y;
			}
			if (n == 2) {
				return Interval.sqrt(y, contextRounding);
			}
			return Interval.exp(Interval.divide(Interval.log(y, contextRounding), Interval.fromIntegers(n, n), contextRounding), contextRounding);
		} else if (e instanceof Expression.BinaryOperation) {

			if (e instanceof Expression.Addition && Expression.has(e, Expression.PolynomialRootSymbol)) {
				var root = Expression.getVariable(e);
				var p = Polynomial.toPolynomial(e, root);
				if (p.hasIntegerCoefficients()) {

					var zero = evaluateExpression(root, contextRounding);

					return calcAt(p, zero, contextRounding);
				}
			}
			if (e.a === Expression.E && e.getS() === "^") {
				var b = evaluateExpression(e.b, contextRounding);
				if (b === "CANNOT_DIVIDE" || b == undefined) {
					return b;
				}
				return Interval.exp(b, contextRounding);
			}

			var a = evaluateExpression(e.a, contextRounding);
			if (a === "CANNOT_DIVIDE" || a == undefined) {
				return a;
			}
			var b = evaluateExpression(e.b, contextRounding);
			if (b === "CANNOT_DIVIDE" || b == undefined) {
				return b;
			}
			var operator = e.getS();
			if (operator === "+") {
				return Interval.add(a, b, contextRounding);
			} else if (operator === "-") {
				return Interval.subtract(a, b, contextRounding);
			} else if (operator === "*") {
				return Interval.multiply(a, b, contextRounding);
			} else if (operator === "/") {
				return Interval.divide(a, b, contextRounding);
			} else if (operator === "^") {

				if (!(e.b instanceof Expression.Integer) || e.b.toNumber() <= 0 || e.b.toNumber() > Number.MAX_SAFE_INTEGER) {

					var log = Interval.log(a, contextRounding);
					if (log === "CANNOT_DIVIDE") {
						return log;
					}
					return Interval.exp(Interval.multiply(log, b, contextRounding), contextRounding);
				}
				var n = e.b.toNumber();
				return Interval.exponentiate(a, n, contextRounding);
			}
		} else if (e instanceof Expression.PolynomialRootSymbol || e instanceof Expression.ExpressionPolynomialRoot) {
			var i = (e instanceof Expression.ExpressionPolynomialRoot ? e.root : e).toDecimal(contextRounding.maximumSignificantDigits || contextRounding.maximumFractionDigits);

			var d = i.a.getDenominator().multiply(i.b.getDenominator()).value;
			return Interval.divide(Interval.fromIntegers(i.b.getDenominator().multiply(i.a.getNumerator()).value, i.a.getDenominator().multiply(i.b.getNumerator()).value), Interval.fromIntegers(d, d), contextRounding);
		} else if (e === Expression.E) {
			return Interval.exp(Interval.fromIntegers(1, 1), contextRounding);
		} else if (e === Expression.PI) {
			return Interval.multiply(Interval.fromIntegers(4, 4), Interval.atan(Interval.fromIntegers(1, 1), contextRounding));
		} else if (e instanceof Expression.Function) {
			var x = evaluateExpression((e instanceof Expression.Sin || e instanceof Expression.Cos) && e.a instanceof Expression.Radians ? e.a.value : e.a, contextRounding);
			if (x === "CANNOT_DIVIDE" || x == undefined) {
				return x;
			}
			if (e instanceof Expression.Sin) {
				return Interval.sin(x, contextRounding);
			}
			if (e instanceof Expression.Cos) {
				return Interval.cos(x, contextRounding);
			}
			if (e instanceof Expression.Logarithm) {
				return Interval.log(x, contextRounding);
			}
			if (e instanceof Expression.Arctan) {
				return Interval.atan(x, contextRounding);
			}
		} else if (e instanceof Expression.ExpressionWithPolynomialRoot) {
			return evaluateExpression(e.e, contextRounding);
		}

		return undefined;
	};

	var decimalToString = function (decimal) {
		return decimal.replace(/[eE]/g, '*10^');
	};

	var complexToString = function (real, imaginary) {
		return real + (/^[\-\+]/.test(imaginary) ? imaginary.replace(/^([\-\+])[\s\S]+/g, '$1') : (real !== '' ? '+' : '')) + (imaginary !== '1' && imaginary !== '-1' ? imaginary.replace(/^[\-\+]/g, '') + '*' + 'i' : 'i');
	};

	var toDecimalStringInternal = function (expression, rounding, decimalToStringCallback, complexToStringCallback) {
		decimalToStringCallback = decimalToStringCallback || decimalToString;
		complexToStringCallback = complexToStringCallback || complexToString;
		if (rounding.fractionDigits == undefined && rounding.significantDigits == undefined || rounding.fractionDigits != undefined && rounding.significantDigits != undefined) {
			throw new RangeError();
		}
		if (rounding.fractionDigits != undefined && (rounding.fractionDigits < 0 || rounding.fractionDigits > Number.MAX_SAFE_INTEGER) || rounding.significantDigits != undefined && (rounding.significantDigits < 1 || rounding.significantDigits > Number.MAX_SAFE_INTEGER) || rounding.roundingMode != undefined) {
			throw new RangeError();
		}

		if (expression instanceof Expression.Complex || Expression.has(expression, Expression.Complex)) {
			var numerator = expression.getNumerator();
			var denominator = expression.getDenominator();
			if (denominator instanceof Expression.Integer || Expression.has(denominator, Expression.PolynomialRootSymbol) || Expression.has(denominator, Expression.ExpressionPolynomialRoot) || Expression._isPositive(denominator)) {
				if (numerator instanceof Expression.Addition || numerator instanceof Expression.Multiplication || numerator instanceof Expression.Complex) {
					var tmp = Expression.getComplexNumberParts(numerator);
					var realValue = tmp.real;
					var imaginaryValue = tmp.imaginary;
					if (!imaginaryValue.equals(Expression.ZERO)) {
						realValue = realValue.divide(denominator);
						imaginaryValue = imaginaryValue.divide(denominator);
						var real = realValue.equals(Expression.ZERO) ? '' : toDecimalStringInternal(realValue, rounding, decimalToStringCallback, complexToStringCallback);
						var imaginary = toDecimalStringInternal(imaginaryValue, rounding, decimalToStringCallback, complexToStringCallback);
						return complexToStringCallback(real, imaginary);
					}
				}
			}
		}

		if (expression instanceof Expression.Integer || expression instanceof Expression.Division && expression.a instanceof Expression.Integer && expression.b instanceof Expression.Integer) {

			if (true) {
				return decimalToStringCallback(primeFactor._rationalNumberToDecimalString(expression.getNumerator().toBigInt(), expression.getDenominator().toBigInt(), rounding));
			}
		}

		console.assert(BASE % 2 === 0);
		var result = undefined;
		var guessedPrecision = 1;

		var flag0 = Expression.has(expression, Expression.Function) || Expression.has(expression, Expression.Exponentiation);
		while (result == undefined) {
			if (guessedPrecision > 60000 && guessedPrecision > (rounding.fractionDigits || rounding.significantDigits) * 4 * Math.log2(10)) {
				debugger;
				throw new TypeError();
			}

			var contextRounding = flag0 ? {maximumSignificantDigits: guessedPrecision} : {maximumFractionDigits: guessedPrecision - 1};
			var x = evaluateExpression(expression, contextRounding);
			if (x == undefined) {
				return undefined;
			}
			if (x !== "CANNOT_DIVIDE") {
				result = Interval.formatToDecimal(x, rounding);
			}
			if (guessedPrecision > 1 && result == undefined) {

			}
			if (x !== "CANNOT_DIVIDE" && result == undefined && rounding.fractionDigits != undefined && guessedPrecision === 1) {
				var log10OfValue = BigFloat.max(BigFloat.abs(x.a), BigFloat.abs(x.b)).toFixed(0).length;
				guessedPrecision = Math.max(Math.ceil((log10OfValue + rounding.fractionDigits + 1) * Math.log2(10) / 2), 2);
			}
			if (x !== "CANNOT_DIVIDE" && result == undefined && rounding.significantDigits != undefined && guessedPrecision === 1) {
				if (BigFloat.sign(x.a) === BigFloat.sign(x.b)) {
					var tmp = BigFloat.log(BigFloat.min(BigFloat.abs(x.a), BigFloat.abs(x.b)), {
						maximumSignificantDigits: 1,
						roundingMode: 'half-even'
					}).toFixed(0).length;
					guessedPrecision = Math.max(Math.ceil(tmp * Math.log2(10) / 2), 1);
				}
			}
			guessedPrecision *= 2;
		}
		if (guessedPrecision !== 256) {

		}
		return decimalToStringCallback(result);
	};

	self.toDecimalStringInternal = toDecimalStringInternal;

	toDecimalStringInternal.testables = {
		BigDecimalMath: BigDecimalMath,
		BigDecimal: BigDecimal,
		BigFloat: BigFloat,
		Interval: Interval
	};
}

function GF2() {
	function GF2(a) {
		this.a = a;
	}

	GF2.prototype = Object.create(Expression.prototype);

	Expression.GF2 = GF2;
	Expression.GF2.prototype.toString = function (options) {
		return "GF2(" + this.a.toString(Expression.setTopLevel(true, options)) + ")";
	};

	function GF2Value(value) {

		this.value = value;
	}

	Expression.GF2Value = GF2Value;

	GF2Value.prototype = Object.create(Expression.prototype);
	Expression.GF2Value.prototype.equals = function (b) {
		if (Expression.ZERO === b) {
			return this.value === 0;
		}
		return false;
	};
	Expression.GF2Value.prototype.negate = function () {
		return new GF2Value(this.value === 0 ? 0 : 2 - this.value);
	};

	GF2Value.prototype.add = function (x) {
		if (x === Expression.ZERO) {
			return new GF2Value(this.value);
		}
		if (!(x instanceof GF2Value)) {
			throw new RangeError();
		}
		var v = this.value - 2 + x.value;
		return new GF2Value(v >= 0 ? v : v + 2);
	};

	GF2Value.prototype.multiply = function (x) {
		if (x === Expression.ZERO) {
			return new GF2Value(0);
		}
		if (!(x instanceof GF2Value)) {
			throw new RangeError();
		}
		var v = this.value * x.value;
		return new GF2Value(v - 2 * Math.floor(v / 2));
	};

	GF2Value.prototype.divide = function (x) {

		return new GF2Value(this.value);
	};

	Expression.prototype.GF2 = function () {
		var x = this;
		if (!(x instanceof Expression.Matrix)) {
			throw new RangeError("NotSupportedError");
		}
		return new Expression.Matrix(x.matrix.map(function (e, i, j) {
			if (!(e.equals(Expression.ZERO) || e.equals(Expression.ONE))) {
				throw new TypeError();
			}
			return new Expression.GF2Value(e.equals(Expression.ZERO) ? 0 : 1);
		}));
	};

	GF2Value.prototype.toString = function (options) {
		return this.value.toString();
	};
}

function Trigonometry() {
	var Integer = Expression.Integer;
	var Addition = Expression.Addition;
	var Multiplication = Expression.Multiplication;
	var Division = Expression.Division;
	var Exponentiation = Expression.Exponentiation;
	var BinaryOperation = Expression.BinaryOperation;

	var separateSinCos = function (e) {
		if (!(e instanceof Multiplication)) {
			throw new TypeError();
		}
		var sinCos = undefined;
		var other = undefined;
		var x = e;
		for (var iteratory = x.factors()[globalThis.Symbol.iterator](), y = iteratory.next().value; y != null; y = iteratory.next().value) {
			var v = y;
			if (v instanceof Sin || v instanceof Cos || (v instanceof Exponentiation && (v.a instanceof Sin || v.a instanceof Cos))) {
				sinCos = sinCos == undefined ? v : sinCos.multiply(v);
			} else {
				other = other == undefined ? v : other.multiply(v);
			}
		}
		return {
			sinCos: sinCos == undefined ? Expression.ONE : sinCos,
			other: other == undefined ? Expression.ONE : other
		};
	};

	var expandMainOp = function (u) {
		return u;
	};

	var contractTrigonometryInternal = function (a, b) {

		var ax = a.a;
		var bx = b.a;
		if (a instanceof Sin && b instanceof Sin) {
			return ax.subtract(bx).cos().divide(Expression.TWO).subtract(ax.add(bx).cos().divide(Expression.TWO));
		}
		if (a instanceof Sin && b instanceof Cos) {
			return ax.add(bx).sin().divide(Expression.TWO).add(ax.subtract(bx).sin().divide(Expression.TWO));
		}
		if (a instanceof Cos && b instanceof Sin) {
			return ax.add(bx).sin().divide(Expression.TWO).subtract(ax.subtract(bx).sin().divide(Expression.TWO));
		}
		if (a instanceof Cos && b instanceof Cos) {
			return ax.subtract(bx).cos().divide(Expression.TWO).add(ax.add(bx).cos().divide(Expression.TWO));
		}
		throw new TypeError();
	};

	var contractTrigonometryPower = function (u) {
		var b = u.a;
		if (!(b instanceof Sin) && !(b instanceof Cos)) {
			return u;
		}
		var e = contractTrigonometryInternal(b, b).multiply(u.divide(b.multiply(b)));
		return contractTrigonometryRules(e.getNumerator()).divide(e.getDenominator());
	};

	var contractTrigonometryProduct = function (u) {
		var i = u.factors();
		var a = i.next().value;
		var b = i.next().value;
		var rest = Expression.ONE;
		var y = i.next().value;
		while (y != null) {
			rest = y.multiply(rest);
			y = i.next().value;
		}

		if (a instanceof Exponentiation) {
			a = contractTrigonometryPower(a);
			return contractTrigonometryRules(a.multiply(b).multiply(rest));
		}
		if (b instanceof Exponentiation) {
			b = contractTrigonometryPower(b);
			return contractTrigonometryRules(a.multiply(b).multiply(rest));
		}

		var c = contractTrigonometryInternal(a, b);

		return contractTrigonometryRules(c.multiply(rest));
	};

	var contractTrigonometryRules = function (u) {
		var v = expandMainOp(u);
		if (v instanceof Exponentiation) {
			return contractTrigonometryPower(v);
		}
		if (v instanceof Multiplication) {
			var tmp = separateSinCos(v);
			var c = tmp.other;
			var d = tmp.sinCos;
			if (d.equals(Expression.ONE)) {
				return v;
			}
			if (d instanceof Sin || d instanceof Cos) {
				return v;
			}
			if (d instanceof Exponentiation) {
				return expandMainOp(c.multiply(contractTrigonometryPower(d)));
			}
			if (d instanceof Multiplication) {
				return expandMainOp(c.multiply(contractTrigonometryProduct(d)));
			}
			throw new TypeError();
		}
		if (v instanceof Addition) {
			var s = Expression.ZERO;
			var e = v;
			for (var iteratorx = e.summands()[globalThis.Symbol.iterator](), x = iteratorx.next().value; x != null; x = iteratorx.next().value) {
				if (x instanceof Multiplication || x instanceof Exponentiation) {
					s = s.add(contractTrigonometryRules(x));
				} else {
					s = s.add(x);
				}
			}
			return s;
		}
		return v;
	};

	var map = function (f, u) {
		if (u instanceof Integer) {
			return f(u);
		}
		if (u instanceof Addition) {
			return f(map(f, u.a).add(map(f, u.b)));
		}
		if (u instanceof Multiplication) {
			return f(map(f, u.a).multiply(map(f, u.b)));
		}
		if (u instanceof Division) {
			return f(map(f, u.a).divide(map(f, u.b)));
		}
		if (u instanceof Exponentiation) {
			return f(map(f, u.a).pow(map(f, u.b)));
		}
		if (u instanceof Sin) {
			return f(map(f, u.a).sin());
		}
		if (u instanceof Cos) {
			return f(map(f, u.a).cos());
		}
		if (u instanceof Expression.Matrix) {
			return new Expression.Matrix(u.matrix.map(function (e, i, j) {
				return map(f, e);
			}));
		}
		if (u instanceof Expression.Polynomial) {
			return new Expression.Polynomial(u.polynomial.map(function (c, d) {
				return map(f, c);
			}));
		}
		if (u instanceof Expression.GF2Value) {
			return u;
		}
		if (u instanceof Expression.NthRoot) {
			return f(u);
		}
		if (u instanceof Expression.Negation) {
			return u;
		}
		if (u instanceof Expression.Complex) {
			return u;
		}
		if (u instanceof Expression.NonSimplifiedExpression) {

			return u;
		}
		if (u instanceof Expression.Degrees) {
			return u;
		}
		if (u instanceof Expression.Radians) {
			return u;
		}
		if (u instanceof Expression.Symbol) {
			return f(u);
		}
		if (u instanceof Expression.Arctan) {
			return f(map(f, u.a).arctan());
		}
		if (u instanceof Expression.Logarithm) {
			return f(map(f, u.a).logarithm());
		}
		if (u instanceof Expression.Determinant) {
			return f(map(f, u.a).determinant());
		}
		if (u instanceof Expression.Function && u.name === 'trace') {
			return f(map(f, u.a).trace());
		}
		if (u instanceof Expression.Inequality) {
			return f(map(f, u.a).transformInequality(map(f, u.b), u.sign));
		}
		if (u instanceof Expression.ComplexConjugate) {
			return f(map(f, u.a).complexConjugate());
		}
		if (u instanceof Expression.Abs) {
			return f(map(f, u.a).abs());
		}
		throw new TypeError();
	};

	Expression._map = map;

	var expandTrigonometryRulesInternal = function (a, b, type) {
		if (type === "cos") {

			return expandTrigonometryRules(a, "cos").multiply(expandTrigonometryRules(b, "cos")).subtract(expandTrigonometryRules(a, "sin").multiply(expandTrigonometryRules(b, "sin")));
		}
		if (type === "sin") {

			return expandTrigonometryRules(a, "sin").multiply(expandTrigonometryRules(b, "cos")).add(expandTrigonometryRules(a, "cos").multiply(expandTrigonometryRules(b, "sin")));
		}
		throw new TypeError(type);
	};

	var expandTrigonometryRules = function (A, type) {
		if (A instanceof Addition) {
			return expandTrigonometryRulesInternal(A.a, A.b, type);
		} else if (A instanceof Multiplication) {
			var i = Expression.ONE;
			for (var iteratory = A.factors()[globalThis.Symbol.iterator](), y = iteratory.next().value; y != null; y = iteratory.next().value) {
				if (y instanceof Expression.Integer) {
					i = i.multiply(y);
				}
			}
			var a = i;
			var b = A.divide(i);

			if (!(a instanceof Integer)) {
				throw new TypeError();
			}
			if (a.equals(Expression.ONE)) {
				if (type === "cos") {
					return A.cos();
				}
				if (type === "sin") {
					return A.sin();
				}
			}
			if (a.compareTo(Expression.ONE.negate()) === 0) {
				if (type === "cos") {
					return expandTrigonometryRules(b, type);
				}
				if (type === "sin") {
					return expandTrigonometryRules(b, type).negate();
				}
			}
			var c = a.compareTo(Expression.ZERO) > 0 ? Expression.ONE : Expression.ONE.negate();
			return expandTrigonometryRulesInternal(c.multiply(b), a.subtract(c).multiply(b), type);
		} else if (A instanceof Division) {
			var t = simplifyConstantValue(A, type);
			if (t != null) {
				return t;
			}
			var a = A.a;
			var b = A.b;
			if (a instanceof Addition) {
				return expandTrigonometryRulesInternal(a.a.divide(b), a.b.divide(b), type);
			}
		}
		if (A instanceof Expression.Symbol || A instanceof Expression.Exponentiation && A.a instanceof Expression.Symbol && Expression.isScalar(A.a) && A.b instanceof Expression.Integer && A.b.compareTo(Expression.ONE) > 0 || A instanceof Expression.Degrees || A instanceof Expression.Radians || A instanceof Expression.Complex || A instanceof Expression.Arctan) {
			if (type === "cos") {
				return A.cos();
			}
			if (type === "sin") {
				return A.sin();
			}
		}
		throw new TypeError();
	};

	var expandTrigonometry = function (u) {
		return map(function (v) {
			if (v instanceof Sin) {
				return expandTrigonometryRules(v.a, "sin");
			}
			if (v instanceof Cos) {
				return expandTrigonometryRules(v.a, "cos");
			}
			return v;
		}, u);
	};

	Expression._expandTrigonometry = expandTrigonometry;

	var contractTrigonometry = function (u) {
		return map(function (v) {
			if (v instanceof Multiplication || v instanceof Exponentiation || v instanceof Addition) {
				return contractTrigonometryRules(v);
			}
			if (v instanceof Division) {
				return contractTrigonometryRules(v.getNumerator()).divide(v.getDenominator());
			}
			return v;
		}, u);
	};

	var hasTrigonometry = function (e) {
		if (e instanceof BinaryOperation) {
			return hasTrigonometry(e.a) || hasTrigonometry(e.b);
		}
		return e instanceof Cos || e instanceof Sin;
	};

	var simplifyTrigonometry = function (u) {
		if (!hasTrigonometry(u)) {
			return u;
		}

		var v = null;
		var r = null;
		Expression._map(function (e) {

			if (e instanceof Expression.Sin || e instanceof Expression.Cos) {
				var a = e.a;
				if (a instanceof Division) {
					var n = a.getNumerator();
					var d = a.getDenominator();
					if (!d.equals(Expression.ONE)) {
						for (var iteratorx = n.summands()[globalThis.Symbol.iterator](), x = iteratorx.next().value; x != null; x = iteratorx.next().value) {
							var g = x.gcd(d);
							if (!g.equals(d)) {
								for (var iteratory = x.factors()[globalThis.Symbol.iterator](), y = iteratory.next().value; y != null; y = iteratory.next().value) {
									if (y instanceof Expression.Symbol && y !== Expression.PI) {
										r = d.divide(g);
										v = y;
									}
								}
							}
						}
					}
				}
			}
			return e;
		}, u);
		if (v != null && r != null) {

			u = Expression._substitute(u, v, v.multiply(r), v.divide(r));
			u = simplifyTrigonometry(u);

			u = Expression._substitute(u, v, v.divide(r), v.multiply(r));
			return u;
		}

		var n = u.getNumerator();
		n = expandTrigonometry(n);
		n = contractTrigonometry(n);
		var d = u.getDenominator();
		d = expandTrigonometry(d);
		d = contractTrigonometry(d);
		return n.divide(d);
	};

	Expression.Division.prototype.compare4Multiplication = function (y) {
		if (y instanceof Division) {
			return this.a.compare4Multiplication(y.a) || this.b.compare4Multiplication(y.b);
		}
		return -1;
	};
	Expression.Division.prototype.compare4MultiplicationSymbol = function () {
		return +1;
	};
	Expression.Division.prototype.compare4MultiplicationInteger = function () {
		return +1;
	};
	Expression.Division.prototype.compare4MultiplicationNthRoot = function () {
		return +1;
	};

	Expression.simplifyTrigonometry = simplifyTrigonometry;

	function Sin(x) {
		Expression.Function.call(this, "sin", x);
	}

	Sin.prototype = Object.create(Expression.Function.prototype);

	var simplifyConstantValueInternal = function (d, fraction) {
		fraction = fraction || Expression.ZERO;
		if (d >= +360 || d <= -360) {
			throw new RangeError();
		}
		if (d < 0) {
			d = 0 - d;
			fraction = fraction.negate();
		}
		if (d >= 180) {
			d = d - 180;
			var tmp = simplifyConstantValueInternal(d, fraction);
			return tmp == null ? null : tmp.negate();
		}
		if (d > 90) {
			d = 0 - d;
			fraction = fraction.negate();
			d = d + 180;
			var tmp = simplifyConstantValueInternal(d, fraction);
			return tmp == null ? null : tmp.negate();
		}
		console.assert(d >= 0 && d <= 90);
		console.assert(fraction.getNumerator().abs().compareTo(fraction.getDenominator()) < 0);

		function f(x) {

			var y = simplifyConstantValueInternal(x * 2);
			return y == null ? null : Expression.TWO.add(Expression.TWO.multiply(y)).squareRoot().divide(Expression.TWO);
		}

		function cosapb(a, b) {
			var cosa = simplifyConstantValueInternal(a);
			var cosb = simplifyConstantValueInternal(b);
			var sina = simplifyConstantValueInternal(90 - a);
			var sinb = simplifyConstantValueInternal(90 - b);
			return cosa.multiply(cosb).subtract(sina.multiply(sinb));
		}

		function phi() {
			return Expression.ONE.add(Expression.TWO.add(Expression.TWO).add(Expression.ONE).squareRoot()).divide(Expression.TWO);
		}

		if (fraction.equals(Expression.ZERO)) {
			if (d === 0) {
				return Expression.ONE;
			}
			if (d === 30) {
				return Expression.ONE.add(Expression.TWO).squareRoot().divide(Expression.TWO);
			}
			if (d === 45) {
				return Expression.ONE.divide(Expression.TWO.squareRoot());
			}
			if (d === 60) {
				return Expression.ONE.divide(Expression.TWO);
			}
			if (d === 90) {
				return Expression.ZERO;
			}

			if (d === 15) {
				return f(d);
			}
			if (d === 75) {
				return f(d);
			}

			if (d === 36) {
				return phi().divide(Expression.TWO);
			}
			if (d === 72) {
				return phi().subtract(Expression.ONE).divide(Expression.TWO);
			}

			if (d === 18) {
				return Expression.TWO.add(phi()).squareRoot().divide(Expression.TWO);
			}

			if (d === 54) {

				return Expression.TWO.add(Expression.ONE).subtract(phi()).squareRoot().divide(Expression.TWO);
			}

			if (d % 3 === 0) {
				var a = 90 - (Math.floor(d / 3) % 6) * 15;
				var b = -(a - d);
				return cosapb(a, b);
			}
		}

		if (fraction.multiply(Expression.TWO).getDenominator().equals(Expression.ONE)) {
			var dd = d + fraction.multiply(Expression.TWO).toNumber() / 2;
			if (dd === 7.5) {
				return cosapb(30, -22.5);
			}
			if (dd === 22.5) {
				return f(dd);
			}
			if (dd === 37.5) {
				return cosapb(60, -22.5);
			}
			if (dd === 52.5) {
				return cosapb(30, +22.5);
			}
			if (dd === 67.5) {
				return f(dd);
			}
			if (dd === 82.5) {
				return cosapb(60, +22.5);
			}
		}

		if (d % 1 === 0) {
			var rational = Integer.fromNumber(d).add(fraction).divide(Integer.fromNumber(60));

			var n = rational.getDenominator().toNumber();
			var a = rational.getNumerator().toNumber();
			if (n > Number.MAX_SAFE_INTEGER || a > Number.MAX_SAFE_INTEGER) {
				return undefined;
			}
			var T = function (n) {

				var x = Polynomial.of(Expression.ZERO, Expression.ONE);
				var Tprevious = Polynomial.of(Expression.ONE);
				var Tcurrent = x;
				var i = 1;
				while (i < n) {
					var Tnext = Polynomial.of(Expression.TWO).multiply(x).multiply(Tcurrent).subtract(Tprevious);
					Tprevious = Tcurrent;
					Tcurrent = Tnext;
					i += 1;
				}
				return Tcurrent;
			};
			var polynomial = T(n).subtract(Polynomial.of(simplifyConstantValueInternal(60 * (a % 6), Expression.ZERO)));
			polynomial = polynomial.scale(polynomial.getContent().inverse());

			var approximate = Math.cos((d + fraction.getNumerator().toNumber() / fraction.getDenominator().toNumber()) / 180 * Math.PI);
			var tmp = Math.floor(approximate * Math.pow(2, 24) + 0.5);
			var scale = Expression.Integer.fromNumber(Math.pow(2, 24));
			var interval = {
				a: Expression.Integer.fromNumber(tmp - 1).divide(scale),
				b: Expression.Integer.fromNumber(tmp + 1).divide(scale)
			};
			return Expression.ExpressionPolynomialRoot.create(polynomial, interval);
		}

		return undefined;
	};

	var simplifyConstantValue = function (x, type) {
		var a = undefined;
		var b = undefined;
		if (x instanceof Integer && x.compareTo(Expression.ZERO) === 0) {
			a = Expression.ZERO;
			b = Expression.ONE;
		} else if (x === Expression.PI) {
			a = Expression.ONE;
			b = Expression.ONE;
		} else if (x instanceof Multiplication && x.a instanceof Integer && x.b === Expression.PI) {
			a = x.a;
			b = Expression.ONE;
		} else if (x instanceof Division && x.b instanceof Integer && x.a === Expression.PI) {
			a = Expression.ONE;
			b = x.b;
		} else if (x instanceof Division && x.b instanceof Integer && x.a instanceof Multiplication && x.a.a instanceof Integer && x.a.b === Expression.PI) {
			a = x.a.a;
			b = x.b;
		} else if (x instanceof Expression.Degrees) {
			var t = x.value.simplify();
			t = t.multiply(Expression.PI).divide(Integer.fromNumber(180));
			if (type === 'sin') {
				return t.sin();
			}
			if (type === 'cos') {
				return t.cos();
			}
		}
		if (a != undefined && b != undefined) {

			var integer = a.multiply(Integer.fromNumber(180)).truncatingDivide(b);
			var fraction = a.multiply(Integer.fromNumber(180)).subtract(integer.multiply(b)).divide(b);

			var d = integer.remainder(Integer.fromNumber(360)).toNumber();
			if (type === "sin") {
				d = 90 - d;
				fraction = fraction.negate();
				if (d >= 360 - 90) {
					d -= 360;
				}
			} else if (type !== "cos") {
				throw new TypeError();
			}
			return simplifyConstantValueInternal(d, fraction);

		}
		if (x instanceof Expression.Radians && x.value.equals(Expression.ZERO)) {
			return simplifyConstantValue(x.value, type);
		}
		if (Expression.has(x, Expression.Complex)) {
			if (type === "sin") {
				return Expression.I.multiply(x.divide(Expression.I).sinh());
			}
			if (type === "cos") {
				return x.divide(Expression.I).cosh();
			}
		}
		if (x instanceof Expression.Arctan) {
			if (Expression.callback != undefined) {
				Expression.callback(new Expression.Event("trigonometric-function-of-inverse-trigonometric-function-arg", new Expression.Matrix(Matrix.I(1))));
			}

			var a = x.a;
			if (type === "sin") {

				return a.getNumerator().divide(a.getDenominator()._pow(2).add(a.getNumerator()._pow(2)).squareRoot());
			}
			if (type === "cos") {

				return a.getDenominator().divide(a.getDenominator()._pow(2).add(a.getNumerator()._pow(2)).squareRoot());
			}

		}
		if (x instanceof Expression.ExpressionWithPolynomialRoot) {
			return simplifyConstantValue(x.upgrade(), type);
		}
		return undefined;
	};

	Expression.prototype.cosh = function () {
		var a = this;
		return a.exp().add(a.negate().exp()).divide(Expression.TWO);
	};

	Expression.prototype.sinh = function () {
		var a = this;
		return a.exp().subtract(a.negate().exp()).divide(Expression.TWO);
	};

	Expression.prototype.tanh = function () {
		var a = this;
		return a.exp().subtract(a.negate().exp()).divide(a.exp().add(a.negate().exp()));
	};

	Expression.prototype.coth = function () {
		var a = this;
		return a.exp().add(a.negate().exp()).divide(a.exp().subtract(a.negate().exp()));
	};

	Expression.prototype.arccos = function () {
		var a = this;

		return a.arcsin().subtract(Expression.PI.divide(Expression.TWO)).negate();
	};

	Expression.prototype.arcsin = function () {
		var a = this;

		return a.divide(a.pow(Expression.TWO).subtract(Expression.ONE).negate().squareRoot()).arctan();
	};

	Expression.prototype.arccot = function () {
		var a = this;

		return a.arctan().subtract(Expression.PI.divide(Expression.TWO)).negate();
	};

	Expression.prototype.arcosh = function () {
		var x = this;

		return x.add(x.multiply(x).subtract(Expression.ONE).squareRoot()).logarithm();
	};
	Expression.prototype.arsinh = function () {
		var x = this;

		return x.add(x.multiply(x).add(Expression.ONE).squareRoot()).logarithm();
	};
	Expression.prototype.artanh = function () {
		var x = this;

		return x.add(Expression.ONE).divide(x.subtract(Expression.ONE).negate()).logarithm().divide(Expression.TWO);
	};
	Expression.prototype.arcoth = function () {
		var x = this;

		return x.add(Expression.ONE).divide(x.subtract(Expression.ONE)).logarithm().divide(Expression.TWO);
	};

	Expression.isRealAlgebraicNumber = function isRealAlgebraicNumber(x) {
		return x instanceof Expression.Integer || x instanceof Expression.NthRoot && typeof x.n === "number" && x.n % 1 === 0 && isRealAlgebraicNumber(x.a) && (x.n % 2 !== 0 || Expression._isPositive(x.a)) || x instanceof Expression.Division && isRealAlgebraicNumber(x.getNumerator()) && isRealAlgebraicNumber(x.getDenominator()) || x instanceof Expression.Addition && isRealAlgebraicNumber(x.a) && isRealAlgebraicNumber(x.b) || x instanceof Expression.Multiplication && isRealAlgebraicNumber(x.a) && isRealAlgebraicNumber(x.b);
	};

	var isArgumentValid = function (x, type) {
		if (x instanceof Expression.Radians) {

			return Expression.isRealAlgebraicNumber(x.value);
		}
		if (x instanceof Expression.Degrees) {
			return simplifyConstantValue(x, type) != undefined;
		}
		if (x instanceof Expression.Symbol) {
			return Expression.isScalar(x);
		}
		if (x instanceof Expression.Exponentiation) {

			return x.a instanceof Expression.Symbol && Expression.isScalar(x.a) && x.b instanceof Expression.Integer && x.b.compareTo(Expression.ONE) > 0;
		}
		if (x instanceof Addition) {
			return isArgumentValid(x.a, type) && isArgumentValid(x.b, type);
		}
		if (x instanceof Expression.Arctan) {
			return true;
		}
		if (x instanceof Multiplication) {
			if (x.a instanceof Integer && Expression.isScalar(x.b) && x.b instanceof Expression.Symbol) {
				return true;
			}
			if (x.a instanceof Integer && Expression.isScalar(x.b) && x.b instanceof Expression.Arctan) {
				return true;
			}
			if (Expression.isScalar(x.b) && x.b instanceof Expression.Symbol) {
				if (x.a instanceof Expression.NthRoot && x.a.a instanceof Integer) {
					return true;
				}
				if (x.a instanceof Multiplication && x.a.a instanceof Integer && x.a.b instanceof Expression.NthRoot && x.a.b.a instanceof Integer) {
					return true;
				}
			}
			var c = Expression.getConstant(x);
			var t = x.divide(c);
			if (Expression.isScalar(x) && (c instanceof Integer || c instanceof Expression.Complex) && (t instanceof Multiplication || t instanceof Expression.Symbol || t instanceof Expression.Exponentiation)) {
				for (var iteratory = t.factors()[globalThis.Symbol.iterator](), y = iteratory.next().value; y != null; y = iteratory.next().value) {
					if (!(y instanceof Expression.NthRoot) && !(y instanceof Expression.Symbol) && !(y instanceof Expression.Exponentiation && y.a instanceof Expression.Symbol && Expression.isScalar(y.a) && y.b instanceof Expression.Integer && y.b.compareTo(Expression.ONE) > 0)) {
						return false;
					}
				}

				return true;
			}
		}
		if (x instanceof Division) {
			if (x.b instanceof Integer) {
				return isArgumentValid(x.a);
			}
		}
		if (x instanceof Expression.Complex) {
			return true;
		}
		return false;
	};

	Expression.prototype.sin = function () {
		var x = this;
		var t = simplifyConstantValue(x, "sin");
		if (t != undefined) {
			return t;
		}
		if (x.isNegative()) {
			return x.negate().sin().negate();
		}
		if (!isArgumentValid(x, "sin")) {
			throw new RangeError("NotSupportedError");
		}
		return new Sin(x);
	};

	function Cos(x) {
		Expression.Function.call(this, "cos", x);
	}

	Cos.prototype = Object.create(Expression.Function.prototype);

	Expression.prototype.cos = function () {
		var x = this;
		var t = simplifyConstantValue(x, "cos");
		if (t != undefined) {
			return t;
		}
		if (x.isNegative()) {
			return x.negate().cos();
		}
		if (!isArgumentValid(x, "cos")) {
			throw new RangeError("NotSupportedError");
		}
		return new Cos(x);
	};

	Expression.simplifications.push(Expression.simplifyTrigonometry);

	Expression.Sin = Sin;
	Expression.Cos = Cos;

	Expression.Addition.prototype.compare4Addition = function (y) {

		var x = this;
		return Expression.Addition.compare4Addition(x, y);
	};

	Expression.Multiplication.prototype.compare4MultiplicationInteger = function (x) {
		return -1;
	};

	Expression.Addition.prototype.compare4Multiplication = function (y) {
		if (y instanceof Integer) {
			return -1;
		}
		if (y instanceof Expression.MatrixSymbol) {
			return +1;
		}

		var x = this;
		var i = x.summands();
		var j = y.summands();
		var a = i.next().value;
		var b = j.next().value;
		while (a != null && b != null) {
			var c = a.compare4Multiplication(b);
			if (c !== 0) {
				return c;
			}
			a = i.next().value;
			b = j.next().value;
		}
		return a != null ? +1 : (b != null ? -1 : 0);
	};

	Expression.Addition.prototype.compare4MultiplicationSymbol = function (x) {
		return 0 - this.compare4Multiplication(x);
	};

	Expression.Addition.prototype.compare4MultiplicationInteger = function (x) {
		return +1;
	};

	Expression.Addition.compare4Addition = function (x, y) {
		var i = x.summands();
		var j = y.summands();
		var a = i.next().value;
		var b = j.next().value;
		while (a != null && b != null) {
			var c = a.compare4Addition(b);
			if (c !== 0) {
				return c;
			}
			a = i.next().value;
			b = j.next().value;
		}
		return a != null ? +1 : (b != null ? -1 : 0);
	};

	Expression.Unit = function (value) {
		this.value = value;
	};
	Expression.Unit.prototype = Object.create(Expression.prototype);
	Expression.Unit.prototype.toString = function (options) {
		var b = this.value;
		var fb = b instanceof Expression.Integer ? false : true;
		return (fb ? "(" : "") + b.toString(options) + (fb ? ")" : "") + this.unitSymbol();
	};
	Expression.Unit.prototype.equals = function (y) {
		return y instanceof Expression.Unit && this.unitSymbol() === y.unitSymbol() && this.value.equals(y.value);
	};
	Expression.Unit.prototype.compare4AdditionSymbol = function (x) {

		return x.compare4Addition(this.value);
	};
	Expression.Unit.prototype.compare4Addition = function (y) {
		return this.value.compare4Addition(y instanceof Expression.Unit && this.unitSymbol() === y.unitSymbol() ? y.value : y);
	};
	Expression.Unit.prototype.compare4Multiplication = function (y) {
		return this.value.compare4Multiplication(y instanceof Expression.Unit && this.unitSymbol() === y.unitSymbol() ? y.value : y);
	};
	Expression.Unit.prototype.compare4MultiplicationSymbol = function (x) {
		return x.compare4Multiplication(this.value);
	};
	Expression.Unit.prototype.compare4MultiplicationInteger = function (x) {
		return +1;
	};
	Expression.Unit.prototype.negate = function () {
		return this.create(this.value.negate());
	};
	Expression.Unit.prototype.multiply = function (y) {
		return this.create(this.value.multiply(y));
	};
	Expression.Unit.prototype.multiplyInteger = function (x) {
		return this.create(x.multiply(this.value));
	};

	Expression.Unit.prototype.add = function (y) {
		if (y instanceof Expression.Unit && this.unitSymbol() === y.unitSymbol()) {
			var x = this.value.add(y.value);
			if (x.equals(Expression.ZERO)) {
				return x;
			}
			return this.create(x);
		}
		return Expression.prototype.add.call(this, y);
	};

	Expression.Degrees = function (value) {
		Expression.Unit.call(this, value);
	};
	Expression.Degrees.prototype = Object.create(Expression.Unit.prototype);
	Expression.Degrees.prototype.unitSymbol = function () {
		return "\u00B0";
	};
	Expression.Degrees.prototype.create = function (value) {
		return new Expression.Degrees(value);
	};

	Expression.Radians = function (value) {
		this.value = value;
	};
	Expression.Radians.prototype = Object.create(Expression.Unit.prototype);
	Expression.Radians.prototype.unitSymbol = function () {
		return " rad";
	};
	Expression.Radians.prototype.create = function (value) {
		return new Expression.Radians(value);
	};

	Expression.Matrix.prototype.sin = function () {
		var X = this;
		var i = Expression.I;
		var TWO = Expression.TWO;
		return i.multiply(X).exp().subtract(i.negate().multiply(X).exp()).divide(TWO.multiply(i));
	};
	Expression.Matrix.prototype.cos = function () {
		var X = this;
		var i = Expression.I;
		var TWO = Expression.TWO;
		return i.multiply(X).exp().add(i.negate().multiply(X).exp()).divide(TWO);
	};

	(function () {
		var i = new Expression.Symbol('_i');

		function replaceSinCos(e) {
			return Expression._map(function (x) {
				if (x instanceof Expression.Sin) {
					var a = x.a;

					return i.multiply(a).exp().subtract(i.multiply(a).negate().exp()).divide(Expression.TWO.multiply(Expression.I));
				}
				if (x instanceof Expression.Cos) {
					var a = x.a;

					return i.multiply(a).exp().add(i.multiply(a).negate().exp()).divide(Expression.TWO);
				}
				return x;
			}, e);
		}

		function replaceBySinCos(e) {
			return Expression._map(function (x) {
				if (x instanceof Expression.Exponentiation && x.a === Expression.E) {
					var b = x.b;

					var p = Polynomial.toPolynomial(b.getNumerator(), i).scale(b.getDenominator().inverse());
					if (p.getDegree() === 1) {
						var q = p.getCoefficient(0);
						var w = p.getCoefficient(1);

						return w.cos().add(Expression.I.multiply(w.sin())).multiply(q.exp());
					}
					if (p.getDegree() > 1) {
						throw new TypeError("!?");
					}
				}
				return x;
			}, e);
		}

		Expression._replaceSinCos = replaceSinCos;
		Expression._replaceBySinCos = replaceBySinCos;
	}());

	function Arctan(x) {
		Expression.Function.call(this, "arctan", x);
	}

	Arctan.prototype = Object.create(Expression.Function.prototype);
	Expression.Arctan = Arctan;

	function getlowestfraction(x0) {
		var eps = 1.0E-15;
		var h,
			h1,
			h2,
			k,
			k1,
			k2,
			a,
			x;

		x = x0;
		a = Math.floor(x);
		h1 = 1;
		k1 = 0;
		h = a;
		k = 1;

		while (x - a > eps * k * k) {
			x = 1 / (x - a);
			a = Math.floor(x);
			h2 = h1;
			h1 = h;
			k2 = k1;
			k1 = k;
			h = h2 + a * h1;
			k = k2 + a * k1;
		}

		return h + "/" + k;
	}

	Expression.prototype.arctan = function () {
		var x = this;
		if (x.isNegative()) {
			return x.negate().arctan().negate();
		}
		if (Expression.isConstant(x) && !(x instanceof Expression.Logarithm)) {
			if (x instanceof Expression.Complex) {

				return Expression.I.subtract(x).divide(Expression.I.add(x)).logarithm().divide(Expression.TWO.multiply(Expression.I));
			}
			var value = Number(toDecimalStringInternal(x, {fractionDigits: 15}));
			console.assert(!Number.isNaN(value));
			var tmp = getlowestfraction(Math.atan(value) / Math.PI).split("/");
			var guess = Expression.Integer.fromNumber(Number(tmp[0])).divide(Expression.Integer.fromNumber(tmp[1])).multiply(Expression.PI);
			if (guess.getDenominator().toNumber() < 10000 && guess.tan().subtract(x).equals(Expression.ZERO)) {
				return guess;
			}
			throw new RangeError("NotSupportedError");
		}
		if (x instanceof Division) {
			var n = x.getNumerator();
			var d = x.getDenominator();
			if (d.subtract(Expression.ONE).subtract(n).multiply(d.subtract(Expression.ONE).add(n)).subtract(Expression.ONE).equals(Expression.ZERO)) {
				var y = Expression.TWO.multiply(x).divide(Expression.ONE.subtract(x._pow(2)));
				return (new Arctan(y)).divide(Expression.TWO);
			}
		}
		if (x instanceof Expression.Matrix) {
			if (x.matrix.isDiagonal()) {
				return new Expression.Matrix(x.matrix.map(function (e, i, j) {
					return i === j ? e.arctan() : Expression.ZERO;
				}));
			}

			return Expression.I.subtract(x).divide(Expression.I.add(x)).logarithm().divide(Expression.TWO.multiply(Expression.I));
		}

		return new Arctan(x);
	};

	Expression.prototype.tan = function () {
		var a = this;

		var a2 = a.multiply(Expression.TWO);
		return a2.sin().divide(a2.cos().add(Expression.ONE));
	};
	Expression.prototype.cot = function () {
		var a = this;
		if (a instanceof Expression.Matrix) {
			return a.cos().divide(a.sin());
		}

		var a2 = a.multiply(Expression.TWO);
		return a2.cos().add(Expression.ONE).divide(a2.sin());
	};

	Expression.Radians.prototype.complexConjugate = function () {
		return new Expression.Radians(this.value.complexConjugate());
	};
	Expression.Sin.prototype.complexConjugate = function () {
		return this.a.complexConjugate().sin();
	};
	Expression.Cos.prototype.complexConjugate = function () {
		return this.a.complexConjugate().cos();
	};

	Expression.Sin.prototype.compare4MultiplicationExponentiation = function () {
		return -1;
	};
}

function ComplexNumbers() {
	var Integer = Expression.Integer;

	function Complex(real, imaginary) {

		if (!(real instanceof Integer) || !(imaginary instanceof Integer) || imaginary.compareTo(Expression.ZERO) === 0) {
			throw new RangeError();
		}
		this.real = real;
		this.imaginary = imaginary;
	}

	Complex.prototype = Object.create(Expression.prototype);

	Expression.I = new Complex(Expression.ZERO, Expression.ONE);
	Expression.Complex = Complex;

	Complex.prototype.add = function (y) {
		return y.addComplex(this);
	};
	Expression.prototype.addComplex = function (x) {
		return this.addExpression(x);
	};
	Integer.prototype.addComplex = function (x) {
		return new Complex(x.real.add(this), x.imaginary);
	};
	Complex.prototype.addComplex = function (x) {
		var real = x.real.add(this.real);
		var imaginary = x.imaginary.add(this.imaginary);
		return imaginary.compareTo(Expression.ZERO) === 0 ? real : new Complex(real, imaginary);
	};
	Complex.prototype.addInteger = function (x) {
		return new Complex(x.add(this.real), this.imaginary);
	};

	Complex.prototype.equals = function (y) {
		return y instanceof Complex && this.real.equals(y.real) && this.imaginary.equals(y.imaginary) ? true : false;
	};

	Complex.prototype.compare4AdditionSymbol = function (x) {
		return +1;
	};
	Complex.prototype.compare4MultiplicationNthRoot = function (x) {
		return +1;
	};
	Complex.prototype.compare4Addition = function (y) {
		if (y instanceof Complex) {
			if (this.equals(y)) {
				return 0;
			}
			return this.real.compareTo(y.real) || this.imaginary.compareTo(y.imaginary);
		}
		if (y instanceof Integer) {
			return +1;
		}
		if (y instanceof Expression.Division) {
			return Expression.prototype.compare4Addition.call(this, y);
		}
		if (y instanceof Expression.Exponentiation) {
			return Expression.prototype.compare4Addition.call(this, y);
		}
		if (y instanceof Expression.Matrix) {
			return Expression.prototype.compare4Addition.call(this, y);
		}
		return -1;
	};

	Complex.prototype.compare4Multiplication = function (y) {
		if (y instanceof Complex) {
			if (y.equals(this)) {
				return 0;
			}
			return this.real.abs().compareTo(y.real.abs()) || this.imaginary.abs().compareTo(y.imaginary.abs());

		}
		return y.compare4MultiplicationComplex(this);
	};
	Expression.prototype.compare4MultiplicationComplex = function (x) {
		return -1;
	};
	Complex.prototype.compare4MultiplicationSymbol = function (x) {
		return +1;
	};
	Complex.prototype.multiply = function (y) {
		return y.multiplyComplex(this);
	};
	Complex.prototype.multiplyComplex = function (x) {
		var real = x.real.multiply(this.real).subtract(x.imaginary.multiply(this.imaginary));
		var imaginary = x.real.multiply(this.imaginary).add(x.imaginary.multiply(this.real));
		return imaginary.compareTo(Expression.ZERO) === 0 ? real : new Complex(real, imaginary);
	};
	Expression.prototype.multiplyComplex = function (x) {
		return this.multiplyExpression(x);
	};
	Integer.prototype.multiplyComplex = function (x) {
		if (this.compareTo(Expression.ZERO) === 0) {
			return this;
		}
		return new Complex(x.real.multiply(this), x.imaginary.multiply(this));
	};
	Complex.prototype.multiplyInteger = function (x) {
		if (x.compareTo(Expression.ZERO) === 0) {
			return x;
		}
		return new Complex(x.multiply(this.real), x.multiply(this.imaginary));
	};

	Complex.prototype.conjugate = function () {
		return new Complex(this.real, this.imaginary.negate());
	};

	Complex.prototype.getPrecedence = function () {
		return this.real.equals(Expression.ZERO) ? (this.imaginary.equals(Expression.ONE) ? 1000 : 3) : 2;
	};

	Complex.prototype.truncatingDivide = function (f) {
		if (f instanceof Integer) {
			return new Complex(this.real.truncatingDivide(f), this.imaginary.truncatingDivide(f));
		}
		return this.multiply(f.conjugate()).truncatingDivide(f.multiply(f.conjugate()));
	};

	Complex.prototype.toStringInternal = function (options, times, i, minus, plus, start, end, toString) {
		if (this.real.equals(Expression.ZERO)) {
			if (this.imaginary.equals(Expression.ONE)) {
				return i;
			}
			if (this.imaginary.equals(Expression.ONE.negate())) {
				return start + minus + i + end;
			}
			return start + toString(this.imaginary, options) + times + i + end;
		}
		var isNegative = this.imaginary.isNegative();
		var imaginary = (isNegative ? this.imaginary.negateCarefully() : this.imaginary);
		var si = (imaginary.equals(Expression.ONE) ? i : start + toString(imaginary, options) + times + i + end);
		var sr = toString(this.real, options);
		return start + sr + (isNegative ? minus : plus) + si + end;
	};

	Complex.prototype.toString = function (options) {
		return this.toStringInternal(options, "", "i", "-", "+", "", "", function (x, options) {
			return x.toString(options);
		});
	};

	Complex.prototype.compare4MultiplicationInteger = function (x) {
		return +1;
	};

	Complex.prototype.remainderInteger = function (x) {
		return Complex.prototype.remainder.call(x, this);
	};

	Complex.prototype.remainder = function (y) {
		function norm(x) {
			return x instanceof Expression.Integer ? x.multiply(x) : x.multiply(x.conjugate());
		}

		var x = this;
		var n = y instanceof Expression.Integer ? x : x.multiply(y.conjugate());
		var d = y instanceof Expression.Integer ? y : y.multiply(y.conjugate());

		var q1 = (n instanceof Complex ? n.real : n).roundDivision(d);
		var q2 = (n instanceof Complex ? n.imaginary : Expression.ZERO).roundDivision(d);
		var q = q2.compareTo(Expression.ZERO) === 0 ? q1 : new Complex(q1, q2);
		var r = x.subtract(y.multiply(q));
		if (norm(r).compareTo(norm(y)) >= 0) {
			throw new TypeError();
		}
		return r;
	};

	Complex.prototype.primeFactor = function () {
		return QuadraticInteger._complexIntegerPrimeFactor(this.real.toBigInt(), this.imaginary.toBigInt());
	};

	Expression.Complex = Complex;

	Expression.Complex.prototype.complexConjugate = function () {
		return this.conjugate();
	};

	Expression.Complex.prototype.compare4MultiplicationExponentiation = function () {
		return +1;
	};
}

function NonSimplifiedExpression() {
	var idCounter = 0;

	function NonSimplifiedExpression(e, position, length, input) {

		this.e = e;
		this.position = position == undefined ? -1 : position;
		this.length = length == undefined ? -1 : length;
		this.input = input == undefined ? "" : input;
		this.id = (idCounter += 1);
	}

	NonSimplifiedExpression.prototype = Object.create(Expression.prototype);

	NonSimplifiedExpression.prototype.negate = function () {
		return new NonSimplifiedExpression(new Expression.Negation(this));
	};
	NonSimplifiedExpression.prototype.add = function (y) {
		return new NonSimplifiedExpression(new Expression.Addition(this, y));
	};
	NonSimplifiedExpression.prototype.subtract = function (y) {
		return new NonSimplifiedExpression(new Expression.Subtraction(this, y));
	};
	NonSimplifiedExpression.prototype.divide = function (y) {
		return new NonSimplifiedExpression(new Expression.Division(this, y));
	};
	NonSimplifiedExpression.prototype.multiply = function (y) {
		return new NonSimplifiedExpression(new Expression.Multiplication(this, y));
	};
	NonSimplifiedExpression.prototype.pow = function (y) {
		return new NonSimplifiedExpression(new Expression.Exponentiation(this, y));
	};

	NonSimplifiedExpression.prototype.exp = function () {
		return new NonSimplifiedExpression(Expression.E).pow(this);
	};
	NonSimplifiedExpression.prototype.logarithm = function () {
		return new NonSimplifiedExpression(new Expression.Logarithm(this));
	};
	NonSimplifiedExpression.prototype.inverse = function () {
		return new NonSimplifiedExpression(new Expression.Exponentiation(this, Expression.ONE.negate()));

	};

	NonSimplifiedExpression.prototype.factorial = function () {
		return new NonSimplifiedExpression(new Expression.Factorial(this));
	};

	NonSimplifiedExpression.prototype.addExpression = function (x) {
		throw new TypeError();
	};

	NonSimplifiedExpression.prototype.squareRoot = function () {
		return new NonSimplifiedExpression(new Expression.SquareRoot(this));
	};
	NonSimplifiedExpression.prototype._nthRoot = function (n) {
		return new NonSimplifiedExpression(new Expression.NthRoot(n + "-root", this, n));
	};
	NonSimplifiedExpression.prototype.abs = function () {
		return new NonSimplifiedExpression(new Expression.Function("abs", this));
	};
	NonSimplifiedExpression.prototype.gcd = function () {
		return new NonSimplifiedExpression(new Expression.Function("gcd", this));
	};
	NonSimplifiedExpression.prototype.min = function () {
		return new NonSimplifiedExpression(new Expression.Function("min", this));
	};
	NonSimplifiedExpression.prototype.max = function () {
		return new NonSimplifiedExpression(new Expression.Function("max", this));
	};
	NonSimplifiedExpression.prototype.cos = function () {
		return new NonSimplifiedExpression(new Expression.Function("cos", this));
	};
	NonSimplifiedExpression.prototype.sin = function () {
		return new NonSimplifiedExpression(new Expression.Function("sin", this));
	};
	NonSimplifiedExpression.prototype.tan = function () {
		return new NonSimplifiedExpression(new Expression.Function("tan", this));
	};
	NonSimplifiedExpression.prototype.cot = function () {
		return new NonSimplifiedExpression(new Expression.Function("cot", this));
	};
	NonSimplifiedExpression.prototype.cosh = function () {
		return new NonSimplifiedExpression(new Expression.Function("cosh", this));
	};
	NonSimplifiedExpression.prototype.sinh = function () {
		return new NonSimplifiedExpression(new Expression.Function("sinh", this));
	};
	NonSimplifiedExpression.prototype.tanh = function () {
		return new NonSimplifiedExpression(new Expression.Function("tanh", this));
	};
	NonSimplifiedExpression.prototype.coth = function () {
		return new NonSimplifiedExpression(new Expression.Function("coth", this));
	};
	NonSimplifiedExpression.prototype.arccos = function () {
		return new NonSimplifiedExpression(new Expression.Function("arccos", this));
	};
	NonSimplifiedExpression.prototype.arcsin = function () {
		return new NonSimplifiedExpression(new Expression.Function("arcsin", this));
	};
	NonSimplifiedExpression.prototype.arctan = function () {
		return new NonSimplifiedExpression(new Expression.Function("arctan", this));
	};
	NonSimplifiedExpression.prototype.arccot = function () {
		return new NonSimplifiedExpression(new Expression.Function("arccot", this));
	};
	NonSimplifiedExpression.prototype.arcosh = function () {
		return new NonSimplifiedExpression(new Expression.Function("arcosh", this));
	};
	NonSimplifiedExpression.prototype.arsinh = function () {
		return new NonSimplifiedExpression(new Expression.Function("arsinh", this));
	};
	NonSimplifiedExpression.prototype.artanh = function () {
		return new NonSimplifiedExpression(new Expression.Function("artanh", this));
	};
	NonSimplifiedExpression.prototype.arcoth = function () {
		return new NonSimplifiedExpression(new Expression.Function("arcoth", this));
	};
	NonSimplifiedExpression.prototype.rank = function () {
		return new NonSimplifiedExpression(new Expression.Rank(this));
	};
	NonSimplifiedExpression.prototype.determinant = function () {
		return new NonSimplifiedExpression(new Expression.Determinant(this));
	};
	NonSimplifiedExpression.prototype.trace = function () {
		return new NonSimplifiedExpression(new Expression.Function("trace", this));
	};
	NonSimplifiedExpression.prototype.LLL = function () {
		return new NonSimplifiedExpression(new Expression.Function("LLL", this));
	};
	NonSimplifiedExpression.prototype.HNF = function () {
		return new NonSimplifiedExpression(new Expression.Function("HNF", this));
	};

	Expression.Pseudoinverse.prototype.simplifyInternal = function (holder) {
		return prepare(this.a, holder).pseudoinverse();
	};
	NonSimplifiedExpression.prototype.pseudoinverse = function () {
		return new NonSimplifiedExpression(new Expression.Pseudoinverse(this));
	};

	NonSimplifiedExpression.prototype.rowReduce = function () {
		return new NonSimplifiedExpression(new Expression.RowReduce(this));
	};

	NonSimplifiedExpression.prototype.GF2 = function () {
		return new NonSimplifiedExpression(new Expression.GF2(this));
	};
	NonSimplifiedExpression.prototype.transpose = function () {
		return new NonSimplifiedExpression(new Expression.Transpose(this));
	};
	NonSimplifiedExpression.prototype.complexConjugate = function () {
		return new NonSimplifiedExpression(new Expression.ComplexConjugate(this));
	};
	NonSimplifiedExpression.prototype.complexArgument = function () {
		return new NonSimplifiedExpression(new Expression.ComplexArgument(this));
	};
	NonSimplifiedExpression.prototype.adjugate = function () {
		return new NonSimplifiedExpression(new Expression.Adjugate(this));
	};

	NonSimplifiedExpression.prototype.elementWisePower = function (a) {
		return new NonSimplifiedExpression(new Expression.ElementWisePower(this, a));
	};
	NonSimplifiedExpression.prototype.transformNoAnswerExpression = function (name, second) {
		return new NonSimplifiedExpression(new Expression.NoAnswerExpression(this, name, second));
	};
	NonSimplifiedExpression.prototype.transformEquality = function (b) {
		return new NonSimplifiedExpression(new Expression.Equality(this, b));
	};
	NonSimplifiedExpression.prototype.transformInequality = function (b, sign) {
		return new NonSimplifiedExpression(new Expression.Inequality(this, b, sign));
	};
	NonSimplifiedExpression.prototype.transformComma = function (b) {
		return new NonSimplifiedExpression(new Expression.Comma(this, b));
	};

	NonSimplifiedExpression.prototype.derivative = function (variable) {
		return new NonSimplifiedExpression(new Expression.Derivative(this, variable));
	};
	NonSimplifiedExpression.prototype.KroneckerProduct = function (b) {
		return new NonSimplifiedExpression(new Expression.KroneckerProduct(this, b));
	};

	NonSimplifiedExpression.prototype.addPosition = function (position, length, input) {
		return new NonSimplifiedExpression(this.e, position, length, input);
	};

	var prepare = function (x, holder) {
		var e = x.simplify();
		ExpressionParser.startPosition = holder.position;
		ExpressionParser.endPosition = holder.position + holder.length;
		ExpressionParser.input = holder.input;
		return e;
	};

	Expression.prototype.simplifyInternal = function (holder) {
		return this;
	};
	Expression.Exponentiation.prototype.simplifyInternal = function (holder) {
		return prepare(this.a, holder).pow(prepare(this.b, holder));
	};
	Expression.Multiplication.prototype.simplifyInternal = function (holder) {
		return prepare(this.a, holder).multiply(prepare(this.b, holder));
	};
	Expression.Addition.prototype.simplifyInternal = function (holder) {
		return prepare(this.a, holder).add(prepare(this.b, holder));
	};
	Expression.Division.prototype.simplifyInternal = function (holder) {
		return prepare(this.a, holder).divide(prepare(this.b, holder));
	};
	Expression.SquareRoot.prototype.simplifyInternal = function (holder) {
		return prepare(this.a, holder).squareRoot();
	};
	Expression.NthRoot.prototype.simplifyInternal = function (holder) {
		return prepare(this.a, holder)._nthRoot(this.n);
	};
	Expression.Function.prototype.simplifyInternal = function (holder) {
		return prepare(this.a, holder)[this.name]();
	};
	Expression.Logarithm.prototype.simplifyInternal = function (holder) {
		return prepare(this.a, holder).logarithm();
	};
	Expression.Rank.prototype.simplifyInternal = function (holder) {
		return prepare(this.a, holder).rank();
	};
	Expression.Determinant.prototype.simplifyInternal = function (holder) {
		return prepare(this.a, holder).determinant();
	};
	Expression.RowReduce.prototype.simplifyInternal = function (holder) {
		return prepare(this.a, holder).rowReduce();
	};
	Expression.GF2.prototype.simplifyInternal = function (holder) {
		return prepare(this.a, holder).GF2();
	};
	Expression.Transpose.prototype.simplifyInternal = function (holder) {
		return prepare(this.a, holder).transpose();
	};
	Expression.ComplexConjugate.prototype.simplifyInternal = function (holder) {
		return prepare(this.a, holder).complexConjugate();
	};
	Expression.ComplexArgument.prototype.simplifyInternal = function (holder) {
		return prepare(this.a, holder).complexArgument();
	};
	Expression.Adjugate.prototype.simplifyInternal = function (holder) {
		return prepare(this.a, holder).adjugate();
	};
	Expression.NoAnswerExpression.prototype.simplifyInternal = function (holder) {
		return prepare(this.a, holder).transformNoAnswerExpression(this.name, this.second == undefined ? undefined : prepare(this.second, holder));
	};
	Expression.Equality.prototype.simplifyInternal = function (holder) {
		return prepare(this.a, holder).transformEquality(prepare(this.b, holder));
	};
	Expression.Inequality.prototype.simplifyInternal = function (holder) {
		return prepare(this.a, holder).transformInequality(prepare(this.b, holder), this.sign);
	};
	Expression.Matrix.prototype.simplifyInternal = function (holder) {
		return new Expression.Matrix(this.matrix.map(function (e, i, j) {
			return prepare(e, holder);
		}));
	};

	Expression.Radians.prototype.simplifyInternal = function (holder) {
		return new Expression.Radians(prepare(this.value, holder));
	};

	Expression.Comma.prototype.simplifyInternal = function (holder) {
		return prepare(this.a, holder).transformComma(prepare(this.b, holder));
	};

	Expression.Derivative.prototype.simplifyInternal = function (holder) {
		return prepare(this.symbol, holder).derivative(this.variable);
	};
	Expression.KroneckerProduct.prototype.simplifyInternal = function (holder) {
		return prepare(this.a, holder).KroneckerProduct(prepare(this.b, holder));
	};

	Expression.prototype.simplify = function () {
		return this;
	};
	NonSimplifiedExpression.prototype.simplify = function () {

		return this.e.simplify().simplifyInternal(this).simplifyExpression();
	};
	NonSimplifiedExpression.prototype.toString = function (options) {
		return this.e.toString(options);
	};
	NonSimplifiedExpression.prototype.equals = function (y) {
		return this.simplify().equals(y.simplify());
	};

	NonSimplifiedExpression.prototype.unwrap = function () {
		return this.e;
	};
	Expression.Negation.prototype.simplifyInternal = function (holder) {
		return prepare(this.b, holder).negate();
	};
	Expression.Subtraction.prototype.simplifyInternal = function (holder) {
		return prepare(this.a, holder).subtract(prepare(this.b, holder));
	};
	NonSimplifiedExpression.prototype.isUnaryPlusMinus = function () {
		return this.e.isUnaryPlusMinus();
	};
	NonSimplifiedExpression.prototype.getPrecedence = function () {
		return this.e.getPrecedence();
	};

	Expression.ElementWisePower.prototype.simplifyInternal = function (holder) {
		return prepare(this.a, holder).elementWisePower(prepare(this.b, holder));
	};
	Expression.Factorial.prototype.simplifyInternal = function (holder) {
		return prepare(this.n, holder).factorial();
	};

	NonSimplifiedExpression.prototype.getId = function () {
		return "e" + this.id.toString();
	};
	Expression.prototype.getIds = function () {
		return "";
	};
	Expression.BinaryOperation.prototype.getIds = function () {
		var a = this.a.getIds();
		var b = this.b.getIds();
		return a === "" ? b : (b === "" ? a : a + ", " + b);
	};
	NonSimplifiedExpression.prototype.getIds = function () {
		var a = this.getId();
		var b = this.e.getIds();
		return a === "" ? b : (b === "" ? a : a + ", " + b);
	};

	NonSimplifiedExpression.prototype.isNegative = function () {

		return false;
	};
	NonSimplifiedExpression.prototype.negateCarefully = function () {
		return new NonSimplifiedExpression(this.e.negateCarefully());
	};
	NonSimplifiedExpression.prototype.isRightToLeftAssociative = function () {
		return this.e.isRightToLeftAssociative();
	};

	NonSimplifiedExpression.prototype.isExact = function () {
		return this.e.isExact();
	};

	Expression.DecimalFraction = function (integer, transient, repetend, exponent) {
		this.integer = integer;
		this.transient = transient;
		this.repetend = repetend;
		this.exponent = exponent;
	};
	Expression.DecimalFraction.prototype = Object.create(Expression.prototype);
	Expression.DecimalFraction.prototype.getPrecedence = function () {

		return 1000;
	};
	Expression.DecimalFraction.prototype.simplifyInternal = function () {
		return ExpressionParser._getDecimalFraction(this.integer, this.transient, this.repetend, this.exponent);
	};
	Expression.DecimalFraction.prototype.toString = function () {
		return (this.integer || '0') + '.' + (this.transient || '') + (this.repetend != undefined ? '(' + this.repetend + ')' : '') + (this.exponent != undefined ? 'E' + this.exponent : '');
	};

	NonSimplifiedExpression.prototype.augment = function (other) {
		return new NonSimplifiedExpression(new Expression.AugmentedMatrix(this, other));
	};
	Expression.AugmentedMatrix.prototype.simplifyInternal = function (holder) {
		return prepare(this.a, holder).augment(prepare(this.b, holder));
	};

	Expression.NonSimplifiedExpression = NonSimplifiedExpression;

	self.NonSimplifiedExpression = NonSimplifiedExpression;
}

function ExpressionParser() {
	var LEFT_TO_RIGHT = 0;
	var RIGHT_TO_LEFT = 1;

	var COMMA_PRECEDENCE = 1;
	var EQUALITY_PRECEDENCE = 2;
	var ADDITIVE_PRECEDENCE = 3;
	var MULTIPLICATIVE_PRECEDENCE = 4;
	var UNARY_PRECEDENCE = 6;

	var UNARY_PRECEDENCE_PLUS_ONE = UNARY_PRECEDENCE + 1;
	var UNARY_PRECEDENCE_PLUS_TWO = UNARY_PRECEDENCE + 2;

	function Operator(name, arity, rightToLeftAssociative, precedence, i) {
		this.name = name;
		this.arity = arity;
		this.rightToLeftAssociative = rightToLeftAssociative;
		this.precedence = precedence;
		this.i = i;

	}

	Operator.trigonometry = function (name) {
		return new Operator(name, 1, RIGHT_TO_LEFT, UNARY_PRECEDENCE_PLUS_ONE, function (a) {
			a = prepareTrigonometricArgument(a);
			return a[name]();
		});
	};
	Operator.simple = function (name) {
		return new Operator(name, 1, RIGHT_TO_LEFT, UNARY_PRECEDENCE_PLUS_ONE, function (a) {
			return a[name]();
		});
	};

	var UNARY_PLUS = new Operator("+", 1, RIGHT_TO_LEFT, UNARY_PRECEDENCE, function (e) {
		return e;
	});
	var UNARY_MINUS = new Operator("-", 1, RIGHT_TO_LEFT, UNARY_PRECEDENCE, function (e) {
		return e.negate();
	});

	var prepareTrigonometricArgument = function (a) {
		if (a instanceof Expression.Integer) {
			return new Expression.Degrees(a);
		}
		if (a instanceof Expression.NonSimplifiedExpression) {
			var isGood = function (a) {
				if (a instanceof Expression.NonSimplifiedExpression) {
					return isGood(a.e);
				}
				if (a instanceof Expression.Integer) {
					return true;
				}
				if (a instanceof Expression.Negation) {
					return isGood(a.b);
				}
				if (a instanceof Expression.Multiplication || a instanceof Expression.Addition) {
					return isGood(a.a) && isGood(a.b);
				}
				return false;
			};
			if (isGood(a)) {
				return toDegrees(a);
			}
		}
		return a;
	};

	var toDegrees = function (a) {
		return a instanceof Expression.NonSimplifiedExpression ? new Expression.NonSimplifiedExpression(new Expression.Degrees(a)) : new Expression.Degrees(a);
	};

	var toRadians = function (a) {
		return a instanceof Expression.NonSimplifiedExpression ? new Expression.NonSimplifiedExpression(new Expression.Radians(a)) : new Expression.Radians(a);
	};

	var notSupported = function (a) {
		throw new TypeError();
	};

	var conjugateTranspose = function (a) {
		return a.transpose().complexConjugate();
	};

	var inequalityOperator = function (name, sign) {
		return new Operator(name, 2, LEFT_TO_RIGHT, EQUALITY_PRECEDENCE, function (a, b) {
			return a.transformInequality(b, sign);
		});
	};

	var operations = [new Operator("=", 2, LEFT_TO_RIGHT, EQUALITY_PRECEDENCE, function (a, b) {
		return a.transformEquality(b);
	}),

		inequalityOperator('≠', '!='), inequalityOperator('!=', '!='), inequalityOperator('>', '>'), inequalityOperator('<', '<'), inequalityOperator('⩽', '>='), inequalityOperator('⩾', '<='),

		new Operator(";", 2, LEFT_TO_RIGHT, COMMA_PRECEDENCE, function (a, b) {
			return a.transformComma(b);
		}), new Operator(",", 2, LEFT_TO_RIGHT, COMMA_PRECEDENCE, function (a, b) {
			return a.transformComma(b);
		}),

		new Operator("+", 2, LEFT_TO_RIGHT, ADDITIVE_PRECEDENCE, function (a, b) {
			return a.add(b);
		}), new Operator("-", 2, LEFT_TO_RIGHT, ADDITIVE_PRECEDENCE, function (a, b) {
			return a.subtract(b);
		}), new Operator("*", 2, LEFT_TO_RIGHT, MULTIPLICATIVE_PRECEDENCE, function (a, b) {
			return a.multiply(b);
		}), new Operator("/", 2, LEFT_TO_RIGHT, MULTIPLICATIVE_PRECEDENCE, function (a, b) {
			return a.divide(b);
		}), new Operator("\\", 2, LEFT_TO_RIGHT, MULTIPLICATIVE_PRECEDENCE, function (a, b) {
			return a.inverse().multiply(b);
		}),

		new Operator("^", 2, RIGHT_TO_LEFT, UNARY_PRECEDENCE, function (a, b) {
			return a.pow(b);
		}), new Operator("**", 2, RIGHT_TO_LEFT, UNARY_PRECEDENCE, function (a, b) {
			return a.pow(b);
		}), new Operator(".^", 2, RIGHT_TO_LEFT, UNARY_PRECEDENCE, function (a, b) {
			return a.elementWisePower(b);
		}), new Operator("\u221A", 1, RIGHT_TO_LEFT, UNARY_PRECEDENCE, function (a) {
			return a.squareRoot();
		}), new Operator("sqrt", 1, RIGHT_TO_LEFT, UNARY_PRECEDENCE_PLUS_ONE, function (a) {
			return a.squareRoot();
		}), new Operator("radical", 1, RIGHT_TO_LEFT, UNARY_PRECEDENCE_PLUS_ONE, function (a) {
			return a.squareRoot();
		}), new Operator("\u221B", 1, RIGHT_TO_LEFT, UNARY_PRECEDENCE, function (a) {
			return a._nthRoot(3);
		}), new Operator("cbrt", 1, RIGHT_TO_LEFT, UNARY_PRECEDENCE_PLUS_ONE, function (a) {
			return a._nthRoot(3);
		}), new Operator("\u221C", 1, RIGHT_TO_LEFT, UNARY_PRECEDENCE, function (a) {
			return a._nthRoot(4);
		}), new Operator("rank", 1, RIGHT_TO_LEFT, UNARY_PRECEDENCE, function (a) {
			return a.rank();
		}), new Operator("adj", 1, RIGHT_TO_LEFT, UNARY_PRECEDENCE, function (a) {
			return a.adjugate();
		}), new Operator("adjugate", 1, RIGHT_TO_LEFT, UNARY_PRECEDENCE, function (a) {
			return a.adjugate();
		}), new Operator("trace", 1, RIGHT_TO_LEFT, UNARY_PRECEDENCE, function (a) {
			return a.trace(a);
		}), new Operator("inverse", 1, RIGHT_TO_LEFT, UNARY_PRECEDENCE, function (a) {
			return a.inverse();
		}), new Operator("det", 1, RIGHT_TO_LEFT, UNARY_PRECEDENCE, function (a) {
			return a.determinant();
		}), new Operator("determinant", 1, RIGHT_TO_LEFT, UNARY_PRECEDENCE, function (a) {
			return a.determinant();
		}), new Operator("row-reduce", 1, RIGHT_TO_LEFT, UNARY_PRECEDENCE, function (a) {
			return a.rowReduce();
		}), new Operator("transpose", 1, RIGHT_TO_LEFT, UNARY_PRECEDENCE, function (a) {
			return a.transpose();
		}),

		new Operator("'", 1, LEFT_TO_RIGHT, UNARY_PRECEDENCE, function (a) {
			if (Expression.isScalar(a)) {
				var x = null;
				Expression._map(function f1(e) {
					if (e instanceof Expression.Symbol && !Expression.isConstant(e)) {
						x = e;
					}
					return e;
				}, a.simplify());
				if (x != null) {
					return a.simplify().derivative(x);
				}
			}
			return a.transpose();
		}),

		new Operator("^*", 1, LEFT_TO_RIGHT, UNARY_PRECEDENCE, conjugateTranspose), new Operator("^{*}", 1, LEFT_TO_RIGHT, UNARY_PRECEDENCE, conjugateTranspose), new Operator("⃰", 1, LEFT_TO_RIGHT, UNARY_PRECEDENCE, conjugateTranspose),

		new Operator("solve", 1, RIGHT_TO_LEFT, UNARY_PRECEDENCE, function (a) {
			return a.transformNoAnswerExpression("solve");
		}),

		new Operator("GF2", 1, RIGHT_TO_LEFT, UNARY_PRECEDENCE, function (a) {
			return a.GF2();
		}),

		new Operator("°", 1, LEFT_TO_RIGHT, UNARY_PRECEDENCE_PLUS_TWO, function (a) {
			return toDegrees(a);
		}), new Operator("deg", 1, LEFT_TO_RIGHT, UNARY_PRECEDENCE_PLUS_TWO, function (a) {
			return toDegrees(a);
		}), new Operator("rad", 1, LEFT_TO_RIGHT, UNARY_PRECEDENCE_PLUS_TWO, function (a) {
			return toRadians(a);
		}),

		new Operator("exp", 1, RIGHT_TO_LEFT, UNARY_PRECEDENCE_PLUS_ONE, function (a) {
			return a.exp();
		}), new Operator("log", 1, RIGHT_TO_LEFT, UNARY_PRECEDENCE_PLUS_ONE, function (a) {
			return a.logarithm();
		}), new Operator("lg", 1, RIGHT_TO_LEFT, UNARY_PRECEDENCE_PLUS_ONE, function (a) {
			return a.logarithm().divide(Expression.TEN.logarithm());
		}), new Operator("ln", 1, RIGHT_TO_LEFT, UNARY_PRECEDENCE_PLUS_ONE, function (a) {
			return a.logarithm();
		}),

		new Operator("abs", 1, RIGHT_TO_LEFT, UNARY_PRECEDENCE_PLUS_ONE, function (a) {
			return a.abs();
		}),

		new Operator("min", 1, RIGHT_TO_LEFT, UNARY_PRECEDENCE_PLUS_ONE, function (a) {
			return a.min();
		}), new Operator("max", 1, RIGHT_TO_LEFT, UNARY_PRECEDENCE_PLUS_ONE, function (a) {
			return a.max();
		}), new Operator("gcd", 1, RIGHT_TO_LEFT, UNARY_PRECEDENCE_PLUS_ONE, function (a) {
			return a.gcd();
		}),

		new Operator("modinv", 1, RIGHT_TO_LEFT, UNARY_PRECEDENCE_PLUS_ONE, function (a) {

			a = a.simplify();
			if (a instanceof Expression.List) {
				if (a.list.length !== 2) {
					throw new RangeError();
				}
				return a.list[0].modInverse(a.list[1]);
			}
			throw new TypeError();
		}),

		new Operator("binomial", 1, RIGHT_TO_LEFT, UNARY_PRECEDENCE_PLUS_ONE, function (a) {

			a = a.simplify();
			if (a instanceof Expression.List) {
				if (a.list.length !== 2) {
					throw new RangeError();
				}
				var binomialCoefficient = function (n, k) {
					return k.equals(Expression.ZERO) ? Expression.ONE : n.multiply(binomialCoefficient(n.subtract(Expression.ONE), k.subtract(Expression.ONE))).divide(k);
				};

				var n = a.list[0];
				var k = a.list[1];
				return binomialCoefficient(n, k);
			}
			throw new TypeError();
		}),

		new Operator("conjugate", 1, RIGHT_TO_LEFT, UNARY_PRECEDENCE_PLUS_ONE, function (a) {
			return a.complexConjugate();
		}), new Operator("overline", 1, RIGHT_TO_LEFT, UNARY_PRECEDENCE_PLUS_ONE, function (a) {
			return a.complexConjugate();
		}), new Operator("arg", 1, RIGHT_TO_LEFT, UNARY_PRECEDENCE_PLUS_ONE, function (a) {
			return a.complexArgument();
		}),

		new Operator("\\left", 1, RIGHT_TO_LEFT, UNARY_PRECEDENCE_PLUS_ONE, function (a) {
			return a;
		}), new Operator("\\right", 1, LEFT_TO_RIGHT, UNARY_PRECEDENCE_PLUS_ONE, function (a) {
			return a;
		}), new Operator("\\mathrm", 1, RIGHT_TO_LEFT, UNARY_PRECEDENCE_PLUS_ONE, function (a) {
			return a;
		}), new Operator("├", 1, RIGHT_TO_LEFT, UNARY_PRECEDENCE_PLUS_ONE, function (a) {
			return a;
		}), new Operator("┤", 1, LEFT_TO_RIGHT, UNARY_PRECEDENCE_PLUS_ONE, function (a) {
			return a;
		}),

		new Operator("frac", 2, RIGHT_TO_LEFT, UNARY_PRECEDENCE_PLUS_ONE, function (a, b) {
			return a.divide(b);
		}), new Operator("\\cdot", 2, LEFT_TO_RIGHT, MULTIPLICATIVE_PRECEDENCE, function (a, b) {
			return a.multiply(b);
		}), new Operator("\\times", 2, LEFT_TO_RIGHT, MULTIPLICATIVE_PRECEDENCE, function (a, b) {
			return a.multiply(b);
		}),

		new Operator("!", 1, LEFT_TO_RIGHT, UNARY_PRECEDENCE, function (a) {
			return a.factorial();
		}), new Operator("!!", 1, LEFT_TO_RIGHT, UNARY_PRECEDENCE, notSupported), new Operator("!!!", 1, LEFT_TO_RIGHT, UNARY_PRECEDENCE, notSupported),

		new Operator("pseudoinverse", 1, RIGHT_TO_LEFT, UNARY_PRECEDENCE, function (a) {
			return a.pseudoinverse();
		}), new Operator("root of", 1, RIGHT_TO_LEFT, EQUALITY_PRECEDENCE, function (a) {

			var tmp = Expression.getMultivariatePolynomial(a.simplify());
			return SomePolynomialRoot.create(tmp.p);
		}), new Operator("near", 2, RIGHT_TO_LEFT, COMMA_PRECEDENCE, function (a, b) {

			if (a instanceof Expression.Integer) {
				return a;
			}
			if (a instanceof SomePolynomialRoot && (a.e.toString() === 'alpha' || a.e.toString() === 'x')) {
				var point = b.simplify();
				var p = a.polynomial;

				var zeros = p.getZeros();
				var min = 1 / 0;
				var candidate = null;
				var distance = function (x, y) {
					return x.subtract(y);
				};
				var fractionDigits = 1;
				while (candidate == null) {
					var distances = [];
					fractionDigits *= 2;
					for (var iteratorzero = zeros[globalThis.Symbol.iterator](), zero = iteratorzero.next().value; zero != null; zero = iteratorzero.next().value) {
						var z = ExpressionParser.parse(zero.toString({rounding: {fractionDigits: fractionDigits}}));
						var d = distance(point, z).abs();
						if (candidate == null || d.compareTo(min) < 0) {
							min = d;
							candidate = zero;
						} else {
							distances.push(d);
						}
					}
					for (var iteratord = distances[globalThis.Symbol.iterator](), d = iteratord.next().value; d != null; d = iteratord.next().value) {
						if (candidate != null && d.subtract(min).compareTo(Expression.TEN._pow(fractionDigits).inverse().multiply(Expression.TWO)) < 0) {
							candidate = null;
						}
					}
				}
				var result = candidate.upgrade();
				if (b instanceof Expression.NonSimplifiedExpression) {
					return new Expression.NonSimplifiedExpression(result);
				}
				return result;
			}
			throw new TypeError();
		}), new Operator("where", 1, RIGHT_TO_LEFT, UNARY_PRECEDENCE_PLUS_ONE, function (a) {

			return a.simplify();
		}), new Operator("factor", 1, RIGHT_TO_LEFT, UNARY_PRECEDENCE_PLUS_ONE, function (a) {
			return a.simplify().factor();
		}), new Operator("derivative", 1, RIGHT_TO_LEFT, UNARY_PRECEDENCE_PLUS_ONE, function (a) {
			a = a.simplify();
			if (a instanceof Expression.List) {
				if (a.list.length !== 2) {
					throw new RangeError();
				}
				return a.list[0].derivative(a.list[1]);
			}
			return a.derivative();
		}), new Operator("\'(x)", 1, LEFT_TO_RIGHT, UNARY_PRECEDENCE_PLUS_ONE, function (a) {
			return a.derivative(new Expression.Symbol('x'));
		}), new Operator("\'(t)", 1, LEFT_TO_RIGHT, UNARY_PRECEDENCE_PLUS_ONE, function (a) {
			return a.derivative(new Expression.Symbol('t'));
		}), new Operator("\'_{x}", 1, LEFT_TO_RIGHT, UNARY_PRECEDENCE_PLUS_ONE, function (a) {
			return a.derivative(new Expression.Symbol('x'));
		}), new Operator("resultant", 1, RIGHT_TO_LEFT, UNARY_PRECEDENCE_PLUS_ONE, function (a) {
			a = a.simplify();
			if (a instanceof Expression.List) {
				if (a.list.length !== 2) {
					throw new RangeError();
				}
				var v = new Expression.Symbol('x');
				var p1 = Polynomial.toPolynomial(a.list[0], v);
				var p2 = Polynomial.toPolynomial(a.list[1], v);
				return new Expression.Polynomial(Polynomial.resultant(p1, p2));
			}
		}), new Operator("MinimalPolynomial", 1, RIGHT_TO_LEFT, UNARY_PRECEDENCE_PLUS_ONE, function (a) {
			a = a.simplify();
			if (a instanceof Expression.List) {
				if (a.list.length !== 2) {
					throw new RangeError();
				}
				return Expression.toPolynomialRoot(a.list[0]).root.getAlpha().polynomial.calcAt(a.list[1]);
			}
		}),

		new Operator("⊗", 2, LEFT_TO_RIGHT, MULTIPLICATIVE_PRECEDENCE, function (a, b) {
			return a.KroneckerProduct(b);
		}), new Operator("\\otimes", 2, LEFT_TO_RIGHT, MULTIPLICATIVE_PRECEDENCE, function (a, b) {
			return a.KroneckerProduct(b);
		}), new Operator("LLL", 1, RIGHT_TO_LEFT, UNARY_PRECEDENCE_PLUS_ONE, function (a) {
			return a.LLL();
		}), new Operator("LatticeReduce", 1, RIGHT_TO_LEFT, UNARY_PRECEDENCE_PLUS_ONE, function (a) {
			return a.LLL();
		}), new Operator("HNF", 1, RIGHT_TO_LEFT, UNARY_PRECEDENCE_PLUS_ONE, function (a) {
			return a.HNF();
		})

	];

	function OperationSearchCache() {
		this.map = {};
		this.re = null;
	}

	OperationSearchCache.prototype.append = function (operator) {
		this.map[operator.name.toLowerCase()] = operator;
		this.re = null;
	};
	OperationSearchCache.prototype.getByName = function (name) {
		return this.map[name.toLowerCase()];
	};
	OperationSearchCache.prototype.getRegExp = function () {

		var escapeRegExp = function (s) {

			return s.replace(/[\/\\^$*+?.()|[\]{}]/g, '\\$&');
		};

		if (this.re == null) {
			var names = [];
			for (var name in this.map) {
				if (Object.prototype.hasOwnProperty.call(this.map, name)) {
					names.push(name);
				}
			}
			names.sort(function (a, b) {

				return a < b && b.lastIndexOf(a, 0) !== 0 || a.lastIndexOf(b, 0) === 0 ? -1 : +1;
			});
			var separator = String.fromCharCode(0x0000);
			this.re = new RegExp('^(?:' + escapeRegExp(names.join(separator)).split(separator).join('|').replace(/\|ch\|/g, '|ch(?!i)|').replace(/\|th\|/g, '|th(?!eta)|') + ')', 'i');
		}
		return this.re;
	};

	var operationSearchCache = new OperationSearchCache();
	var trigonometryFunctions = {};

	var i = -1;
	while (++i < operations.length) {
		operationSearchCache.append(operations[i]);
	}
	for (var iteratorname = 'cos sin tan cot'.split(' ')[globalThis.Symbol.iterator](), name = iteratorname.next().value; name != null; name = iteratorname.next().value) {
		operationSearchCache.append(Operator.trigonometry(name));
		trigonometryFunctions[name] = true;
	}
	for (var iteratorname = 'cosh sinh tanh coth arccos arcsin arctan arccot arcosh arsinh artanh arcoth'.split(' ')[globalThis.Symbol.iterator](), name = iteratorname.next().value; name != null; name = iteratorname.next().value) {
		operationSearchCache.append(Operator.simple(name));
	}

	var nextToken = function (tokenizer) {
		var token = null;
		do {
			token = tokenizer.next();
		} while (token.type === 'whitespace');
		return token;
	};

	var parsePunctuator = function (tokenizer, token, punctuator) {
		if (token.type !== 'punctuator' || token.value !== punctuator) {
			ExpressionParser.startPosition = tokenizer.previousPosition;
			ExpressionParser.endPosition = tokenizer.position;
			ExpressionParser.input = tokenizer.input;
			if (token.type === 'EOF') {
				throw new RangeError("UserError: unexpected end of input, '" + punctuator + "' expected");
			}
			throw new RangeError("UserError: unexpected '" + tokenizer.input.slice(tokenizer.previousPosition, tokenizer.position) + "', '" + punctuator + "' expected");
		}
		token = nextToken(tokenizer);
		return token;
	};

	function ParseResult(result, token) {
		this.result = result;
		this.token = token;
	}

	var parseMatrix = function (tokenizer, token, context) {
		var openingBracket = "{";
		var closingBracket = "}";

		var rows = [];
		var hasNextRow = true;
		while (hasNextRow) {
			token = parsePunctuator(tokenizer, token, openingBracket);
			var row = [];
			var hasNextCell = true;
			while (hasNextCell) {
				var tmp = parseExpression(tokenizer, token, context, COMMA_PRECEDENCE, undefined);
				token = tmp.token;
				row.push(tmp.result);
				if (token.type === 'punctuator' && token.value === ",") {
					hasNextCell = true;
					token = nextToken(tokenizer);
				} else {
					hasNextCell = false;
				}
			}
			token = parsePunctuator(tokenizer, token, closingBracket);
			rows.push(row);
			if (token.type === 'punctuator' && token.value === ",") {
				hasNextRow = true;
				token = nextToken(tokenizer);
			} else {
				hasNextRow = false;
			}
		}
		token = parsePunctuator(tokenizer, token, "}");
		return new ParseResult(context.wrap(Expression.Matrix.fromArray(rows)), token);
	};

	var parseLaTeXMatrix = function (tokenizer, token, context, rowSeparator) {
		var rows = [];
		var firstRow = true;
		while (firstRow || (token.type === 'punctuator' && token.value === rowSeparator)) {
			if (firstRow) {
				firstRow = false;
			} else {
				token = nextToken(tokenizer);
			}
			var row = [];
			var firstCell = true;
			while (firstCell || token.type === 'punctuator' && token.value === "&") {
				if (firstCell) {
					firstCell = false;
				} else {
					token = nextToken(tokenizer);
				}
				var tmp = parseExpression(tokenizer, token, context, COMMA_PRECEDENCE, undefined);
				token = tmp.token;
				row.push(tmp.result);
			}
			rows.push(row);
		}
		return new ParseResult(context.wrap(Expression.Matrix.fromArray(rows)), token);
	};

	var parseLaTeXArgument = function (tokenizer, token, context) {
		return parseExpression(tokenizer, token, context, 0, undefined);
	};

	var getVulgarFraction = function (vulgarFraction) {
		var input = normalizeVulgarFractions(vulgarFraction).replace(/[\u2044]/g, "/");
		var e = Expression.Integer.fromString(input.slice(0, input.indexOf('/'))).divide(Expression.Integer.fromString(input.slice(input.indexOf('/') + '/'.length)));
		return e;
	};

	var getDecimalFraction = function (integerPart, nonRepeatingFractionalPart, repeatingFractionalPart, exponentPart) {
		var numerator = Expression.ZERO;
		var denominator = Expression.ONE;

		if (integerPart != undefined) {
			numerator = Expression.Integer.fromString(integerPart);
		}
		if (nonRepeatingFractionalPart != undefined) {
			var factor = Expression.pow(Expression.TEN, nonRepeatingFractionalPart.length);
			numerator = numerator.multiply(factor).add(Expression.Integer.fromString(nonRepeatingFractionalPart));
			denominator = denominator.multiply(factor);
		}
		if (repeatingFractionalPart != undefined) {
			var factor = Expression.pow(Expression.TEN, repeatingFractionalPart.length).subtract(Expression.ONE);
			numerator = numerator.multiply(factor).add(Expression.Integer.fromString(repeatingFractionalPart));
			denominator = denominator.multiply(factor);
		}
		if (exponentPart != undefined) {
			var exponent = 0 + Number(exponentPart);
			var factor = Expression.pow(Expression.TEN, exponent < 0 ? -exponent : exponent);
			if (exponent < 0) {
				denominator = denominator.multiply(factor);
			} else {
				numerator = numerator.multiply(factor);
			}
		}

		var value = numerator.divide(denominator);
		return value;
	};
	ExpressionParser._getDecimalFraction = getDecimalFraction;

	var parseDecimalFraction = function (tokenizer, token, context) {
		var isOnlyInteger = true;
		var result = undefined;
		if (token.type === 'integerLiteral') {
			result = Expression.Integer.fromString(token.value);
			result = context.wrap(result);
			token = nextToken(tokenizer);
		} else if (token.type === 'numericLiteral') {
			var value = token.value;

			var match = decimalFractionWithGroups.exec(value);
			isOnlyInteger = false;
			if (!context.needsWrap) {
				result = getDecimalFraction(match[1], match[2], match[3], match[4]);
			} else {
				result = new Expression.DecimalFraction(match[1], match[2], match[3], match[4]);
			}
			result = context.wrap(result);
			token = nextToken(tokenizer);
		}

		if (isOnlyInteger || result == undefined) {
			if (token.type === 'vulgarFraction') {
				var fraction = context.wrap(getVulgarFraction(token.value, context));
				if (result != undefined) {
					result = result.add(fraction).addPosition(tokenizer.previousPosition, tokenizer.previousPosition, tokenizer.input);
				} else {
					result = fraction;
				}
				token = nextToken(tokenizer);
			}
		}
		return result != undefined ? new ParseResult(result, token) : undefined;
	};

	var whiteSpaces = /^\s+/;
	var punctuators = /^(?:[,&(){}|■@]|\\\\|(?:\\begin|\\end)(?:\{(?:[bvp]?matrix|gathered)\})?)/;

	var integerLiteralWithoutComma = /^\d+(?![\d.])(?!(?:(?:e|E|\u0415|\u0623\u0633|\u0627\u0633)[\+\-]?\d+))/;
	var integerLiteral = new RegExp(integerLiteralWithoutComma.source + /(?!,(?:\d|\(\d+\)))/.source);

	var decimalFraction = /^(?=[.,]?\d)\d*(?:(?:[.]|[.,](?=\d|\(\d+\)))\d*(?:\(\d+\))?)?(?:(?:e|E|\u0415|\u0623\u0633|\u0627\u0633)[\+\-]?\d+)?/;
	var decimalFractionWithoutComma = new RegExp(decimalFraction.source.replace(/,/g, ''));

	var greek = "alpha beta gamma delta epsilon zeta eta theta iota kappa lambda mu nu xi omicron pi rho varsigma sigma tau upsilon phi chi psi omega".split(" ");
	var ARABIC_MATHEMATIC_LETTER = /(?:[\u0627\u066E\u062D\u062F\u0633\u0634\u0635\u0639\u0637\u06BE\u062A]|\u062d\u0640\u0640\u0640\u0640)(?![\u0600-\u06FF])/;
	var symbols = new RegExp(/^(?:GREEK|circ|∞|[a-zA-Zа-яА-Яα-ωß]|ARABIC_MATHEMATIC_LETTER)(?:\_[0-9]+|\_\([a-z0-9]+,[a-z0-9]+\)|[\u2080-\u2089]+)?/.source.replace(/GREEK/g, greek.join('|')).replace(/ARABIC_MATHEMATIC_LETTER/g, ARABIC_MATHEMATIC_LETTER.source));
	var superscripts = /^[\u00B2\u00B3\u00B9\u2070\u2071\u2074-\u207F]+/;
	var vulgarFractions = /^[\u00BC-\u00BE\u2150-\u215E]/;

	var other = /^(?:[\uD800-\uDBFF][\uDC00-\uDFFF]|\S)/;

	var decimalFractionWithGroups = /^(\d+)?(?:[.,](\d+)?(?:\((\d+)\))?)?(?:(?:e|E|\u0415|\u0623\u0633|\u0627\u0633)([\+\-]?\d+))?$/;

	var normalizeSuperscripts = function (s) {
		return s.replace(/[\u00B2\u00B3\u00B9\u2070\u2071\u2074-\u207F]/g, function (c) {
			var charCode = c.charCodeAt(0);
			if (charCode === 0x00B2) {
				return "2";
			}
			if (charCode === 0x00B3) {
				return "3";
			}
			if (charCode === 0x00B9) {
				return "1";
			}
			var i = charCode - 0x2070;
			return "0i  456789+-=()n".slice(i, i + 1);
		});
	};

	var normalizeVulgarFractions = function (s) {
		return s.replace(/[\u00BC-\u00BE\u2150-\u215E]/g, function (c) {
			var charCode = c.charCodeAt(0);
			var i = charCode - 0x2150 < 0 ? (charCode - 0x00BC) * 2 : (3 + charCode - 0x2150) * 2;
			return "141234171911132315253545165618385878".slice(i, i + 2).replace(/^\S/g, "$&\u2044").replace(/1\u20441/g, "1\u204410");
		});
	};

	var normalizeSubscripts = function (s) {
		var i = s.length - 1;
		while (i >= 0 && s.charCodeAt(i) >= 0x2080 && s.charCodeAt(i) <= 0x2089) {
			i -= 1;
		}
		return i === s.length - 1 ? s : s.slice(0, i + 1) + "_" + s.slice(i + 1).replace(/[\u2080-\u2089]/g, function (c) {
			return String.fromCharCode(c.charCodeAt(0) - 0x2080 + "0".charCodeAt(0));
		});
	};

	var normalizeGreek = function (s) {
		var i = s.indexOf("_");
		var k = i === -1 ? s.length : i;
		if (k > 1) {
			var name = s.slice(0, k);
			var j = greek.indexOf(name);
			if (j !== -1) {
				return String.fromCharCode(0x03B1 + j) + s.slice(k);
			}
		}
		return s;
	};

	var afterVerticalBar = false;

	var parseExpression = function (tokenizer, token, context, precedence, left) {
		var ok = true;
		var isDecimalFraction = false;
		var tmp = undefined;
		var right = undefined;

		while (token.type !== 'EOF' && ok) {
			var op = undefined;
			var operand = undefined;

			var bestMatch = token.type === 'operator' || (token.type === 'punctuator' && token.value === ',') ? operationSearchCache.getByName(token.value) : null;
			if (bestMatch != null) {
				op = left == null && bestMatch.name === '+' ? UNARY_PLUS : (left == null && bestMatch.name === '-' ? UNARY_MINUS : bestMatch);
			}

			if (op != null && op.name === "frac") {
				if (!(left == null && precedence <= UNARY_PRECEDENCE_PLUS_ONE || precedence < MULTIPLICATIVE_PRECEDENCE)) {
					ok = false;
				} else {

					token = nextToken(tokenizer);
					tmp = parseExpression(tokenizer, token, context, MULTIPLICATIVE_PRECEDENCE, undefined);
					var a = tmp.result;
					token = tmp.token;
					tmp = parseExpression(tokenizer, token, context, MULTIPLICATIVE_PRECEDENCE, undefined);
					var b = tmp.result;
					token = tmp.token;

					operand = op.i(a, b);
					ok = true;
				}
			} else if (op != undefined) {

				if (!(left != undefined && (op.arity !== 1 || op.rightToLeftAssociative !== RIGHT_TO_LEFT || precedence < MULTIPLICATIVE_PRECEDENCE) || left == undefined && op.arity === 1 && op.rightToLeftAssociative === RIGHT_TO_LEFT) ||

					precedence > op.precedence + (op.rightToLeftAssociative === RIGHT_TO_LEFT ? 0 : -1)) {
					ok = false;
				} else {
					var operatorPosition = tokenizer.previousPosition;
					token = nextToken(tokenizer);
					if (op.arity === 1 && op.rightToLeftAssociative !== RIGHT_TO_LEFT) {

						ExpressionParser.startPosition = operatorPosition;
						ExpressionParser.endPosition = operatorPosition + op.name.length;
						ExpressionParser.input = tokenizer.input;
						left = op.i(left).addPosition(operatorPosition, op.name.length, tokenizer.input);
					} else {
						if (op.arity === 1 && op.rightToLeftAssociative === RIGHT_TO_LEFT && op.precedence === UNARY_PRECEDENCE_PLUS_ONE && op.name.length > 1 && trigonometryFunctions[op.name] === true && (token.type === 'operator' && token.value === '^' || token.type === 'superscript' && /^\d+$/.test(normalizeSuperscripts(token.value)))) {

							var exponentiationPosition = tokenizer.position;

							var exponentiationLength = 0;
							var middle = null;
							if (token.type === 'superscript') {
								middle = Expression.Integer.fromString(normalizeSuperscripts(token.value));
								exponentiationLength = tokenizer.position - tokenizer.previousPosition;
								token = nextToken(tokenizer);
							} else {
								exponentiationLength = '^'.length;
								token = nextToken(tokenizer);
								var inParenthesis = token.type === 'punctuator' && token.value === '(';
								var inCurlyBrackets = token.type === 'punctuator' && token.value === '{';
								if (inParenthesis) {
									token = parsePunctuator(tokenizer, token, "(");
								}
								if (inCurlyBrackets) {
									token = parsePunctuator(tokenizer, token, "{");
								}
								if (token.type !== 'integerLiteral') {
									ok = false;
								} else {
									tmp = parseExpression(tokenizer, token, context, UNARY_PRECEDENCE, undefined);
									middle = tmp.result;
									token = tmp.token;
									if (inParenthesis) {
										token = parsePunctuator(tokenizer, token, ")");
									}
									if (inCurlyBrackets) {
										token = parsePunctuator(tokenizer, token, "}");
									}
								}
							}
							if (ok) {

								tmp = parseExpression(tokenizer, token, context, op.precedence, undefined);
								right = tmp.result;
								token = tmp.token;
								operand = op.i(right).addPosition(operatorPosition, op.name.length, tokenizer.input).pow(middle).addPosition(exponentiationPosition, exponentiationLength, tokenizer.input);
							}
						} else {
							tmp = parseExpression(tokenizer, token, context, op.precedence, undefined);
							right = tmp.result;
							token = tmp.token;

							ExpressionParser.startPosition = operatorPosition;
							ExpressionParser.endPosition = operatorPosition + op.name.length;
							ExpressionParser.input = tokenizer.input;
							if (op.arity === 1) {

								operand = op.i(right).addPosition(operatorPosition, op.name.length, tokenizer.input);
							} else if (op.arity === 2) {
								left = op.i(left, right).addPosition(operatorPosition, op.name.length, tokenizer.input);
							} else {
								throw new RangeError();
							}
						}
					}
				}
			} else if (left == undefined || precedence < MULTIPLICATIVE_PRECEDENCE || (precedence === UNARY_PRECEDENCE_PLUS_ONE && isDecimalFraction && token.type === 'symbol')) {
				if ((tmp = parseDecimalFraction(tokenizer, token, context)) != undefined) {
					operand = tmp.result;
					token = tmp.token;
					isDecimalFraction = true;
				} else if (token.type === 'punctuator' && token.value === "(") {
					var s1 = afterVerticalBar;
					afterVerticalBar = false;
					token = parsePunctuator(tokenizer, token, "(");
					tmp = parseExpression(tokenizer, token, context, 0, undefined);
					operand = tmp.result;
					token = tmp.token;
					token = parsePunctuator(tokenizer, token, ")");
					afterVerticalBar = s1;
				} else if (token.type === 'punctuator' && token.value === "{") {
					token = parsePunctuator(tokenizer, token, "{");
					if (token.type === 'punctuator' && token.value === "{") {
						tmp = parseMatrix(tokenizer, token, context);
						operand = tmp.result;
						token = tmp.token;
					} else {
						tmp = parseLaTeXArgument(tokenizer, token, context);
						operand = tmp.result;
						token = tmp.token;
						token = parsePunctuator(tokenizer, token, "}");
					}
				} else if (token.type === 'punctuator' && (token.value === "\\begin{bmatrix}" || token.value === "\\begin{vmatrix}" || token.value === "\\begin{pmatrix}" || token.value === "\\begin{matrix}" || token.value === "\\begin{gathered}")) {
					var kind = token.value.slice('\\begin{'.length, -1);
					token = nextToken(tokenizer);
					tmp = parseLaTeXMatrix(tokenizer, token, context, '\\\\');
					operand = tmp.result;
					token = tmp.token;
					if (token.type === 'punctuator' && token.value === "\\end{" + kind + "}") {
						token = nextToken(tokenizer);
					}
					if (kind === 'vmatrix') {
						operand = operand.determinant();
					}
				} else if (token.type === 'symbol') {
					var symbolName = token.value;
					symbolName = normalizeSubscripts(symbolName);
					symbolName = normalizeGreek(symbolName);
					operand = context.get(symbolName);
					operand = context.wrap(operand);
					token = nextToken(tokenizer);
				} else if (token.type === 'punctuator' && token.value === "|") {
					if (left == undefined || Expression.isScalar(left)) {
						if (left != undefined && precedence >= COMMA_PRECEDENCE) {
							if (afterVerticalBar) {
								ok = false;
							}
						}
						if (ok) {
							afterVerticalBar = true;
							token = parsePunctuator(tokenizer, token, "|");
							tmp = parseExpression(tokenizer, token, context, COMMA_PRECEDENCE, undefined);
							operand = tmp.result;
							token = tmp.token;
							token = parsePunctuator(tokenizer, token, "|");
							afterVerticalBar = false;
							if (Expression.isScalar(operand)) {
								operand = operand.abs();
							} else {
								operand = operand.determinant();
							}
						}
					} else if (precedence < COMMA_PRECEDENCE) {

						token = parsePunctuator(tokenizer, token, "|");
						tmp = parseExpression(tokenizer, token, context, 0, undefined);
						operand = tmp.result;
						token = tmp.token;
						operand = left.augment(operand);
						left = undefined;
					} else {
						ok = false;
					}
				} else if (token.type === 'punctuator' && token.value === '■') {
					token = nextToken(tokenizer);
					token = parsePunctuator(tokenizer, token, '(');
					tmp = parseLaTeXMatrix(tokenizer, token, context, '@');
					operand = tmp.result;
					token = tmp.token;
					token = parsePunctuator(tokenizer, token, ')');
				} else {
					ok = false;
				}
			} else {
				ok = false;
			}

			if (!ok && left != undefined && precedence <= UNARY_PRECEDENCE + (RIGHT_TO_LEFT === RIGHT_TO_LEFT ? 0 : -1)) {
				if (token.type === 'superscript') {

					var x = ExpressionParser.parse(normalizeSuperscripts(token.value), context);
					left = left.pow(x).addPosition(tokenizer.previousPosition, tokenizer.previousPosition, tokenizer.input);
					token = nextToken(tokenizer);
					ok = true;
				}
			}

			if (!ok && token.type === 'operator' && token.value === "\\") {

				ok = true;
				token = nextToken(tokenizer);
			}

			if (operand != undefined) {
				if (left != undefined) {

					var oldPosition = tokenizer.position;
					tmp = parseExpression(tokenizer, token, context, MULTIPLICATIVE_PRECEDENCE, operand);
					var right1 = tmp.result;
					token = tmp.token;
					left = left.multiply(right1).addPosition(oldPosition, "*".length, tokenizer.input);
				} else {
					left = operand;
				}
			}
		}

		if (left == undefined) {
			ExpressionParser.startPosition = tokenizer.previousPosition;
			ExpressionParser.endPosition = tokenizer.position;
			ExpressionParser.input = tokenizer.input;
			if (token.type === 'EOF') {
				throw new RangeError("UserError: unexpected end of input");
			}

			throw new RangeError("UserError: unexpected '" + tokenizer.input.slice(tokenizer.previousPosition, tokenizer.position) + "'");
		}
		return new ParseResult(left, token);
	};

	var decimalNumberRegExp = new RegExp('\\p{Decimal_Number}', 'u');
	var replaceSimpleDigit = function (codePoint) {
		var i = 0;
		while (decimalNumberRegExp.test(String.fromCodePoint(codePoint - i))) {
			i += 1;
		}
		return i === 0 ? -1 : (i - 1) % 10;
	};

	var map = {
		":": "/",
		"[": "(",
		"]": ")",
		"·": "*",
		"×": "*",
		"÷": "/",
		"ˆ": "^",
		"ϕ": "φ",
		"А": "A",
		"В": "B",
		"С": "C",
		"Т": "T",
		"а": "A",
		"в": "B",
		"с": "C",
		"т": "T",
		"،": ",",
		"٫": ",",
		"\u200B": " ",
		"‐": "-",
		"‑": "-",
		"‒": "-",
		"–": "-",
		"—": "-",
		"―": "-",
		"•": "*",
		"\u2061": " ",
		"\u2062": "*",
		"\u2063": ",",
		"\u2064": " ",
		"ⅇ": "e",
		"ⅈ": "i",
		"−": "-",
		"∕": "/",
		"∙": "*",
		"≤": "⩽",
		"≥": "⩾",
		"⋅": "*",
		"│": "|",
		"█": "■",
		"✓": "√",
		"〇": "0",
		"〖": "(",
		"〗": ")",
		"ー": "-",
		"一": "1",
		"七": "7",
		"三": "3",
		"九": "9",
		"二": "2",
		"五": "5",
		"八": "8",
		"六": "6",
		"四": "4"
	};

	var isBidiControl = function (codePoint) {

		return codePoint === 0x061C || codePoint === 0x200E || codePoint === 0x200F || codePoint >= 0x202A && codePoint <= 0x202E || codePoint >= 0x2066 && codePoint <= 0x2069;
	};

	var getCodePointReplacement = function (codePoint) {
		if (codePoint >= 0xFF01 && codePoint <= 0xFF5E) {

			return codePoint - 0xFF01 + 0x0021;
		}
		var digit = replaceSimpleDigit(codePoint);
		if (digit !== -1) {
			return digit + "0".charCodeAt(0);
		}
		if (isBidiControl(codePoint)) {
			return " ".charCodeAt(0);
		}
		if (codePoint >= 0x0000 && codePoint <= 0xFFFF) {

			var replacement = map[String.fromCharCode(codePoint)];
			if (replacement != undefined && replacement.length === 1) {
				return replacement.charCodeAt(0);
			}
		}
		return -1;
	};

	var replaceSomeChars = function (input) {
		var lastIndex = 0;
		var result = '';
		var i = 0;
		while (i < input.length) {
			var codePoint = input.codePointAt(i);
			var width = codePoint <= 0xFFFF ? 1 : 2;
			if (codePoint > 0x007F || codePoint === 0x003A || codePoint === 0x005B || codePoint === 0x005D) {
				var x = getCodePointReplacement(codePoint);
				if (x !== -1) {
					if (!(x >= 0x0000 && x <= 0xFFFF)) {
						throw new RangeError();
					}
					result += input.slice(lastIndex, i);
					result += String.fromCharCode(x);
					lastIndex = i + width;
				}
			}
			i += width;
		}
		result += input.slice(lastIndex);
		return result;
	};

	var config = [{
		type: 'integerLiteral',
		re: integerLiteral,
		state: 0
	}, {
		type: 'integerLiteral',
		re: integerLiteralWithoutComma,
		state: 1
	}, {
		type: 'numericLiteral',
		re: decimalFraction,
		state: 0
	}, {
		type: 'numericLiteral',
		re: decimalFractionWithoutComma,
		state: 1
	}, {
		type: 'whitespace',
		re: whiteSpaces,
		state: -1
	}, {
		type: 'punctuator',
		re: punctuators,
		state: -1
	}, {
		type: 'operator',
		re: null,
		state: -1
	}, {
		type: 'symbol',
		re: symbols,
		state: -1
	}, {
		type: 'vulgarFraction',
		re: vulgarFractions,
		state: -1
	}, {
		type: 'superscript',
		re: superscripts,
		state: -1
	}, {
		type: 'OTHER',
		re: other,
		state: -1
	}];
	var stateConfigs = [{
		start: '(',
		end: ')'
	}, {
		start: '{',
		end: '}'
	}];

	function Token(type, value) {
		this.type = type;
		this.value = value;
	}

	Token.EOF = new Token('EOF', '');

	function Tokenizer(input, position, states) {
		this._preparedInput = replaceSomeChars(input.slice(position));
		this.input = input;
		this._preparedInputPosition = 0;
		this.previousPosition = position;
		this.position = position;
		this.states = states;
	}

	Tokenizer.prototype.next = function () {
		this.previousPosition = this.position;
		if (this.position >= this.input.length) {
			return Token.EOF;
		}

		for (var i = 0; i < config.length; i += 1) {
			var c = config[i];
			var type = c.type;
			var re = c.re;
			var state = c.state;
			if (re == null && type === 'operator') {
				re = operationSearchCache.getRegExp();
			}
			if (state === -1 || state === (this.states == null ? 0 : this.states.value)) {
				var tmp = re.exec(this._preparedInput.slice(this._preparedInputPosition));
				if (tmp != null) {
					var value = tmp[0];
					if (type === 'punctuator') {
						for (var j = 0; j < stateConfigs.length; j += 1) {
							var state = stateConfigs[j];
							if (value === state.start) {
								this.states = {
									previous: this.states,
									value: j
								};
							} else if (value === state.end && this.states != null && this.states.value === j) {
								this.states = this.states.previous;
							}
						}
					}
					for (var j = 0; j < value.length; j += (value.codePointAt(j) <= 0xFFFF ? 1 : 2)) {
						this.position += this.input.codePointAt(this.position) <= 0xFFFF ? 1 : 2;
					}
					this._preparedInputPosition += value.length;
					return new Token(type, value);
				}
			}
		}
		throw new TypeError();
	};

	var fs = {};

	function ExpressionParser() {
	}

	ExpressionParser.parse = function (input, context) {
		context = context == undefined ? new ExpressionParser.Context(undefined, false) : context;

		ExpressionParser.startPosition = -1;
		ExpressionParser.endPosition = -1;
		ExpressionParser.input = input;

		if (typeof input !== "string") {
			throw new RangeError();
		}

		if (typeof hit === "function" && context.getter != undefined) {
			var re = /[a-z][a-z][a-z\-]+/gi;
			var m = null;
			while ((m = re.exec(input)) != null) {
				var t = m[0];
				if (!(t in fs) && t.indexOf("-") === -1) {
					fs[t] = true;
					hit({fs: t});
				}
			}
		}

		afterVerticalBar = false;
		var tokenizer = new Tokenizer(input, 0, null);
		var token = nextToken(tokenizer);
		var tmp = parseExpression(tokenizer, token, context, 0, undefined);
		token = tmp.token;
		if (token.type !== 'EOF') {
			ExpressionParser.startPosition = tokenizer.previousPosition;
			ExpressionParser.endPosition = tokenizer.position;
			ExpressionParser.input = tokenizer.input;
			throw new RangeError("UserError: unexpected '" + tokenizer.input.slice(tokenizer.previousPosition, tokenizer.position) + "'");
		}

		return tmp.result;
	};

	globalThis.Tokenizer = Tokenizer;

	ExpressionParser.startPosition = -1;
	ExpressionParser.endPosition = -1;
	ExpressionParser.input = "";

	var getConstant = function (symbolName) {
		if (symbolName === "pi" || symbolName === "\u03C0" || symbolName === "\u0637") {
			return Expression.PI;
		}
		if (symbolName === "e" || symbolName === "\u06BE") {
			return Expression.E;
		}
		if (symbolName === "i" || symbolName === "\u062A") {
			return Expression.I;
		}
		if (symbolName === "I" || symbolName === "U" || symbolName === "E") {
			return new Expression.IdentityMatrix(symbolName);
		}
		if (symbolName === "circ") {
			return Expression.CIRCLE;
		}
		if (symbolName === "∞") {
			return Expression.INFINITY;
		}
		return new Expression.Symbol(symbolName);
	};

	ExpressionParser.Context = function (getter, needsWrap) {
		this.getter = getter;
		this.needsWrap = needsWrap == undefined ? true : needsWrap;
	};
	ExpressionParser.Context.prototype.get = function (symbolName) {
		if (this.getter != undefined) {
			var x = this.getter(symbolName);
			if (x != undefined) {
				return x;
			}
		}
		return getConstant(symbolName);
	};
	ExpressionParser.Context.prototype.wrap = function (e) {
		if (!this.needsWrap) {
			return e;
		}
		return new Expression.NonSimplifiedExpression(e);
	};

	ExpressionParser.addOperation = function (denotation, arity) {

		var newOperation = arity === 1 ? new Operator(denotation, arity, RIGHT_TO_LEFT, UNARY_PRECEDENCE, function (a) {
			return a.transformNoAnswerExpression(denotation);
		}) : new Operator(denotation, arity, RIGHT_TO_LEFT, MULTIPLICATIVE_PRECEDENCE, function (a, b) {
			return a.transformNoAnswerExpression(denotation, b);
		});

		operationSearchCache.append(newOperation);
	};

	self.ExpressionParser = ExpressionParser;
}

function BinaryHeap() {
	function Heap(compareTo) {
		this.data = [];
		this.compareTo = compareTo;
	}

	Heap.prototype.push = function (value) {
		var data = this.data;
		var compareTo = this.compareTo;
		data.push(value);

		var size = data.length;
		var j = size - 1;
		var tmp = data[j];
		var parent = -1;
		while (j > 0 && compareTo(tmp, data[parent = Math.floor((j - 1) / 2)]) < 0) {
			data[j] = data[parent];
			j = parent;
		}
		data[j] = tmp;
	};

	Heap.prototype.pop = function () {
		var data = this.data;
		var compareTo = this.compareTo;
		var size = data.length;
		if (size === 0) {
			return undefined;
		}
		if (size === 1) {
			return data.pop();
		}
		var value = data[0];
		data[0] = data.pop();
		--size;

		var j = 0;
		if (j < size) {
			var tmp = data[j];
			do {
				var child = size;
				var t = tmp;
				var c = j * 2;
				if (++c < size && compareTo(data[c], t) < 0) {
					child = c;
					t = data[child];
				}
				if (++c < size && compareTo(data[c], t) < 0) {
					child = c;
					t = data[child];
				}
				data[j] = t;
				j = child;
			} while (j < size);
		}
		return value;
	};

	Heap.prototype.peek = function () {
		var data = this.data;
		return data.length > 0 ? data[0] : undefined;
	};

	Heap.prototype.size = function () {
		var data = this.data;
		return data.length;
	};

	Heap.prototype.replace = function (newItem) {
		this.data.push(newItem);
		return this.pop();
	};

	self.Heap = Heap;
}

function Polynomial() {
	var isPrime = primeFactor._isPrime;

	var freeze = function (x) {
		return x;
	};

	function PolynomialData(length) {
		this.degrees = new Array(length);
		this.coefficients = new Array(length);
		this.size = 0;
	}

	PolynomialData.prototype.add = function (degree, coefficient) {
		var k = this.size;
		if (!(Math.floor(degree) === degree && degree >= 0 && degree <= Number.MAX_SAFE_INTEGER)) {
			throw new RangeError("NotSupportedError");
		}
		if (k > 0 && !(degree < this.degrees[k - 1]) || k >= this.degrees.length || k >= this.coefficients.length) {
			throw new RangeError();
		}
		this.degrees[k] = degree;
		this.coefficients[k] = coefficient;
		this.size = k + 1;
	};
	PolynomialData.prototype.degree = function (i) {
		return this.degrees[i];
	};
	PolynomialData.prototype.coefficient = function (i) {
		return this.coefficients[i];
	};
	PolynomialData.prototype.trim = function () {
		if (this.size < Math.max(this.degrees.length, this.coefficients.length)) {
			this.degrees.length = this.size;
			this.coefficients.length = this.size;
		}
		return this;
	};

	function Polynomial(a) {
		this.a = a.trim();
	}

	Polynomial.of = function () {
		var newData = new PolynomialData(arguments.length);
		for (var i = arguments.length - 1; i >= 0; i -= 1) {
			var a = arguments[i];
			if (!a.equals(Expression.ZERO)) {
				newData.add(i, a);
			}
		}
		return new Polynomial(newData);
	};
	Polynomial.from = function (array) {
		var newData = new PolynomialData(array.length);
		for (var i = array.length - 1; i >= 0; i -= 1) {
			var degree = i;
			var coefficient = array[i];
			if (!coefficient.equals(Expression.ZERO)) {
				newData.add(degree, coefficient);
			}
		}
		return new Polynomial(newData);
	};
	Polynomial.ZERO = Polynomial.of();
	Polynomial.prototype.getDegree = function () {
		return this.a.size === 0 ? -1 : this.a.degree(0);
	};
	Polynomial.prototype.getCoefficient = function (degree) {
		var from = 0;
		var to = this.a.size;
		while (from < to) {
			var middle = from + Math.floor((to - from) / 2);
			var y = this.a.degree(middle);
			if (y > degree) {
				from = middle + 1;
			} else if (y < degree) {
				to = middle;
			} else {
				return this.a.coefficient(middle);
			}
		}
		return Expression.ZERO;
	};
	Polynomial.prototype.getLeadingCoefficient = function () {
		return this.a.size === 0 ? Expression.ZERO : this.a.coefficient(0);
	};
	Polynomial.prototype.map = function (mapFunction) {

		if (mapFunction.length !== 1) {
			throw new RangeError("deprecated");
		}
		var newData = new PolynomialData(this.a.size);
		for (var i = 0; i < this.a.size; i += 1) {
			var degree = this.a.degree(i);
			var coefficient = this.a.coefficient(i);
			var c = mapFunction(coefficient);
			if (!c.equals(Expression.ZERO)) {
				newData.add(degree, c);
			}
		}
		return new Polynomial(newData);
	};
	Polynomial.prototype.equals = function (p) {
		if (p === Expression.ZERO) {
			return this.a.size === 0;
		}
		if (this.a.size !== p.a.size) {
			return false;
		}
		var i = 0;
		var j = 0;
		while (i < this.a.size && j < p.a.size) {
			if (this.a.degree(i) !== p.a.degree(j) || !this.a.coefficient(i).equals(p.a.coefficient(j))) {
				return false;
			}
			i += 1;
			j += 1;
		}
		return true;
	};

	function _join(A, B, mapFunction) {
		var newData = new PolynomialData(A.a.size + B.a.size);
		var i = -1;
		var x = -2;
		var xc = Expression.ZERO;
		var j = -1;
		var y = -2;
		var yc = Expression.ZERO;
		while (x !== -1 || y !== -1) {
			var d = Math.max(x, y);
			if (d !== -2) {

				var c = mapFunction(x >= y ? xc : Expression.ZERO, y >= x ? yc : Expression.ZERO);
				if (x !== y || !c.equals(Expression.ZERO)) {
					newData.add(d, c);
				}
			}
			if (x === d) {
				i += 1;
				if (i < A.a.size) {
					x = A.a.degree(i);
					xc = A.a.coefficient(i);
				} else {
					x = -1;
					xc = Expression.ZERO;
				}
			}
			if (y === d) {
				j += 1;
				if (j < B.a.size) {
					y = B.a.degree(j);
					yc = B.a.coefficient(j);
				} else {
					y = -1;
					yc = Expression.ZERO;
				}
			}
		}
		return new Polynomial(newData);
	}

	Polynomial.prototype.add = function (p) {
		if (p.a.size === 0) {
			return this;
		}
		if (this.a.size === 0) {
			return p;
		}
		return _join(this, p, function (xc, yc) {
			if (xc === Expression.ZERO) {
				return yc;
			}
			if (yc === Expression.ZERO) {
				return xc;
			}
			return xc.add(yc);
		});
	};
	var KARATSUBA_THRESHOLD = 12 + 48;

	function karatsuba(p1, p2) {

		var m2 = p2.a.size > p1.a.size ? p2.a.degree(Math.floor(p2.a.size / 2)) : p1.a.degree(Math.floor(p1.a.size / 2));

		var high1 = high(p1, m2);
		var low1 = low(p1, m2);
		var high2 = p1 === p2 ? high1 : high(p2, m2);
		var low2 = p1 === p2 ? low1 : low(p2, m2);

		var z0 = low1.multiply(low2);
		var low1phigh1 = low1.add(high1);
		var z1 = low1phigh1.multiply(p1 === p2 ? low1phigh1 : low2.add(high2));
		var z2 = high1.multiply(high2);
		return z2.shift(m2 * 2).add(z1.subtract(z2).subtract(z0).shift(m2)).add(z0);
	}

	function coefficientsBound(p, estimateOnly) {
		estimateOnly = estimateOnly == undefined ? false : estimateOnly;

		if (p.a.size <= 4) {
			estimateOnly = false;
		}
		var s1 = Math.floor(p.a.size / 2);
		var s2 = p.a.size - 1 - (s1 + 1);
		var max = Expression.ZERO;
		var min = Expression.ZERO;
		for (var i = 0; i < p.a.size; i += estimateOnly ? i === 0 ? s1 : i === s1 + 1 ? s2 : 1 : 1) {
			var c = p.a.coefficient(i);
			if (c.compareTo(max) > 0) {
				max = c;
			} else if (c.compareTo(min) < 0) {
				min = c;
			}
		}
		var n = (min.negate().compareTo(max) < 0 ? max : min.negate()).bitLength();
		return n;
	}

	var supportsLargeBigintCache = undefined;

	function supportsLargeBigint() {

		if (supportsLargeBigintCache == undefined) {
			try {
				supportsLargeBigintCache = Expression.ONE.leftShift(Math.pow(2, 20)).compareTo(Expression.ZERO) > 0;
			} catch (error) {

				supportsLargeBigintCache = false;
			}
		}
		return supportsLargeBigintCache;
	}

	function hasFastBigIntMultiplication() {
		return supportsLargeBigint();
	}

	function toInteger(coefficients, blockSize) {
		var bigIntCache = new Array(coefficients.length).fill(null);

		function toIntegerInternal(start, end) {
			var k = end - start;
			if (k >= 2) {
				var m = Math.ceil(k / 2);
				if (bigIntCache[m] == null) {
					bigIntCache[m] = BigInt(blockSize * m);
				}
				return toIntegerInternal(start + m, end) << bigIntCache[m] | toIntegerInternal(start, start + m);
			} else if (k === 1) {
				return coefficients[start];
			} else {
				throw new RangeError();
			}
		}

		var zero = BigInt(0);
		var one = BigInt(1);
		var M = one << BigInt(blockSize);
		var Mm1 = M - one;
		var borrow = 0;
		for (var i = 0; i < coefficients.length; i += 1) {
			var c = coefficients[i];
			if (borrow === 0) {
				if (c < zero) {
					c += M;
					borrow = 1;
				}
			} else {

				if (c <= zero) {
					c += Mm1;
				} else {
					c -= one;
					borrow = 0;
				}
			}
			coefficients[i] = c;
		}
		var n = toIntegerInternal(0, coefficients.length);
		if (borrow === 1) {
			n -= one << BigInt(blockSize * coefficients.length);
		}
		return n;
	}

	function toPolynomial(bigint, blockSize, blocksCount) {
		var bigIntCache = new Array(blocksCount).fill(null);
		var k = blocksCount;
		var coefficients = new Array(k);

		function toPolynomialInternal(C, start, end) {
			var k = end - start;
			if (k >= 2) {
				var m = Math.ceil(k / 2);
				var r = BigInt.asUintN(blockSize * m, C);
				toPolynomialInternal(r, start, start + m);
				if (bigIntCache[m] == null) {
					bigIntCache[m] = BigInt(blockSize * m);
				}
				var q = C >> bigIntCache[m];
				toPolynomialInternal(q, start + m, end);
			} else if (k === 1) {
				coefficients[start] = C;
			} else {
				throw new RangeError();
			}
		}

		toPolynomialInternal(BigInt(bigint), 0, k);
		var one = BigInt(1);
		var M = one << BigInt(blockSize);
		var Mm1 = M - one;
		var MOver2 = M >> one;
		var MOver2m1 = MOver2 - one;
		var carry = 0;
		for (var i = 0; i < coefficients.length; i += 1) {
			var c = coefficients[i];
			if (carry === 0) {
				if (c >= MOver2) {
					c -= M;
					carry = 1;
				}
			} else {

				if (c >= MOver2m1) {
					c -= Mm1;
				} else {
					c += one;
					carry = 0;
				}
			}
			coefficients[i] = c;
		}
		if (carry !== 0) {

		}
		return coefficients;
	}

	function toCoefficients(p) {
		var coefficients = new Array(p.getDegree() + 1).fill(BigInt(0));
		for (var i = 0; i < p.a.size; i += 1) {
			coefficients[p.a.degree(i)] = BigInt(p.a.coefficient(i).toBigInt());
		}
		return coefficients;
	}

	function multiplyByKroneckerSubstitution(A, B, low) {
		low = low == undefined ? -1 : low;

		if (A.getDegree() < 0) {
			return A.multiply(B);
		}
		if (B.getDegree() < 0) {
			return A.multiply(B);
		}
		var g = Math.gcd(A.getGCDOfTermDegrees(), B.getGCDOfTermDegrees());
		if (g > 1) {
			A = A._exponentiateRoots(g);
			B = B._exponentiateRoots(g);
		}

		var bA = coefficientsBound(A);
		var bB = coefficientsBound(B);
		var blockSize = Math.ceil((bA + bB + Math.ceil(Math.log2(Math.min(A.getDegree() + 1, B.getDegree() + 1))) + 1) / 8) * 8;
		var C = Expression.ZERO;
		var es = (A.getDegree() + B.getDegree() + 1) * blockSize;
		if (es >= 1 << 30 || es >= 1 << 20 && !supportsLargeBigint()) {
			C = karatsuba(A, B);
		} else {
			var Ai = toInteger(toCoefficients(A), blockSize);
			var Bi = A === B ? Ai : toInteger(toCoefficients(B), blockSize);
			var blocksCount = A.getDegree() + B.getDegree() + 1;
			if (low !== -1) {
				blocksCount = Math.min(low, blocksCount);
			}
			var P = BigInt.asUintN(blocksCount * blockSize, Ai * Bi);
			C = Polynomial.from(toPolynomial(P, blockSize, blocksCount).map(function (c) {
				return Expression.Integer.fromBigInt(c);
			}));
		}
		if (g > 1) {
			C = C._exponentiateRoots(1 / g);
		}

		return C;
	}

	function multiplyInternal(A, B, fromLeft, low) {
		var npmp1 = A.getDegree() + B.getDegree() + 1;
		if ((A.a.size + B.a.size + Math.min(A.a.size, B.a.size)) * 4 >= npmp1) {

			var result = new Array(npmp1);
			for (var i = 0; i < npmp1; i += 1) {
				result[i] = Expression.ZERO;
			}
			for (var i = 0; i < A.a.size; i += 1) {
				var d = A.a.degree(i);
				var c = A.a.coefficient(i);
				var j = 0;
				if (low != -1) {
					while (j < B.a.size && B.a.degree(j) + d >= low) {
						j += 1;
					}
				}
				for (; j < B.a.size; j += 1) {
					var bd = B.a.degree(j);
					var bj = B.a.coefficient(j);
					var degree = d + bd;
					var coefficient = fromLeft ? c.multiply(bj) : bj.multiply(c);
					result[degree] = result[degree].add(coefficient);
				}
			}
			return Polynomial.from(result);
		} else {
			var result = new FastAdditionPolynomial();
			for (var i = 0; i < A.a.size; i += 1) {
				var d = A.a.degree(i);
				var c = A.a.coefficient(i);
				result.add(c, d, B, fromLeft);
			}
			return result.toPolynomial();
		}
	}

	var hasBigInt = globalThis.BigInt != undefined && typeof BigInt(0) === 'bigint';
	globalThis.KroneckerSubstitutionCounter = 0;
	globalThis.KaratsubaCounter = 0;
	Polynomial.prototype.multiply = function (p, options) {
		options = options == undefined ? undefined : options;

		if (this.a.size === 0 || p.a.size === 0) {
			return Polynomial.ZERO;
		}
		if (p.a.size === 1 && p.a.coefficient(0) instanceof Expression.Integer) {

			return this.shift(p.a.degree(0)).scale(p.a.coefficient(0));
		}
		var low = options != null && options.low != null ? options.low | 0 : -1;
		if (this.a.size >= 12 && p.a.size >= 12 && hasBigInt) {
			if (this.hasIntegerCoefficients() && p.hasIntegerCoefficients()) {
				var A = this;
				var B = p;

				var g = Math.gcd(A.getGCDOfTermDegrees(), B.getGCDOfTermDegrees());
				var minDegree = Math.min(A.getDegree(), B.getDegree());
				var minDensity = Math.min((A.a.size - 1) / A.getDegree(), (B.a.size - 1) / B.getDegree());
				var cA = coefficientsBound(A, true);
				var cB = coefficientsBound(B, true);
				if (Math.max(cA, cB) >= 32 && Math.max(cA, cB) <= 1024 && minDensity >= 0.8 && minDegree >= 12 - 1 || hasFastBigIntMultiplication() && minDegree * minDensity >= 64 || hasFastBigIntMultiplication() && minDegree * minDensity * Math.min(cA, cB) * Math.pow(minDensity * g, 2) >= 64 * 1024) {

					globalThis.KroneckerSubstitutionCounter += 1;
					return multiplyByKroneckerSubstitution(A, B, low);
				} else {
					if (g == 1) {

					}
				}
			}
		}
		if (p.a.size >= KARATSUBA_THRESHOLD && this.a.size >= KARATSUBA_THRESHOLD) {

			globalThis.KaratsubaCounter += 1;
			return karatsuba(this, p);
		}
		if (this.a.size <= p.a.size) {
			return multiplyInternal(this, p, true, low);
		} else {
			return multiplyInternal(p, this, false, low);
		}
	};
	Polynomial.prototype.shift = function (n) {

		if (!(n >= 0)) {
			throw new TypeError();
		}
		if (n === 0) {
			return this;
		}
		var newData = new PolynomialData(this.a.size);
		for (var i = 0; i < this.a.size; i += 1) {
			newData.add(this.a.degree(i) + n, this.a.coefficient(i));
		}
		return new Polynomial(newData);
	};

	function FastAdditionPolynomial() {

		this.maxHeap = new Heap(function (a, b) {
			return b.degree - a.degree;
		});
		this.degree = -1;
		this.leadingCoefficient = Expression.ZERO;
	}

	FastAdditionPolynomial.prototype.add = function (scale, shift, polynomial, fromLeft) {
		var i = 0;
		var iterator = {
			next: function () {
				if (i === polynomial.a.size) {
					return undefined;
				}
				var d = polynomial.a.degree(i);
				var c = polynomial.a.coefficient(i);
				i += 1;
				return freeze({
					degree: d + shift,
					coefficient: c === Expression.ONE ? scale : scale === Expression.ONE ? c : fromLeft ? scale.multiply(c) : c.multiply(scale),
					iterator: iterator
				});
			}
		};
		var newEntry = iterator.next();
		if (newEntry.degree > this.degree && this.degree !== -1) {
			throw new RangeError();
		} else if (newEntry.degree < this.degree) {
			this.maxHeap.push(newEntry);
		} else {
			if (this.degree === -1) {
				this.leadingCoefficient = newEntry.coefficient;
				this.degree = newEntry.degree;
			} else {
				this.leadingCoefficient = this.leadingCoefficient.add(newEntry.coefficient);
			}
			newEntry = newEntry.iterator.next();
			if (newEntry != undefined) {
				this.maxHeap.push(newEntry);
			}

			while (this.maxHeap.size() > 0 && (this.degree === this.maxHeap.peek().degree || this.leadingCoefficient.equals(Expression.ZERO))) {
				var tmp = this.maxHeap.peek();
				this.leadingCoefficient = this.leadingCoefficient.add(tmp.coefficient);
				this.degree = tmp.degree;
				var next = tmp.iterator.next();
				if (next != undefined) {

					this.maxHeap.replace(next);
				} else {
					this.maxHeap.pop();
				}
			}
			if (this.maxHeap.size() === 0 && this.leadingCoefficient.equals(Expression.ZERO)) {
				this.degree = -1;
			}
		}
	};
	FastAdditionPolynomial.prototype.getDegree = function () {
		return this.degree;
	};
	FastAdditionPolynomial.prototype.getLeadingCoefficient = function () {
		return this.leadingCoefficient;
	};
	FastAdditionPolynomial.prototype.toPolynomial = function () {
		var terms = [];
		var ONE = Polynomial.of(Expression.ONE);
		while (this.getDegree() >= 0) {
			var degree = this.getDegree();
			var coefficient = this.getLeadingCoefficient();
			this.add(coefficient.negate(), degree, ONE, true);
			terms.push({
				degree: degree,
				coefficient: coefficient
			});
		}
		return Polynomial.fromTerms(terms);
	};
	Polynomial.prototype._div = function (p, w, callback0) {
		w = w || undefined;
		callback0 = callback0 || undefined;
		if (p.equals(Polynomial.ZERO)) {
			throw new TypeError("ArithmeticException");
		}
		if (this.getDegree() < p.getDegree()) {
			return Polynomial.ZERO;
		}
		if (p.a.size === 1 && p.a.coefficient(0).equals(Expression.ONE) && (w == undefined || this._hasIntegerLikeCoefficients())) {

			if (p.a.degree(0) === 0) {
				return this;
			}
			var s = p.a.degree(0);
			return high(this, s);
		}
		var lcp = p.getLeadingCoefficient();
		var isMonic = lcp instanceof Expression.Integer && lcp.equals(Expression.ONE);
		var isNegateOfMonic = lcp instanceof Expression.Integer && lcp.equals(Expression.ONE.negate());
		var lcpInv = lcp instanceof Expression.ExpressionWithPolynomialRoot ? lcp.inverse() : undefined;
		if (p.a.size === 1 && p.a.degree(0) === 0 && lcpInv == undefined && (w == undefined || w === "throw")) {
			var q = this.map(function (c) {
				var q = isMonic ? c : isNegateOfMonic ? c.negate() : c.divide(lcp);
				if (w != undefined) {
					if (q instanceof Expression.Division) {
						throw new RangeError();
					}
				}

				return q;
			});
			return q;
		}
		if (p.getDegree() >= 24 * 4 && true && this.getDegree() <= 2 * p.getDegree() + 2) {

			if (w == undefined && callback0 == undefined) {

				var q = fastDivisionJebelean(this, p);
				return q;
			}
		}
		var quotient = [];
		var isSparse = this.a.size / this.getDegree() < 1 / 4;
		var remainder = null;
		var remainderDegree = this.getDegree();
		var pDegree = p.getDegree();
		if (isSparse) {
			remainder = new FastAdditionPolynomial();
			remainder.add(Expression.ONE, 0, this, true);
		} else {
			remainder = new Array(remainderDegree + 1).fill(Expression.ZERO);
			for (var i = 0; i < this.a.size; i += 1) {
				var d = this.a.degree(i);
				if (d < pDegree) {
					break;
				}
				remainder[d] = this.a.coefficient(i);
			}
		}
		var minusP = p.negate();
		while (remainderDegree >= pDegree) {
			var n = remainderDegree - pDegree;
			var lcr = isSparse ? remainder.getLeadingCoefficient() : remainder[remainderDegree];
			var q = lcpInv == undefined ? isMonic ? lcr : isNegateOfMonic ? lcr.negate() : lcr.divide(lcp) : lcr.multiply(lcpInv);
			if (callback0 != undefined) {
				q = callback0(q);
			}
			if (w != undefined) {
				if (q instanceof Expression.Division) {
					if (w === "throw") {
						throw new TypeError(this.toString() + " " + p.toString());
					} else if (w === "undefined") {
						return undefined;
					} else {
						throw new TypeError();
					}
				}
			}

			quotient.push({
				degree: n,
				coefficient: q
			});

			if (isSparse) {
				remainder.add(q, n, minusP, true);
				if (callback0 != undefined) {
					while (remainder.getDegree() >= 0 && callback0(remainder.getLeadingCoefficient()).equals(Expression.ZERO)) {

						remainder.add(Expression.ONE, remainder.getDegree(), Polynomial.of(remainder.getLeadingCoefficient().negate()), true);
					}
				}
				remainderDegree = remainder.getDegree();
			} else {
				if (!(q instanceof Expression.Integer && q.equals(Expression.ZERO))) {
					var isOne = q instanceof Expression.Integer && q.equals(Expression.ONE);
					var n = remainderDegree - pDegree;
					for (var j = 0; j < minusP.a.size; j += 1) {
						var d = minusP.a.degree(j);
						var c = minusP.a.coefficient(j);
						if (d + n < pDegree) {
							break;
						}
						remainder[d + n] = remainder[d + n].add(isOne ? c : q.multiply(c));
					}
				}
				while (remainderDegree >= 0 && remainder[remainderDegree].equals(Expression.ZERO)) {
					remainder[remainderDegree] = Expression.ZERO;
					remainderDegree -= 1;
				}
				if (callback0 != undefined) {
					while (remainderDegree >= 0 && callback0(remainder[remainderDegree]).equals(Expression.ZERO)) {
						remainder[remainderDegree] = Expression.ZERO;
						remainderDegree -= 1;
					}
				}

			}

			if (remainderDegree - pDegree === n) {

				throw new TypeError("there is a some problem with the expression evaluation");
			}
		}

		return Polynomial.fromTerms(quotient);
	};
	Polynomial.prototype.divideAndRemainder = function (p, w) {
		w = w == undefined ? undefined : w;

		if (arguments.length > 2) {
			throw new RangeError();
		}
		var q = this._div(p, w);
		return divremResult(this, p, q, 0);
	};

	var high = function (p, n) {
		if (n <= 0) {
			return p;
		}
		var k = 0;
		while (k < p.a.size && p.a.degree(k) >= n) {
			k += 1;
		}
		var newData = new PolynomialData(k);
		for (var i = 0; i < k; i += 1) {
			newData.add(p.a.degree(i) - n, p.a.coefficient(i));
		}
		return new Polynomial(newData);
	};
	var low = function (p, n) {
		if (n <= 0) {
			return Polynomial.of(Expression.ZERO);
		}
		var k = 0;
		while (k < p.a.size && p.a.degree(k) >= n) {
			k += 1;
		}
		if (k === 0) {
			return p;
		}
		var newData = new PolynomialData(p.a.size - k);
		for (var i = k; i < p.a.size; i += 1) {
			newData.add(p.a.degree(i), p.a.coefficient(i));
		}
		return new Polynomial(newData);
	};
	globalThis.low = low;
	Polynomial.prototype.reversal = function () {
		var n = this.getDegree();
		var newData = new PolynomialData(this.a.size);
		for (var i = this.a.size - 1; i >= 0; i -= 1) {
			newData.add(n - this.a.degree(i), this.a.coefficient(i));
		}
		return new Polynomial(newData);
	};
	var inv = function (g, k, p) {
		p = p == undefined ? 0 : p;

		var one = Polynomial.of(Expression.ONE);
		var h = Polynomial.of(p === 0 ? g.getCoefficient(0).inverse() : g.getCoefficient(0).modInverse(p));
		var e = 1;
		while (e < k) {
			e *= 2;
			var hh = h.multiply(h);
			var x = h.add(h).subtract(multiplyLow(low(g, e), p === 0 ? hh : hh.mod(p), e));
			h = low(p === 0 ? x : x.mod(p), e);

			var c = 1;
			while (e * c < k) {
				c *= 2;
			}
			if ((e - 1) * c >= k) {
				e -= 1;
				h = low(h, e);
			}
		}
		return low(h, k);
	};
	var multiplyLow = function (a, b, n) {
		if (a.getDegree() > n) {
			throw new Error();
		}
		if (b.getDegree() > n) {
			throw new Error();
		}
		return low(a.multiply(b, {
			low: n
		}), n);
	};

	globalThis.multiplyLow = multiplyLow;

	var multiplyHigh = function (a, b, n) {

		var e = a.getDegree() + b.getDegree() - n + 1;
		if (e <= 0) {
			return Polynomial.ZERO;
		}
		var p = multiplyLow(low(a.reversal(), e), low(b.reversal(), e), e);
		return p.reversal().shift(e - 1 - p.getDegree());
	};

	function fastDivision(A, B, p, BRevModInv) {
		p = p == undefined ? 0 : p;
		BRevModInv = BRevModInv == undefined ? undefined : BRevModInv;

		var n = A.getDegree();
		var m = B.getDegree();
		var e = n - m + 1;
		if (e <= 0) {
			return Polynomial.ZERO;
		}
		if (BRevModInv == undefined) {
			BRevModInv = inv(B.reversal(), e, p);
		}

		var revQ = multiplyLow(low(A.reversal(), e), BRevModInv, e);
		var Q = revQ.reversal().shift(e - 1 - revQ.getDegree());
		if (p !== 0) {
			Q = Q.mod(p);
		}
		return Q;
	}

	function divremResult(a, b, q, p) {
		if (q == undefined) {
			return undefined;
		}
		var r = null;
		if (a === q) {
			r = Polynomial.ZERO;
		} else if (b.equals(Polynomial.ZERO)) {
			r = a;
		} else {
			var m = b.getDegree();
			var x = multiplyLow(low(q, m), b, m);
			if (p !== 0) {
				x = x.mod(p);
			}
			r = low(a, m).subtract(x);
			if (p !== 0) {
				r = r.mod(p);
			}
		}
		return {
			quotient: q,
			remainder: r
		};
	}

	function fastDivisionJebelean(a, b) {

		var q = Polynomial.ZERO;
		while (a.getDegree() > b.getDegree() * 2 + 2) {

			throw new RangeError('not implemented');

		}

		var s = Math.floor(b.getDegree() / 2);
		var bhi = high(b, s);
		var blo = low(b, s);
		var ahi = high(a, s + s);
		var q1 = ahi._div(bhi);
		var r1 = low(ahi, s + 1).subtract(multiplyLow(low(q1, s + 1), bhi, s + 1));
		ahi = r1.subtract(multiplyHigh(q1, blo, s)).shift(s);
		var q2 = ahi._div(bhi);
		q = q.add(q1.shift(s)).add(q2);
		return q;
	}

	Polynomial.prototype._divJebelean = function (p) {
		return fastDivisionJebelean(this, p);
	};
	Polynomial.prototype._divNewton = function (p, bModInv) {
		return fastDivision(this, p, 0, bModInv);
	};
	Polynomial.prototype.divideAndRemainderModP = function (divisor, p) {
		var divisorLeadingCoefficient = divisor.getLeadingCoefficient();
		if (!(divisorLeadingCoefficient instanceof Expression.Polynomial) && !divisorLeadingCoefficient.equals(Expression.ONE) || divisorLeadingCoefficient instanceof Expression.Polynomial && divisorLeadingCoefficient.polynomial.getDegree() !== 0) {
			throw new RangeError();
		}

		if (divisor.getDegree() >= 64 && this.getDegree() - divisor.getDegree() >= 64) {
			var q = fastDivision(this, divisor, p);
			return divremResult(this, divisor, q, p);
		}

		var q = this._div(divisor, "throw", function (c) {
			return c.modulo(p);
		});
		return divremResult(this, divisor, q, p);
	};
	Polynomial._preinvert = function (b, p, n) {
		return inv(b.reversal(), n - b.getDegree() + 1, p);
	};
	Polynomial.pseudoRemainder = function (A, B) {
		var d = A.getDegree() - B.getDegree();

		if (d < 0) {
			throw new RangeError();
		}
		return A.scale(B.getLeadingCoefficient()._pow(d + 1)).divideAndRemainder(B, "throw").remainder;
	};
	Polynomial.polynomialGCD = function (a, b) {
		var g = Math.gcd(a.getGCDOfTermDegrees(), b.getGCDOfTermDegrees());
		if (g > 1) {
			return Polynomial.polynomialGCD(a._exponentiateRoots(g), b._exponentiateRoots(g))._exponentiateRoots(1 / g);
		}

		if (b.getDegree() > 0 && a.getDegree() > 0) {
			var ctz = function (p) {
				var i = 0;
				while (p.getCoefficient(i).equals(Expression.ZERO)) {
					i += 1;
				}
				return i;
			};
			var i = ctz(b);
			var j = ctz(a);
			if (i !== 0 || j !== 0) {

				return Polynomial.polynomialGCD(a.divideAndRemainder(Polynomial.of(Expression.ONE).shift(j), undefined).quotient, b.divideAndRemainder(Polynomial.of(Expression.ONE).shift(i), undefined).quotient).shift(Math.min(i, j));
			}
		}

		if (a.getDegree() < b.getDegree()) {

			var tmp = a;
			a = b;
			b = tmp;
		}
		if (b.equals(Polynomial.ZERO)) {
			return a;
		}

		if (a.getDegree() === 1 && b.getDegree() === 0) {
			return Polynomial.of(b.getCoefficient(0).gcd(a.getCoefficient(0)).gcd(a.getCoefficient(1)));
		}

		var contentA = a.getContent();
		var contentB = b.getContent();
		var ppA = a.divideAndRemainder(Polynomial.of(contentA), "throw").quotient;
		var ppB = b.divideAndRemainder(Polynomial.of(contentB), "throw").quotient;
		var ppGCD = gcdOfPrimitivePolynomials(ppA, ppB);
		var contentGCD = contentA.gcd(contentB);
		return Polynomial.of(contentGCD).multiply(ppGCD);
	};

	function hasQuadraticInteger(c) {
		if (c instanceof Expression.NthRoot) {
			return !(c instanceof Expression.Integer);
		}
		if (c instanceof Expression.ExponentiationOfMinusOne) {
			return true;
		}

		if (c instanceof Expression.BinaryOperation) {
			return hasQuadraticInteger(c.a) || hasQuadraticInteger(c.b);
		}

		if (c instanceof Expression.Integer || c instanceof Expression.Symbol || c instanceof Expression.Complex) {
			return false;
		}

		return false;
	}

	var getY = function (p, other) {
		var visited = {};
		for (var i = 0; i < p.a.size; i++) {
			var c = p.a.coefficient(i);
			var v = Expression.getVariable(c, {
				avoidNthRoots: true
			});
			if (v != null) {
				if (v instanceof Expression.ExpressionWithPolynomialRoot) {

					return null;
				}

				if (Expression.isConstant(v) && v !== Expression.E && v !== Expression.PI) {

					return null;
				}
				if (v instanceof Expression.Polynomial) {
					return null;
				}

				if (v instanceof Expression.Symbol) {
					if (visited[v.symbol]) {
						v = null;
					} else {
						visited[v.symbol] = true;
					}
				}
				for (var j = 0; j < p.a.size && v != null; j += 1) {
					if (!Expression._getReplacement(p.a.coefficient(j), v).equals(v)) {
						v = null;
					}
				}
				for (var j = 0; j < other.a.size && v != null; j += 1) {
					if (!Expression._getReplacement(other.a.coefficient(j), v).equals(v)) {
						v = null;
					}
				}
				if (v != null) {
					return v;
				}
			}
		}
		return null;
	};
	Polynomial._getY = getY;

	function gcdOfPrimitivePolynomials(A, B) {
		console.assert(A.getDegree() >= B.getDegree());

		if (A.hasIntegerCoefficients() && B.hasIntegerCoefficients() && B.getDegree() > 2) {
			if (A.isDivisibleBy(B)) {
				return B;
			}
			return gcdByModularAlgorithm(A, B);
		}

		if (B.getDegree() > 1) {
			if (getY(A, B) != null || getY(B, A) != null) {
				return gcdByMultivariateModularAlgorithm(A, B);
			}
		}

		if (B.getDegree() > 2) {

			return gcdUsingPseudoRemainderSequence(A, B, "subresultant").primitivePart();
		}

		if (!A._testCoefficients(function (c) {
			return hasQuadraticInteger(c);
		}) && !B._testCoefficients(function (c) {
			return hasQuadraticInteger(c);
		}) && B.getDegree() > 0) {

			return gcdUsingPseudoRemainderSequence(A, B, "primitive");
		}

		if (B.getDegree() === 0) {
			return Polynomial.of(Expression.ONE);
		}
		return gcdUsingRemainderSequence(A, B).primitivePart();
	}

	function gcdUsingRemainderSequence(A, B) {
		while (!B.equals(Polynomial.ZERO)) {
			var R = A.divideAndRemainder(B).remainder;
			A = B;
			B = R;
		}
		return A;
	}

	function gcdUsingPseudoRemainderSequence(A, B, type) {
		var g = Math.gcd(A.getGCDOfTermDegrees(), B.getGCDOfTermDegrees());
		if (g > 1) {

			return gcdUsingPseudoRemainderSequence(A._exponentiateRoots(g), B._exponentiateRoots(g), type)._exponentiateRoots(1 / g);
		}
		for (var iteratortmp = Polynomial._pseudoRemainderSequence(A, B, type)[globalThis.Symbol.iterator](), tmp = iteratortmp.next().value; tmp != null; tmp = iteratortmp.next().value) {
			var newR = tmp.R;
			A = B;
			B = newR;
		}
		var lastNonzeroRemainder = A;
		return lastNonzeroRemainder;
	}

	Polynomial._gcdUsingPseudoRemainderSequence = gcdUsingPseudoRemainderSequence;

	function ChineseRemainderTheorem(m1, m2) {

		var c = m1.remainder(m2).modInverse(m2);
		return function (r1, r2) {
			return r1.add(r2.subtract(r1.modulo(m2)).multiply(c).modulo(m2).multiply(m1));
		};
	}

	globalThis.ChineseRemainderTheorem = ChineseRemainderTheorem;

	function ChineseRemainderTheoremForPolynomialCoefficients(p1, p2, m1, m2) {
		var solution = ChineseRemainderTheorem(m1, m2);
		return _join(p1, p2, function (r1, r2) {
			return solution(r1, r2);
		});
	}

	globalThis.ChineseRemainderTheoremForPolynomialCoefficients = ChineseRemainderTheoremForPolynomialCoefficients;
	Polynomial.prototype._exponentiateRoots = function (n) {

		if (n === -1) {
			if (this.getCoefficient(0).equals(Expression.ZERO)) {
				throw new RangeError();
			}
			var newData = new PolynomialData(this.a.size);
			for (var j = this.a.size - 1; j >= 0; j -= 1) {
				newData.add(this.getDegree() - this.a.degree(j), this.a.coefficient(j));
			}
			var p = new Polynomial(newData);
			if (p.getLeadingCoefficient() instanceof Expression.Integer && p.getLeadingCoefficient().sign() < 0) {

				p = p.negate();
			}

			return p;
		}
		var inv = Math.floor(1 / n + 0.5);
		if (Math.floor(n) === n && n >= 2 || 1 / inv === n && inv >= 2) {
			var newData = new PolynomialData(this.a.size);
			for (var i = 0; i < this.a.size; i += 1) {
				if (Math.floor(n) === n && this.a.degree(i) % n !== 0) {
					throw new RangeError();
				}

				newData.add(Math.floor(n) === n ? this.a.degree(i) / n : this.a.degree(i) * inv, this.a.coefficient(i));
			}
			return new Polynomial(newData);
		}
		throw new RangeError(n);
	};
	Polynomial.prototype._scaleRoots = function (s) {
		var sn = s.getNumerator();
		var sd = s.getDenominator();
		var d = this.getDegree();
		var lastScale = Expression.ONE;
		var lastScaleDegree = 0;
		var newData = new PolynomialData(this.a.size);
		for (var i = 0; i < this.a.size; i += 1) {
			var degree = this.a.degree(i);
			var coefficient = this.a.coefficient(i);
			lastScale = lastScale.multiply(sn._pow(d - degree - lastScaleDegree));
			lastScaleDegree = d - degree;
			newData.add(degree, lastScale.multiply(sd._pow(degree)).multiply(coefficient));
		}
		return new Polynomial(newData);
	};
	Polynomial.prototype._translateRoots = function (h) {

		if (h.equals(Expression.ONE.negate())) {

			var u = this;
			var n = u.getDegree();
			var v = new Array(n + 1);
			for (var j = 0; j <= n; j += 1) {
				v[j] = u.getCoefficient(j);
			}
			for (var k = 0; k <= n - 1; k += 1) {
				for (var j = n - 1; j >= k; j -= 1) {
					v[j] = v[j].add(v[j + 1]);
				}
			}
			return Polynomial.from(v);
		}
		if (h.equals(Expression.ZERO)) {
			return this;
		}
		var v = h.getNumerator()._pow(this.getDegree());
		return this._scaleRoots(h.negate().inverse())._translateRoots(Expression.ONE.negate())._scaleRoots(h.negate()).map(function (c) {
			return c.divide(v);
		});
	};
	Polynomial.prototype.mod = function (m) {
		return this.map(function (c) {
			return c.modulo(m);
		});
	};
	Polynomial.prototype.roundMod = function (m) {
		return this.map(function (c) {
			return c.roundMod(m);
		});
	};

	Polynomial.prototype._pow = function (count) {
		var pow = function (x, count, accumulator) {
			if (count < 0) {
				throw new RangeError();
			}
			if (count > Number.MAX_SAFE_INTEGER) {
				throw new RangeError("NotSupportedError");
			}
			return count < 1 ? accumulator : 2 * Math.floor(count / 2) !== count ? pow(x, count - 1, accumulator.multiply(x)) : pow(x.multiply(x), Math.floor(count / 2), accumulator);
		};

		return pow(this, count, Polynomial.of(Expression.ONE));
	};

	function gcdByModularAlgorithm(a, b) {
		if (true) {
			var g = Math.gcd(a.getGCDOfTermDegrees(), b.getGCDOfTermDegrees());
			if (g > 1) {
				console.debug('g > 1');
				return gcdByModularAlgorithm(a._exponentiateRoots(g), b._exponentiateRoots(g))._exponentiateRoots(1 / g);
			}
		}

		var d = a.getLeadingCoefficient().abs().gcd(b.getLeadingCoefficient().abs());
		if (a.getCoefficient(0).equals(Expression.ZERO) || b.getCoefficient(0).equals(Expression.ZERO)) {
			throw new RangeError();
		}
		if (d.compareTo(a.getCoefficient(0).abs().gcd(b.getCoefficient(0).abs())) > 0) {

			return gcdByModularAlgorithm(a._exponentiateRoots(-1), b._exponentiateRoots(-1))._exponentiateRoots(-1);
		}
		console.assert(a.hasIntegerCoefficients() && a.getContent().abs().equals(Expression.ONE) && a.getDegree() > 0);
		console.assert(b.hasIntegerCoefficients() && b.getContent().abs().equals(Expression.ONE) && b.getDegree() > 0);
		var maxGCDDegree = Math.min(a.getDegree(), b.getDegree());
		var bound = function () {
			var maxGCDLeadingCoefficient = d;

			var logarithmOfCoefficientBound = Math.min(a._log2OfBoundForCoefficientsOfFactor(maxGCDDegree, maxGCDLeadingCoefficient), b._log2OfBoundForCoefficientsOfFactor(maxGCDDegree, maxGCDLeadingCoefficient));

			return Expression.TWO._pow(1 + Math.ceil(logarithmOfCoefficientBound));
		};
		var M = bound();

		var p = Expression.Integer.fromBigInt(Math.min(Math.max(M.toNumber(), 1024), Math.floor(Math.sqrt((Number.MAX_SAFE_INTEGER + 1) / (1 + Math.min(a.getDegree(), b.getDegree()))))));

		var counter = 0;
		while (true) {
			var g = null;
			var P = Expression.ZERO;
			while (P.compareTo(M) < 0) {
				counter += 1;
				if (counter > 50 && p._pow(counter - 50).compareTo(M) >= 0) {
					throw new TypeError("!!!");
				}
				do {
					p = p.subtract(Expression.ONE);
				} while (!isPrime(p.toBigInt()) || d.remainder(p).equals(Expression.ZERO));
				var cp = factorizeOverTheIntegers._gcdOfPolynomialsOverFiniteField0(a, b, p.toBigInt());
				console.assert(cp.getLeadingCoefficient().equals(Expression.ONE));
				var gp = cp.scale(d.remainder(p)).mod(p);
				if (gp.getDegree() < 1) {
					return Polynomial.of(Expression.ONE);
				}
				if (gp.getDegree() > 2 / 3 * a.getDegree()) {

				}
				if (gp.getDegree() > maxGCDDegree) {
					continue;
				}
				if (g != null && gp.getDegree() < g.getDegree()) {
					g = null;
				}

				if (g == null) {
					g = gp.roundMod(p);
					P = p;
					maxGCDDegree = gp.getDegree();
					M = bound();
				} else if (gp.getDegree() === g.getDegree()) {

					var oldG = g;
					g = ChineseRemainderTheoremForPolynomialCoefficients(g, gp, P, p);
					P = P.multiply(p);
					g = g.roundMod(P);

					if (P.compareTo(M) < 0 && oldG.equals(g)) {

						g = g.primitivePart();

						if (a.isDivisibleBy(g) && b.isDivisibleBy(g)) {
							return g;
						}
						g = oldG;
					} else {

					}
				}

			}

			g = g.primitivePart();

			if (a.isDivisibleBy(g) && b.isDivisibleBy(g)) {
				return g;
			}
		}
	}

	Polynomial._gcdByModularAlgorithm = gcdByModularAlgorithm;

	function gcdByMultivariateModularAlgorithm(a, b) {
		if (true) {
			var g = Math.gcd(a.getGCDOfTermDegrees(), b.getGCDOfTermDegrees());
			if (g > 1) {
				console.debug('g > 1');
				return gcdByMultivariateModularAlgorithm(a._exponentiateRoots(g), b._exponentiateRoots(g))._exponentiateRoots(1 / g);
			}
		}
		if (!a.getContent().equals(Expression.ONE) || !b.getContent().equals(Expression.ONE)) {
			return Polynomial.polynomialGCD(a, b);
		}
		var y = getY(a, b) || getY(b, a);
		if (y == null) {
			return Polynomial.polynomialGCD(a, b);
		}

		var M = Math.min(a.getDegree(), b.getDegree());

		a = a.map(function (c) {
			return new Expression.Polynomial(Polynomial.toPolynomial(c, y));
		});
		b = b.map(function (c) {
			return new Expression.Polynomial(Polynomial.toPolynomial(c, y));
		});
		var toPolynomialByAnotherVar = function (p) {

			var topLevelVar = new Expression.Polynomial(Polynomial.of(new Expression.Polynomial(Polynomial.of(Expression.ZERO, Expression.ONE))));
			return p.map(function (c) {
				return new Expression.Polynomial(c.polynomial.map(function (c) {
					return new Expression.Polynomial(Polynomial.of(c));
				}));
			}).calcAt(topLevelVar).polynomial;
		};
		var aByY = toPolynomialByAnotherVar(a);
		var bByY = toPolynomialByAnotherVar(b);
		var cgcd = aByY.getContent().gcd(bByY.getContent()).polynomial.primitivePart();
		if (!cgcd.equals(Polynomial.of(Expression.ONE))) {
			var divide = function (p) {
				return p.map(function (c) {
					return new Expression.Polynomial(c.polynomial.divideAndRemainder(cgcd, cgcd._hasIntegerLikeCoefficients() ? "throw" : undefined).quotient);
				}).calcAt(new Expression.Polynomial(Polynomial.of(y))).polynomial;
			};
			return gcdByMultivariateModularAlgorithm(divide(aByY), divide(bByY)).multiply(cgcd);
		}
		console.assert(cgcd.equals(Polynomial.of(Expression.ONE)));
		if (aByY.getDegree() === 0 || bByY.getDegree() === 0) {
			return Polynomial.of(Expression.ONE);
		}

		var d = Polynomial.polynomialGCD(aByY.getLeadingCoefficient().polynomial, bByY.getLeadingCoefficient().polynomial);
		var interpolation = function () {
			NewtonInterpolation.setField(Expression._FIELD);
			var polynomialInterpolation = NewtonInterpolation();
			polynomialInterpolation.next();
			return polynomialInterpolation;
		};
		var integerLikeCoefficientsPolynomials = a._hasIntegerLikeCoefficients() && b._hasIntegerLikeCoefficients();
		var r = Expression.ZERO;
		var m = 0;
		var g = null;
		var gDegreeByY = 1 / 0;
		var polynomialInterpolation = null;
		while (true) {
			do {
				r = Expression.Integer.fromNumber(r.toNumber() + 1);
				if (r.toNumber() - M > 2) {
					console.error("!", r.toNumber() - M);
				}
			} while (d.calcAt(r).equals(Expression.ZERO));
			var g_r = Polynomial.polynomialGCD(a.calcAt(r).polynomial, b.calcAt(r).polynomial);
			if (g_r.getDegree() === 0) {
				return Polynomial.of(Expression.ONE);
			}

			if (g_r.getDegree() > gDegreeByY) {
				continue;
			}
			var d_xequalr = d.calcAt(r);
			g_r = g_r.scale(d_xequalr).scale(g_r.getLeadingCoefficient().inverse());
			if (integerLikeCoefficientsPolynomials && !g_r._hasIntegerLikeCoefficients()) {
				continue;
			}
			if (m === M + 1 || g_r.getDegree() < gDegreeByY) {

				m = 0;
				polynomialInterpolation = interpolation();
			}
			var oldG = g;
			g = Polynomial.from(polynomialInterpolation.next([r.toNumber(), new Expression.Polynomial(g_r)]).value);
			m += 1;
			gDegreeByY = g_r.getDegree();

			if (integerLikeCoefficientsPolynomials) {
				if (g != null && !g._hasIntegerLikeCoefficients()) {
					debugger;
				}
			}
			if (oldG != null && oldG.equals(g) || m === M + 1) {
				if (!integerLikeCoefficientsPolynomials || g._hasIntegerLikeCoefficients()) {

					g = toPolynomialByAnotherVar(toPolynomialByAnotherVar(g).primitivePart());
					if (!integerLikeCoefficientsPolynomials || g.getContent().equals(Expression.ONE)) {

						if (a.isDivisibleBy(g) && b.isDivisibleBy(g)) {
							g = g.map(function (c) {
								return c.polynomial.calcAt(y);
							});
							if (g.getLeadingCoefficient().isNegative()) {
								g = g.negate();
							}
							if (!integerLikeCoefficientsPolynomials) {
								g = g.primitivePart();
							}
							return g;
						}
					}
					g = oldG;
				} else {
					debugger;
				}
			}
		}
	};Polynomial._gcdByMultivariateModularAlgorithm = gcdByMultivariateModularAlgorithm;
	Polynomial.prototype.calcAt = function (point) {

		if (point instanceof Expression.Division && point.getNumerator() instanceof Expression.Integer && point.getDenominator() instanceof Expression.Integer && this.hasIntegerCoefficients()) {
			var n = this.getDegree();
			var p = this._scaleRoots(point.getDenominator());
			return p.calcAt(point.getNumerator()).divide(point.getDenominator()._pow(n));
		}
		if ((point instanceof Expression.Symbol && !(point instanceof Expression.ExpressionPolynomialRoot) || point instanceof Expression.NthRoot) && this.hasIntegerCoefficients()) {
			var s = new Array(this.a.size);
			for (var i = 0; i < this.a.size; i += 1) {
				var degree = this.a.degree(i);
				var coefficient = this.a.coefficient(i);
				s[i] = coefficient.multiply(point._pow(degree));
			}
			return Expression._sum(s);
		}

		if (point instanceof Expression.ExpressionPolynomialRoot && this.hasIntegerCoefficients()) {

			var p = this;
			var x = point;

			var k = Math.ceil(Math.sqrt(p.getDegree() + 1));
			var xPows = [];
			xPows.push(Expression.ONE);
			while (xPows.length <= k) {
				xPows.push(xPows[xPows.length - 1].multiply(x));
			}
			var a = [];
			var s = Expression.ZERO;
			for (var i = 0; i <= p.getDegree(); i += 1) {
				if (i !== 0 && i % k === 0) {
					a.push(s);
					s = Expression.ZERO;
				}
				s = s.add(p.getCoefficient(i).multiply(xPows[i % k]));
			}
			while (a.length > 0) {
				s = s.multiply(xPows[k]).add(a.pop());
			}
			return s;
		}
		var n = Expression.ZERO;
		var lastDegree = -1;
		for (var i = 0; i < this.a.size; i += 1) {
			var degree = this.a.degree(i);
			var coefficient = this.a.coefficient(i);
			if (!n.equals(Expression.ZERO)) {
				n = Expression.pow(point, lastDegree - degree).multiply(n).add(coefficient);
			} else {
				n = coefficient;
			}
			lastDegree = degree;
		}
		if (!n.equals(Expression.ZERO)) {
			n = Expression.pow(point, lastDegree - 0).multiply(n);
		}
		return n;
	};
	Polynomial.prototype.getContent = function () {
		if (this.a.size === 0) {
			return Expression.ONE;
		}
		var denominator = Expression.ONE;
		var numerator = Expression.ZERO;
		for (var i = 0; i < this.a.size; i += 1) {
			var k = i % 2 === 0 ? i / 2 : this.a.size - (i + 1) / 2;
			var y = this.a.coefficient(k);
			denominator = denominator.lcm(y.getDenominator());
			numerator = numerator.gcd(y.getNumerator());
		}
		var c = numerator.divide(denominator);
		var x = this.a.coefficient(0);
		return x.isNegative() && !numerator.isNegative() || numerator.isNegative() && !x.isNegative() ? c.negate() : c;
	};

	Polynomial.prototype.negate = function () {

		return this.map(function (coefficient) {
			return coefficient.negate();
		});
	};
	Polynomial.prototype.subtract = function (l) {
		return this.add(l.negate());
	};
	Polynomial.prototype.scale = function (x) {
		if (x.equals(Expression.ONE)) {
			return this;
		}
		if (Expression.has(x, Expression.Matrix) || Expression.has(x, Expression.MatrixSymbol)) {
			throw new TypeError();
		}
		return this.map(function (coefficient) {
			return coefficient.multiply(x);
		});
	};
	Polynomial.prototype.unscale = function (x) {
		return this.map(function (coefficient) {
			return coefficient.divide(x);
		});
	};
	Polynomial.fromTerms = function (terms) {
		var newData = new PolynomialData(terms.length);
		for (var i = 0; i < terms.length; i += 1) {
			var term = terms[i];
			newData.add(term.degree, term.coefficient);
		}
		return new Polynomial(newData);
	};
	Polynomial.toPolynomial = function (e, v) {
		if (e instanceof Expression.Division) {
			throw new RangeError();
		}
		var terms = Expression.getCoefficients(e, v);
		return Polynomial.fromTerms(terms);
	};
	Polynomial.prototype.toExpression = function (variableSymbol) {
		var result = undefined;
		for (var i = 0; i < this.a.size; i += 1) {
			var degree = this.a.degree(i);
			var coefficient = this.a.coefficient(i);
			var v = degree === 0 ? undefined : degree === 1 ? variableSymbol : new Expression.Exponentiation(variableSymbol, Expression.Integer.fromNumber(degree));
			var current = v == undefined ? coefficient : coefficient.equals(Expression.ONE) ? v : new Expression.Multiplication(coefficient, v);
			result = result == undefined ? current : new Expression.Addition(result, current);
		}
		return result == undefined ? Expression.ZERO : result;
	};

	Polynomial.prototype.doRationalRootTest = function () {
		var np = this;
		if (np.getCoefficient(0).equals(Expression.ZERO)) {
			return Expression.ZERO;
		}

		var an = np.getLeadingCoefficient();
		var a0 = np.getCoefficient(0);
		a0 = Expression._expandTrigonometry(a0);
		if (np.getDegree() === 1) {
			return a0.negate().divide(an);
		}

		var hasIntegerCoefficients = np.hasIntegerCoefficients();

		var fp1 = null;
		var fm1 = null;
		if (hasIntegerCoefficients) {
			fp1 = np.calcAt(Expression.ONE);
			if (fp1.equals(Expression.ZERO)) {
				return Expression.ONE;
			}
			fm1 = np.calcAt(Expression.ONE.negate());
			if (fm1.equals(Expression.ZERO)) {
				return Expression.ONE.negate();
			}
		}
		var filter = function (n, d) {
			if (fp1 != null) {
				if (d.subtract(n).equals(Expression.ZERO)) {
					return false;
				}
				if (!fp1.remainder(d.subtract(n)).equals(Expression.ZERO)) {
					return false;
				}
			}
			if (fm1 != null) {
				if (d.add(n).equals(Expression.ZERO)) {
					return false;
				}
				if (!fm1.remainder(d.add(n)).equals(Expression.ZERO)) {
					return false;
				}
			}
			return true;
		};

		if (hasIntegerCoefficients && an.abs().bitLength() + a0.abs().bitLength() > 8) {

			var toInteger = function (zero, scale) {

				var interval = zero instanceof Expression.ExpressionPolynomialRoot ? zero.root._root.toDecimal(scale.abs().bitLength()) : zero.toDecimal(scale.abs().bitLength());
				var fraction = interval.a.add(interval.b).divide(Expression.TWO);
				return scale.multiply(fraction.getNumerator()).roundDivision(fraction.getDenominator());
			};
			var zeros = np.getZeros();
			for (var i = 0; i < zeros.length; i += 1) {
				var zero = zeros[i];
				if (i === 0 || zero !== zeros[i - 1]) {
					var candidate = zero.root != null ? toInteger(zero, an).divide(an) : zero.getNumerator() instanceof Expression.Integer && zero.getDenominator() instanceof Expression.Integer ? zero : Expression.ZERO;
					if (filter(candidate.getNumerator(), candidate.getDenominator()) && np.calcAt(candidate).equals(Expression.ZERO)) {
						return candidate;
					}
				}
			}
			return null;
		}

		var result = null;

		Expression.everyDivisor(a0, function (p) {
			return Expression.everyDivisor(an, function (q) {
				var sign = -3;
				while ((sign += 2) < 3) {
					var sp = sign === -1 ? p.negate() : p;
					if (

						filter(sp, q)) {

						var x = Polynomial.of(sp.negate(), q);
						var z = np.divideAndRemainder(x, "undefined");
						var r = z == undefined ? undefined : z.remainder.map(function (x) {
							return x.simplifyExpression();
						});
						if (r != undefined && r.equals(Polynomial.ZERO)) {
							result = sp.divide(q);
							return false;
						}
					}
				}
				return true;
			});
		});
		return result;
	};
	Polynomial.prototype._testCoefficients = function (f) {
		for (var i = 0; i < this.a.size; i += 1) {
			if (!f(this.a.coefficient(i))) {
				return false;
			}
		}
		return true;
	};
	Polynomial.prototype.hasIntegerCoefficients = function () {
		return this._testCoefficients(function (c) {
			return c instanceof Expression.Integer;
		});
	};
	Polynomial.prototype.hasComplexCoefficients = function () {
		return this._testCoefficients(function (c) {
			return c instanceof Expression.Complex || c instanceof Expression.Integer;
		});
	};
	var isIntegerLike = function (c) {
		if (c instanceof Expression.Integer) {
			return true;
		}
		if (c instanceof Expression.Symbol) {
			if (c instanceof Expression.ExpressionWithPolynomialRoot) {

				return false;
			}
			if (c instanceof Expression.ExpressionPolynomialRoot) {

				return false;
			}
			if (c instanceof Expression.PolynomialRootSymbol) {

				return true;
			}
			return true;
		}
		if (c instanceof Expression.Addition) {
			return isIntegerLike(c.a) && isIntegerLike(c.b);
		}
		if (c instanceof Expression.Multiplication) {
			return isIntegerLike(c.a) && isIntegerLike(c.b);
		}
		if (c instanceof Expression.Exponentiation) {
			return isIntegerLike(c.a) && c.b instanceof Expression.Integer && c.b.compareTo(Expression.TWO) >= 0;
		}
		if (c instanceof Expression.Polynomial) {
			return c.polynomial._hasIntegerLikeCoefficients();
		}
		return false;
	};

	Polynomial._isIntegerLike = isIntegerLike;
	Polynomial.prototype._hasIntegerLikeCoefficients = function () {
		return this._testCoefficients(function (c) {
			return Polynomial._isIntegerLike(c);
		});
	};
	Polynomial.prototype._canBeFactored = function (depth) {

		if (!this.hasIntegerCoefficients()) {

			return true;
		}
		if (this.getCoefficient(0).equals(Expression.ZERO)) {
			return true;
		}
		var content = this.getContent();
		if (!content.equals(Expression.ONE) && !content.equals(Expression.ONE.negate())) {
			return this.scale(content.inverse())._canBeFactored();
		}

		var g = this.subtract(Polynomial.of(this.getLeadingCoefficient()).shift(this.getDegree())).getContent();

		var x = null;
		do {
			x = g.gcd(this.getLeadingCoefficient());
			g = g.truncatingDivide(x);
		} while (!x.equals(Expression.ONE));
		var x = null;
		g = g.abs();
		while (!g.equals(Expression.ONE)) {
			var p = g.primeFactor();

			if (!this.getCoefficient(0).remainder(p._pow(2)).equals(Expression.ZERO)) {
				return false;
			}
			g = g.truncatingDivide(p);
		}
		if (depth == undefined) {

			if (!this._translateRoots(Expression.Integer.fromNumber(3).negate())._canBeFactored(1)) {
				return false;
			}

		}

		return true;
	};
	Polynomial.prototype.isEven = function () {
		return this.getGCDOfTermDegrees() % 2 === 0;
	};
	var counter = 0;

	Polynomial.prototype.getGCDOfTermDegrees = function () {
		if (this.equals(Polynomial.ZERO)) {
			return 0;
		}
		var g = this.getDegree();
		for (var i = 1; i <= this.getDegree() && g >= 2; i += 1) {
			if (!this.getCoefficient(i).equals(Expression.ZERO)) {
				g = Math.gcd(g, i);
			}
		}
		return g;
	};
	Polynomial.prototype.getroots = function (callback) {

		callback = callback || undefined;
		var np = this;
		var roots = [];

		var ct = Expression.ONE;
		var t = Expression.ZERO;
		while (t != null) {
			var t = Expression.getConjugate(np.getLeadingCoefficient());
			if (t != undefined) {
				np = np.scale(t);
				ct = ct.multiply(t);
			}
		}

		np = np.map(function (x) {
			return x.simplifyExpression();
		});

		var content = np.getContent();
		if (!content.equals(Expression.ONE)) {
			np = np.scale(content.getDenominator()).divideAndRemainder(Polynomial.of(content.getNumerator()), "throw").quotient;

		}

		if (!ct.equals(Expression.ONE)) {
			content = content.divide(ct);
		}

		while (np.getCoefficient(0).equals(Expression.ZERO)) {
			np = np.divideAndRemainder(Polynomial.of(Expression.ZERO, Expression.ONE), "throw").quotient;
			roots.push(Expression.ZERO);
		}
		if (!content.equals(Expression.ONE) && !content.equals(Expression.ONE.negate()) || roots.length > 0) {
			if (roots.length > 0) {
				if (typeof hit === "function") {
					hit({
						getroots: {
							special: "0"
						}
					});
				}
			}
			if (callback != undefined) {
				callback({
					content: content,
					roots: roots,
					newPolynomial: np,
					type: "factorOutTheGreatestCommonFactor"
				});
			}
		}
		if (np.getDegree() === 1) {
			roots.push(np.getCoefficient(0).negate().divide(np.getCoefficient(1)));
			np = Polynomial.of(np.getLeadingCoefficient());
			if (typeof hit === "function") {
				hit({
					getroots: {
						linear: ""
					}
				});
			}
			if (callback != undefined) {
				callback({
					content: content,
					roots: roots,
					newPolynomial: np,
					type: "solveLinearEquation"
				});
			}
			return roots;
		}
		var nthRootInternal = function (n, x) {
			if (x instanceof Expression.ExpressionWithPolynomialRoot) {

				return undefined;

			}

			if (x instanceof Expression.ExpressionPolynomialRoot) {

				return x._nthRoot(n);
			}
			if (x instanceof Expression.Division) {
				var sa1 = nthRootInternal(n, x.a);
				var sb1 = nthRootInternal(n, x.b);
				return sa1 == undefined || sb1 == undefined ? undefined : sa1.divide(sb1);
			}
			if (x instanceof Expression.Exponentiation) {
				var N = Expression.Integer.fromNumber(n);
				if (x.b instanceof Expression.Integer) {
					if (x.b.remainder(N).equals(Expression.ZERO)) {
						return x.a.pow(x.b.divide(N));
					}

				}

				if (x.a instanceof Expression.Integer || x.a === Expression.E) {

					return x.a.pow(x.b.divide(N));
				}
				if (x.b instanceof Expression.Division && x.b.a instanceof Expression.Integer && x.b.a.remainder(N).equals(Expression.ZERO)) {

					return x.a.pow(x.b.divide(N));
				}
			}
			if (x instanceof Expression.Multiplication) {
				var sa = nthRootInternal(n, x.a);
				var sb = nthRootInternal(n, x.b);
				return sa == undefined || sb == undefined ? undefined : sa.multiply(sb);
			}
			if (x instanceof Expression.Complex || Expression.isConstant(x) && Expression.has(x, Expression.Complex)) {

				var c = Expression.getComplexNumberParts(x);
				var real = c.real;
				var imaginary = c.imaginary;
				if (n === 2) {
					var m = real.multiply(real).add(imaginary.multiply(imaginary)).squareRoot();
					var a = nthRootInternal(2, real.add(m).divide(Expression.TWO));
					if (a != undefined) {
						var b = imaginary.divide(Expression.TWO.multiply(a));
						var result = a.add(b.multiply(Expression.I));
						return result;
					}
				}
				if (real.equals(Expression.ZERO) && n % 2 === 0) {
					var c = nthRootInternal(Math.floor(n / 2), x);
					if (c != undefined) {
						return nthRootInternal(2, c);
					}
				}
				if (real.equals(Expression.ZERO) && n % 2 === 1) {

					var c = nthRootInternal(n, imaginary);
					if (c != undefined) {
						return c.multiply(n % 4 === 1 ? Expression.I : Expression.I.negate());
					}
				}

				if (x instanceof Expression.Complex && !imaginary.equals(Expression.ZERO)) {

					var rho = real._pow(2).add(imaginary._pow(2)).squareRoot();
					try {
						var phi = Expression.TWO.multiply(imaginary.divide(rho.add(real)).arctan());
						return rho._nthRoot(n).multiply(Expression.I.multiply(phi.divide(Expression.Integer.fromNumber(n))).exp());
					} catch (error) {

						console.debug(error);
					}
				}
			}
			if (x instanceof Expression.Addition) {
				var lastFactor = undefined;
				var e = 0;
				var result = Expression.ONE;
				var rest = Expression.ONE;
				var t = x;
				while (!t.equals(Expression.ONE) && !t.equals(Expression.ONE.negate())) {
					var f = Expression.simpleDivisor(t);
					if (e === 0) {
						lastFactor = f;
						e += 1;
					} else if (f.equals(lastFactor)) {
						e += 1;
						if (e === n) {
							e = 0;
							result = result.multiply(lastFactor);
						}
					} else if (e !== 0) {
						rest = rest.multiply(Expression.pow(lastFactor, e));
						lastFactor = f;
						e = 1;
					}
					t = t.divide(f);
				}
				if (result !== Expression.ONE) {
					if (e !== 0) {
						rest = rest.multiply(Expression.pow(lastFactor, e));
					}
					if (t.equals(Expression.ONE.negate())) {
						rest = rest.multiply(t);
					}
					var rn = nthRootInternal(n, rest);
					if (rn != undefined) {
						return result.multiply(rn);
					}
				}
			}
			if (x instanceof Expression.Exponentiation && x.a instanceof Expression.Symbol) {
				var b = x.b.divide(Expression.Integer.fromNumber(n));
				return b.equals(Expression.ONE) ? x.a : new Expression.Exponentiation(x.a, b);
			}
			if (!Expression.isConstant(x) && x.isNegative() && (n === 2 || n % 2 !== 0)) {
				x = x.negate();
				var c = nthRootInternal(n, x);
				return c == null ? null : Expression.ONE.negate()._nthRoot(n).multiply(c);
			}
			if ((x instanceof Expression.Integer || x instanceof Expression.Complex) && x.isNegative() && n % 2 === 0) {

				var c = x instanceof Expression.Integer ? x._nthRoot(2) : nthRootInternal(2, x);
				return c == null ? null : nthRootInternal(n / 2, c);
			}
			if (Expression.has(x, Expression.Sin) || Expression.has(x, Expression.Cos)) {

				var tmp = nthRootInternal(2, Expression._replaceSinCos(x));
				if (tmp != null) {
					return Expression._replaceBySinCos(tmp).simplifyExpression();
				}
			}

			var y = undefined;
			try {
				y = x._nthRoot(n);
			} catch (error) {

				console.error(error);
			}
			if (y == undefined) {

				var a = x;

				var ac = Expression.getConjugateExpression(a.getNumerator());
				if ((n === 3 || n === 2) && ac instanceof Expression.Integer) {

					if (n === 2 && Expression._isPositive(x.negate())) {
						return Expression.I.multiply(nthRootInternal(2, x.negate()));
					}

					var a = x;
					var tmp = new Expression.Symbol('x')._pow(n).subtract(a).getNumerator();
					var polynomial = Polynomial.toPolynomial(Expression.getConjugateExpression(tmp), new Expression.Symbol('x'));
					var tmp2 = polynomial.getZeros();
					for (var iteratorzero = tmp2[globalThis.Symbol.iterator](), zero = iteratorzero.next().value; zero != null; zero = iteratorzero.next().value) {
						if (zero._pow(n).equals(x)) {
							return zero;
						}
					}

					return null;
				}
			}
			return y;
		};
		var nthRoot = function (n, x, np) {
			if (n === 1) {
				return x;
			}
			var y = nthRootInternal(n, x);
			if (y == undefined) {
				if (!(x instanceof Expression.Integer)) {
					if (typeof hit === "function") {
						hit({
							nthRoot: (n === 2 ? "squareRoot" : n + "-root") + ":" + x.toString() + ":" + np.toString()
						});
					}
				}
			}
			return y;
		};
		var continueWithNewPolynomial = function (roots, np, newPolynomialVariable) {
			var rs = np.getroots(callback != undefined ? function (info) {
				var xxx = Object.assign({}, info, {
					content: content.multiply(info.content),
					roots: roots.concat(info.roots),
					newPolynomialVariable: newPolynomialVariable
				});
				callback(xxx);
			} : undefined);
			for (var i = 0; i < rs.length; i += 1) {
				roots.push(rs[i]);
			}
		};
		if (np.getDegree() >= 2) {
			var g = np.getGCDOfTermDegrees();
			if (g >= 2) {
				var allZeros = g === np.getDegree();
				if (typeof hit === "function") {
					if (g === np.getDegree()) {
						hit({
							getroots: {
								allZeros: ""
							}
						});
					} else {
						hit({
							getroots: g % 2 === 0 ? np.getDegree() === 4 ? {
								biquadratic: ""
							} : {
								even: ""
							} : {
								xyz: np.toString()
							}
						});
					}
				}

				var newData = new Array(Math.floor((np.getDegree() + g) / g));
				var k = 0;
				for (var i = 0; i <= np.getDegree(); i += g) {
					newData[k] = np.getCoefficient(i);
					k += 1;
				}
				var q = Polynomial.from(newData);
				var qRoots = [];
				if (!allZeros) {
					if (callback != undefined) {
						callback({
							content: content,
							roots: roots,
							newPolynomial: q,
							type: "t = x^g",
							g: g,
							newPolynomialVariable: new Expression.Symbol('t')
						});
					}

					continueWithNewPolynomial(qRoots, q, new Expression.Symbol('t'));
				} else {
					qRoots = q.getroots();
				}
				var n = np.getDegree();

				for (var k = 0; k < qRoots.length; k += 1) {
					var qRoot = qRoots[k];
					var s = nthRoot(g, qRoot, np);
					if (s != undefined) {
						var d = null;
						if ((!allZeros || g >= 5 || !np.hasIntegerCoefficients()) && (g <= 24 && (17896830 >> g) % 2 === 1 || g === 48)) {
							d = Polynomial.of(Expression.ONE).shift(g).add(Polynomial.of(qRoot.negate()));

							var c = Expression.E.pow(Expression.I.multiply(Expression.TWO.multiply(Expression.PI)).divide(Expression.Integer.fromNumber(g)));
							var cInI = Expression.ONE;
							for (var i = 0; i < g; i += 1) {
								var root = cInI.multiply(s);
								cInI = cInI.multiply(c);
								roots.push(root);
							}
						} else {
							roots.push(s);
							d = Polynomial.of(s.negate(), Expression.ONE);
							if (g % 2 === 0) {
								roots.push(s.negate());
								d = Polynomial.of(s.multiply(s).negate(), Expression.ZERO, Expression.ONE);
							}
						}
						var quotient = np.divideAndRemainder(d).quotient;
						console.assert(np.subtract(quotient.multiply(d)).map(function (c) {
							return c.simplifyExpression();
						}).getDegree() < 0);
						np = quotient;
					}

				}

				if (!allZeros) {
					if (callback != undefined) {
						callback({
							content: content,
							roots: roots,
							newPolynomial: np,
							type: "x = t^(1/g)",
							g: g
						});
					}
				} else {
					var type = g === 2 ? "applyDifferenceOfSquaresRule" : g === 3 ? "applyDifferenceOfCubesRule" : "applyDifferenceOfNthPowersRule";
					if (callback != undefined) {
						callback({
							content: content,
							roots: roots,
							newPolynomial: np,
							type: type,
							g: g
						});
					}
				}

				var ok = true;
				if (n !== np.getDegree() && ok && np.getDegree() > 0) {
					continueWithNewPolynomial(roots, np);
				}
				return roots;
			}
		}

		if (np.getDegree() === 2) {
			var a = np.getCoefficient(2);
			var b = np.getCoefficient(1);
			var c = np.getCoefficient(0);
			var D = b.multiply(b).subtract(Expression.TWO.multiply(Expression.TWO).multiply(a).multiply(c));
			D = D.simplifyExpression();
			var sD = nthRoot(2, D, np);
			if (typeof hit === "function") {
				hit({
					getroots: {
						quadratic: sD == undefined ? D instanceof Expression.Integer ? D.compareTo(Expression.ZERO) : "?" + D.toString() : "OK"
					}
				});
			}
			if (sD != undefined) {
				if (sD.equals(Expression.ZERO)) {
					var x12 = b.negate().divide(Expression.TWO.multiply(a));
					roots.push(x12);
					roots.push(x12);

				} else {
					var x1 = b.negate().subtract(sD).divide(Expression.TWO.multiply(a));
					var x2 = b.negate().add(sD).divide(Expression.TWO.multiply(a));
					roots.push(x1);
					roots.push(x2);
				}
				np = Polynomial.of(np.getLeadingCoefficient());
				if (callback != undefined) {
					callback({
						content: content,
						roots: roots,
						newPolynomial: np,
						type: "solveQuadraticEquation"
					});
				}
				return roots;
			}
		}

		if (np.getDegree() >= 4 && np.getDegree() % 2 === 0) {
			var middle = Math.floor(np.getDegree() / 2);
			var j = 1;
			while (j < middle + 1 && np.getCoefficient(middle + j).equals(Expression.ZERO) && np.getCoefficient(middle - j).equals(Expression.ZERO)) {
				j += 1;
			}
			if (j < middle + 1 && !np.getCoefficient(middle + j).equals(Expression.ZERO) && !np.getCoefficient(middle - j).equals(Expression.ZERO)) {
				var jj = Expression.Integer.fromNumber(j);
				var mj = np.getCoefficient(middle + j).divide(np.getCoefficient(middle - j));
				var isQuasiPalindromic = true;
				for (var i = 2; i < middle + 1 && isQuasiPalindromic; i += 1) {
					isQuasiPalindromic = isQuasiPalindromic && np.getCoefficient(middle + i).pow(jj).subtract(np.getCoefficient(middle - i).pow(jj).multiply(mj.pow(Expression.Integer.fromNumber(i)))).equals(Expression.ZERO);
				}
				if (isQuasiPalindromic) {

					if (typeof hit === "function") {
						hit({
							getroots: {
								quasiPalindromic: np.getDegree()
							}
						});
					}
				}
				if (isQuasiPalindromic && np.getDegree() <= Math.log2(Number.MAX_SAFE_INTEGER + 1)) {
					var substitute = function (m, np) {

						var choose = function (n, k) {
							return k === 0 ? 1 : Math.floor(n * choose(n - 1, k - 1) / k);
						};
						var p = function (n, i, mpi) {
							return n - 2 * i >= 0 ? p(n - 2 * i, 1, m).scale(Expression.Integer.fromNumber(choose(n, i)).multiply(mpi).negate()).add(p(n, i + 1, mpi.multiply(m))) : Polynomial.of(Expression.ONE).shift(n);
						};
						var f = function (n, i) {
							return i <= n ? p(n - i, 1, m).scale(np.getCoefficient(i)).add(f(n, i + 1)) : Polynomial.ZERO;
						};
						return f(Math.floor(np.getDegree() / 2), 0);
					};
					var m = j === 1 ? mj : nthRoot(j, mj, np);

					var pt = substitute(m, np);

					var ptRoots = pt.getroots();
					for (var i = 0; i < ptRoots.length; i += 1) {
						var ptRoot = ptRoots[i];

						var u = Polynomial.of(Expression.ONE, ptRoot.negate(), m);
						var uRoots = u.getroots();
						for (var j = 0; j < uRoots.length; j += 1) {
							var root = uRoots[j];

							roots.push(root);
						}
						np = np.divideAndRemainder(u.scale(u.getLeadingCoefficient().inverse())).quotient;

					}

					if (callback != undefined) {
						callback({
							content: content,
							roots: roots,
							newPolynomial: np,
							type: "solvePalindromicEquaion"
						});
					}
					return roots;
				}
			}
		}
		if (np.getDegree() >= 2) {

			var n = np.getDegree();
			var hasZeroCoefficient = function (np) {
				for (var i = 0; i <= np.getDegree(); i += 1) {
					if (np.getCoefficient(i).equals(Expression.ZERO)) {
						return true;
					}
				}
				return false;
			};
			if (!hasZeroCoefficient(np)) {
				var g = np.getCoefficient(n - 1).divide(np.getCoefficient(n)).divide(Expression.Integer.fromNumber(n));
				var ok = true;
				for (var k = np.getDegree() - 1; k >= 1 && ok; k -= 1) {
					ok = g.equals(np.getCoefficient(k - 1).divide(np.getCoefficient(k)).multiply(Expression.Integer.fromNumber(n - k + 1)).divide(Expression.Integer.fromNumber(k)));
				}
				if (ok) {
					var root = g.negate();
					for (var k = 0; k < n; k += 1) {
						roots.push(root);
					}
					np = Polynomial.of(np.getLeadingCoefficient());
					if (callback != undefined) {
						callback({
							content: content,
							roots: roots,
							newPolynomial: np,
							type: "(ax+b)**n"
						});
					}

					return roots;
				}
			}
		}
		if (np.getDegree() >= 2) {
			var root = np.doRationalRootTest();
			if (root != null) {

				np = np.divideAndRemainder(Polynomial.of(root.negate(), Expression.ONE)).quotient;
				roots.push(root);
				if (typeof hit === "function") {
					hit({
						getroots: {
							rational: ""
						}
					});
				}
				if (callback != undefined) {
					callback({
						content: content,
						roots: roots,
						newPolynomial: np,
						type: "useTheRationalRootTest"
					});
				}
				if (np.getDegree() > 0) {
					continueWithNewPolynomial(roots, np);
				}
				return roots;
			}
		}

		if (!np.hasIntegerCoefficients() && np.getDegree() === 3) {

			var h = np._getShiftToDepressed();
			if (!h.equals(Expression.ZERO)) {
				var p = np._translateRoots(h);
				if (p.hasIntegerCoefficients()) {

					var zeros = p.getroots();
					if (zeros.length === 0) {

						zeros = p.getZeros();
						debugger;
					}
					if (zeros.length === np.getDegree()) {

						for (var iteratorzero = zeros[globalThis.Symbol.iterator](), zero = iteratorzero.next().value; zero != null; zero = iteratorzero.next().value) {
							roots.push(zero.subtract(h));
						}
						np = Polynomial.of(np.getLeadingCoefficient());
						if (callback != undefined) {
							callback({
								content: content,
								roots: roots,
								newPolynomial: np,
								type: "solveCubicEquation"
							});
						}
						return roots;
					} else {
						debugger;
					}
				}
			}
		}
		if (np.hasIntegerCoefficients()) {

			var n = np.getDegree();
			var a = np.getLeadingCoefficient();
			var b = np.getCoefficient(n - 1);
			if (!b.equals(Expression.ZERO)) {
				var h = b.divide(Expression.Integer.fromNumber(n).multiply(a));
				var depressed = np._translateRoots(h);
				var depressedRoots = [];
				if (callback != undefined) {

					var originalCallback = callback;
					callback = function (info) {

						originalCallback({
							content: content.multiply(depressed.getLeadingCoefficient().divide(np.getLeadingCoefficient()).inverse()),
							roots: roots,
							newPolynomial: depressed,
							type: "eliminationOfTheSubDominantTerm",
							b: b,
							n: n,
							a: a,
							newPolynomialVariable: new Expression.Symbol('t')
						});
						originalCallback(info);
						callback = originalCallback;
					};
				}
				continueWithNewPolynomial(depressedRoots, depressed, new Expression.Symbol('t'));
				if (depressedRoots.length > 0) {
					for (var iteratordepressedRoot = depressedRoots[globalThis.Symbol.iterator](), depressedRoot = iteratordepressedRoot.next().value; depressedRoot != null; depressedRoot = iteratordepressedRoot.next().value) {
						roots.push(depressedRoot.subtract(h));
					}
					if (depressedRoots.length === depressed.getDegree()) {
						np = Polynomial.of(np.getLeadingCoefficient());
					} else {

						console.warn('T0D0:');

					}

				}

				return roots;
			}
		}
		if (np.getDegree() === 3) {

			var a = np.getCoefficient(3);
			var b = np.getCoefficient(2);
			var c = np.getCoefficient(1);
			var d = np.getCoefficient(0);
			var THREE = Expression.Integer.fromNumber(3);
			var h = b.divide(THREE.multiply(a));
			var substitute = function (y) {
				return y.subtract(h);
			};
			var tmp = np._translateRoots(h);
			var depressed = tmp.scale(tmp.getLeadingCoefficient().inverse());
			var p = depressed.getCoefficient(1);
			var q = depressed.getCoefficient(0);
			var discriminant = p.divide(THREE)._pow(3).add(q.divide(Expression.TWO)._pow(2));
			if (typeof hit === "function") {
				hit({
					getroots: {
						cubic: (discriminant instanceof Expression.Integer ? discriminant.compareTo(Expression.ZERO) : "?") + "-" + (p instanceof Expression.Integer ? p.compareTo(Expression.ZERO) : "?")
					}
				});
			}
			var minusOneOverTwo = Expression.ONE.negate().divide(Expression.TWO);
			var iSqrtOfThreeOverTwo = Expression.I.multiply(THREE.squareRoot()).divide(Expression.TWO);
			var cbrtOfMinusOne1 = minusOneOverTwo.subtract(iSqrtOfThreeOverTwo);
			var cbrtOfMinusOne2 = minusOneOverTwo.add(iSqrtOfThreeOverTwo);
			if (q.equals(Expression.ZERO) && p.equals(Expression.ZERO)) {

				var root = substitute(Expression.ZERO);
				roots.push(root);
				roots.push(root);
				roots.push(root);
				np = Polynomial.of(np.getLeadingCoefficient());
				if (callback != undefined) {
					callback({
						content: content,
						roots: roots,
						newPolynomial: np,
						type: "solveCubicEquation"
					});
				}
				return roots;
			} else if (q.equals(Expression.ZERO)) {
				roots.push(substitute(Expression.ZERO));
				var tmp = nthRoot(2, p.negate(), np);
				roots.push(substitute(tmp));
				roots.push(substitute(tmp.negate()));
				np = Polynomial.of(np.getLeadingCoefficient());
				if (callback != undefined) {
					callback({
						content: content,
						roots: roots,
						newPolynomial: np,
						type: "solveCubicEquation"
					});
				}
				return roots;
			} else if (p.equals(Expression.ZERO)) {

				var tmp = nthRoot(3, q.negate(), np);
				roots.push(substitute(tmp));
				roots.push(substitute(tmp.multiply(cbrtOfMinusOne1)));
				roots.push(substitute(tmp.multiply(cbrtOfMinusOne2)));
				np = Polynomial.of(np.getLeadingCoefficient());
				if (callback != undefined) {
					callback({
						content: content,
						roots: roots,
						newPolynomial: np,
						type: "solveCubicEquation"
					});
				}
				return roots;
			} else if (discriminant.equals(Expression.ZERO)) {

				var t23 = THREE.multiply(q).divide(Expression.TWO.multiply(p)).negate();
				var root23 = substitute(t23);
				roots.push(root23);
				roots.push(root23);
				var t1 = t23.multiply(Expression.TWO).negate();
				var root1 = substitute(t1);
				roots.push(root1);
				np = Polynomial.of(np.getLeadingCoefficient());
				if (callback != undefined) {
					callback({
						content: content,
						roots: roots,
						newPolynomial: np,
						type: "solveCubicEquation"
					});
				}
				return roots;
			} else {

				var tmp = nthRoot(2, discriminant, np);
				if (tmp != undefined) {
					var C = nthRoot(3, q.negate().divide(Expression.TWO).add(tmp), np);
					if (C != undefined && !(C instanceof Expression.ExpressionPolynomialRoot) && !(C instanceof Expression.ExpressionWithPolynomialRoot)) {

						var rootFromC = function (C) {
							return substitute(C.subtract(p.divide(THREE.multiply(C))));
						};
						roots.push(rootFromC(C));
						roots.push(rootFromC(C.multiply(cbrtOfMinusOne1)));
						roots.push(rootFromC(C.multiply(cbrtOfMinusOne2)));
						np = Polynomial.of(np.getLeadingCoefficient());
						if (callback != undefined) {
							callback({
								content: content,
								roots: roots,
								newPolynomial: np,
								type: "solveCubicEquation"
							});
						}
						return roots;
					}
				}
			}
		}

		if (np.getDegree() > 2) {

			var tmp = np.squareFreeFactors();
			var a0 = tmp.a0;
			var a1 = tmp.a1;
			if (a0.getDegree() > 0) {

				var newA0 = a0;
				var a0r = a0.getroots(function (x) {
					newA0 = x.newPolynomial;
				});
				var previousRoot = null;
				for (var i = 0; i < a0r.length; i += 1) {
					var root = a0r[i];
					roots.push(root);
					if (previousRoot == null || !previousRoot.equals(root)) {
						roots.push(root);
					}
					previousRoot = root;
				}

				var newA1 = a1;
				var a1Roots = a1.getroots(function (x) {
					newA1 = x.newPolynomial;
				});
				for (var i = 0; i < a1Roots.length; i += 1) {
					roots.push(a1Roots[i]);
				}
				if (newA0 != null) {

					np = newA1.multiply(newA0).multiply(Polynomial.polynomialGCD(newA0, np));
				}
				if (a0r.length > 0 || a1Roots.length > 0) {
					if (typeof hit === "function") {
						hit({
							getroots: {
								squareFreeFactorization: np.toString()
							}
						});
					}
					if (callback != undefined) {

						callback({
							content: content,
							roots: roots,
							newPolynomial: np,
							type: "squareFreeFactorization"
						});
					}

					return roots;
				}
			}
		}

		if (np.getDegree() >= 4) {
			if (true) {

				var g = np.factorize();
				if (g != undefined) {
					var h = np.divideAndRemainder(g).quotient;
					var gNew = null;
					var gRoots = g.getroots(function (x) {
						gNew = x.newPolynomial.scale(x.content);
					});
					for (var i = 0; i < gRoots.length; i += 1) {
						roots.push(gRoots[i]);

					}

					if (gRoots.length > 0) {
						np = np.divideAndRemainder(g.divideAndRemainder(gNew).quotient).quotient;
					}
					var hNew = null;
					var hRoots = h.getroots(function (x) {
						hNew = x.newPolynomial.scale(x.content);
					});
					for (var i = 0; i < hRoots.length; i += 1) {
						roots.push(hRoots[i]);

					}

					if (hRoots.length > 0) {
						np = np.divideAndRemainder(h.divideAndRemainder(hNew).quotient).quotient;
					}
					if (hRoots.length > 0 || gRoots.length > 0) {
						if (typeof hit === "function") {
							hit({
								getroots: {
									methodOfKronecker: np.toString()
								}
							});
						}
						if (callback != undefined) {

							callback({
								content: content,
								roots: roots,
								newPolynomial: np,
								type: "methodOfKronecker"
							});
						}
					}

					return roots;
				}
			}
		}

		if (np.getDegree() >= 3) {
			for (var i = 0; i <= np.getDegree(); i += 1) {
				if (Expression.has(np.getCoefficient(i), Expression.SquareRoot)) {
					var c = null;
					Expression._map(function (x) {
						if (c == null) {

							if (x instanceof Expression.SquareRoot && x.a instanceof Expression.Integer) {
								c = x;
							}
						}
						return x;
					}, np.getCoefficient(i));
					if (c != null) {
						var tmp = new Expression.Symbol('_t');

						var p = np.map(function (coefficient) {
							var s1 = Expression.ZERO;

							for (var iterators = coefficient.summands()[globalThis.Symbol.iterator](), s = iterators.next().value; s != null; s = iterators.next().value) {
								var t = Expression.ONE;
								for (var iteratorx = s.factors()[globalThis.Symbol.iterator](), x = iteratorx.next().value; x != null; x = iteratorx.next().value) {
									if (x.equals(c)) {
										t = t.multiply(tmp);
									} else if (x instanceof Expression.Integer) {
										var exp = 0;
										while (x.gcd(c.a).equals(c.a)) {
											exp += 2;
											x = x.divide(c.a);
										}
										t = t.multiply(x.multiply(tmp._pow(exp)));

									} else {
										t = t.multiply(x);
									}
								}
								s1 = s1.add(t);
							}
							return s1;
						});
						var a = "_x" + ++counter;
						var newp = Polynomial.toPolynomial(p.calcAt(new Expression.Symbol(a)), tmp);

						var g = newp.getGCDOfTermDegrees();
						if (g >= 2) {
							var newData = new Array(Math.floor((newp.getDegree() + g) / g));
							var k = 0;
							for (var i1 = 0; i1 <= newp.getDegree(); i1 += g) {
								newData[k] = newp.getCoefficient(i1).multiply(c._pow(i1 - k));
								k += 1;
							}
							newp = Polynomial.from(newData);
						}

						if (newp.getDegree() > 1) {
							var roots1 = [];
							var rr = null;

							while ((rr = newp.doRationalRootTest()) != null) {
								roots1.push(rr);
								newp = newp.divideAndRemainder(Polynomial.of(rr.negate(), Expression.ONE), "throw").quotient;
							}

							var rootsCount = roots.length;
							for (var j = 0; j < roots1.length; j += 1) {

								var roots2 = Polynomial.toPolynomial(roots1[j].subtract(c).getNumerator(), new Expression.Symbol(a)).getroots();
								for (var k = 0; k < roots2.length; k += 1) {
									var root = roots2[k];
									roots.push(root);
									np = np.divideAndRemainder(Polynomial.of(root.negate(), Expression.ONE)).quotient;
								}
							}

							if (roots.length > rootsCount) {
								if (typeof hit === "function") {
									hit({
										getroots: {
											methodOfIntroducingANewVariable: ""
										}
									});
								}
								if (callback != undefined) {

									callback({
										content: content,
										roots: roots,
										newPolynomial: np,
										type: "methodOfIntroducingANewVariable",
										t: c
									});
								}

								continueWithNewPolynomial(roots, np);
								return roots;
							}
						}
					}
				}
			}
		}

		if (np.getDegree() === 4) {

			var a_4 = np.getCoefficient(4);
			var p = np.scale(a_4.inverse());
			var b = p.getCoefficient(3);
			var y = new Expression.Symbol('$y');
			var substitute = function (y) {
				return y.subtract(b.divide(Expression.Integer.fromNumber(4)));
			};
			var e = p.calcAt(substitute(y));
			var sp = Polynomial.toPolynomial(e.getNumerator(), y);
			var p = sp.getCoefficient(2);
			var q = sp.getCoefficient(1);
			var r = sp.getCoefficient(0);

			var pU = Polynomial.of(q._pow(2).negate(), p._pow(2).subtract(Expression.TWO.add(Expression.TWO).multiply(r)), Expression.TWO.multiply(p), Expression.ONE);

			var pURoots = pU.getCoefficient(1).equals(Expression.ZERO) && pU.getCoefficient(2).equals(Expression.ZERO) || pU.getCoefficient(0).equals(Expression.ZERO) ? pU.getroots() : [pU.doRationalRootTest() || Expression.ZERO];
			for (var iteratorU = pURoots[globalThis.Symbol.iterator](), U = iteratorU.next().value; U != null; U = iteratorU.next().value) {
				var u = nthRootInternal(2, U);
				if (!U.equals(Expression.ZERO) && u != null) {
					var s = u.negate();
					var t = p.add(u._pow(2)).add(q.divide(u)).divide(Expression.TWO);
					var v = p.add(u._pow(2)).subtract(q.divide(u)).divide(Expression.TWO);

					var p1 = Polynomial.of(t, s, Expression.ONE);
					var p2 = Polynomial.of(v, u, Expression.ONE);
					var p12 = Polynomial.of(Expression.ONE);
					for (var iteratorroot = p1.getroots()[globalThis.Symbol.iterator](), root = iteratorroot.next().value; root != null; root = iteratorroot.next().value) {
						var s = substitute(root);
						roots.push(s);
						p12 = p12.multiply(Polynomial.of(s.negate(), Expression.ONE));
					}
					for (var iteratorroot = p2.getroots()[globalThis.Symbol.iterator](), root = iteratorroot.next().value; root != null; root = iteratorroot.next().value) {
						var s = substitute(root);
						roots.push(s);
						p12 = p12.multiply(Polynomial.of(s.negate(), Expression.ONE));
					}
					if (p12.getDegree() > 0) {
						np = np.divideAndRemainder(p12).quotient;
						if (callback != undefined) {
							callback({
								content: content,
								roots: roots,
								newPolynomial: np,
								type: "solveQuarticEcuation"
							});
						}

						continueWithNewPolynomial(roots, np);
						return roots;
					}
				}
			}

		}

		if (!np.hasIntegerCoefficients() && np.getDegree() > 2) {

			var variable = new Expression.Symbol('$$');
			var e = np.calcAt(variable);
			var c = Expression.getConjugate(e);
			if (c != null) {
				var result = [];
				var newP = null;
				var ceRoots = Polynomial.toPolynomial(c.multiply(e), variable).getSquareFreePolynomial().getroots(function (x) {
					newP = x.newPolynomial;
				});
				for (var i = 0; i < ceRoots.length; i += 1) {
					var root = ceRoots[i];
					if (np.calcAt(root).equals(Expression.ZERO)) {
						roots.push(root);

						np = np.divideAndRemainder(Polynomial.of(root.negate(), Expression.ONE)).quotient;
					} else {

						console.debug(root);
					}
				}
				if (ceRoots.length > 0) {
					if (callback != undefined) {

						callback({
							content: content,
							roots: roots,
							newPolynomial: np,
							type: "multiplyByConjugates",
							t: c
						});
					}

					continueWithNewPolynomial(roots, np);
				}
				return roots;
			}
		}
		if (np.getDegree() >= 0) {

			if (typeof hit === "function") {
				hit({
					getroots: {
						other: np.getDegree()
					}
				});
			}
		}

		if (np.hasIntegerCoefficients() && np.getDegree() >= 4 && np.getDegree() % 2 === 0 && np.getDegree() <= 12) {

			var u = new Expression.Symbol('u');
			var v = new Expression.Symbol('v');
			var p1 = np.calcAt(u.add(v));
			var p2 = np.calcAt(u.subtract(v));
			var res = Polynomial.resultant(Polynomial.toPolynomial(p1, u), Polynomial.toPolynomial(p2, u));
			res = Polynomial.toPolynomial(res, v);
			var f = function (res) {
				var a = [];
				var x = res.factorize();
				while (x != null && res.getDegree() > 1) {
					if (x.getDegree() <= 2) {

						a = a.concat(x.getroots());
					}
					res = res.divideAndRemainder(x).quotient;
					x = res.factorize();
				}
				return a;
			};

			var vs = Expression.unique(f(res.primitivePart()));
			for (var i = 0; i < vs.length; i++) {
				var v = vs[i];
				var g = Polynomial.polynomialGCD(np._translateRoots(v), np._translateRoots(v.negate()));
				if (g.getDegree() <= 3) {

					var us = g.getroots();
					if (us.length > 0) {
						var pp = Polynomial.of(Expression.ONE);
						for (var i = 0; i < us.length; i += 1) {
							var u = us[i];
							var root = u.add(v);
							roots.push(root);
							pp = pp.multiply(Polynomial.of(root.negate(), Expression.ONE));
						}
						var tmp = np.divideAndRemainder(pp);
						if (!tmp.remainder.equals(Polynomial.ZERO)) {
							throw new TypeError();
						}
						np = tmp.quotient;

						continueWithNewPolynomial(roots, np);
						return roots;
					}
				}
			}
		}
		return roots;
	};
	Polynomial.prototype.derive = function () {
		var newData = new PolynomialData(this.a.size);
		for (var i = 0; i < this.a.size; i += 1) {
			var n = this.a.degree(i);
			var c = this.a.coefficient(i);
			if (n >= 1) {
				var nc = Expression.Integer.fromNumber(n).multiply(c);
				if (!nc.equals(Expression.ZERO)) {
					newData.add(n - 1, nc);
				}
			}
		}
		return new Polynomial(newData);
	};
	Polynomial.prototype.getSquareFreePolynomial = function () {

		return this.divideAndRemainder(this.squareFreeFactors().a0).quotient;
	};
	Polynomial.prototype.isSquareFreePolynomial = function () {
		return this.squareFreeFactors().a0.equals(Polynomial.of(Expression.ONE));
	};
	Polynomial.prototype.getSquareFreeFactorization = function () {
		var polynomial = this;
		var result = [];
		var ONE = Polynomial.of(Expression.ONE);
		var m = 1;
		do {
			var tmp = polynomial.squareFreeFactors();
			if (!tmp.a1.equals(ONE)) {

				result.push({
					factor: tmp.a1,
					multiplicity: m
				});
			}
			if (tmp.a0.getDegree() !== 0) {
				m += 1;
				polynomial = tmp.a0;
			} else {
				polynomial = null;
			}
		} while (polynomial != null);
		return result;
	};

	Polynomial.prototype.squareFreeFactors = function () {

		var p = this;
		var zero = 0;
		while (p.getCoefficient(zero).equals(Expression.ZERO)) {
			zero += 1;
		}
		p = p.divideAndRemainder(Polynomial.of(Expression.ONE).shift(zero), "throw").quotient;
		if (p.getDegree() !== 0) {
			var f = p;
			var d = f.derive();
			var a0 = Polynomial.polynomialGCD(f, d);
			if (a0.getDegree() !== 0) {
				if (f._hasIntegerLikeCoefficients()) {

					a0 = a0.scale(a0.getContent().inverse());
				} else {

					if (Expression.isConstant(a0.getLeadingCoefficient())) {

						a0 = a0.scale(a0.getLeadingCoefficient().inverse());
					}
				}

				var b1 = f.divideAndRemainder(a0, f._hasIntegerLikeCoefficients() ? "throw" : undefined).quotient;
				var g1 = Polynomial.polynomialGCD(b1, a0);
				var a1 = b1.divideAndRemainder(g1, b1._hasIntegerLikeCoefficients() ? "throw" : undefined).quotient;
				return {
					a1: a1.shift(zero === 1 ? 1 : 0),
					a0: a0.shift(zero > 1 ? zero - 1 : 0)
				};
			}
		}
		return {
			a1: p.shift(zero === 1 ? 1 : 0),
			a0: Polynomial.of(Expression.ONE).shift(zero > 1 ? zero - 1 : 0)
		};
	};
	Polynomial.testables = {
		supportsLargeBigintCache: function (value) {
			supportsLargeBigintCache = value;
		},
		multiplyByKroneckerSubstitution: multiplyByKroneckerSubstitution
	};
	self.Polynomial = Polynomial;

	Polynomial.prototype._findGoodSubstitution = function () {
		var f = function (polynomial) {
			var g = polynomial.getCoefficient(0).abs();
			for (var i = 0; i < polynomial.getDegree(); i += 1) {
				g = g.gcd(polynomial.getCoefficient(i).abs());
			}
			g = g.abs();
			var result = Expression.ONE;
			while (!g.equals(Expression.ONE)) {
				var p = g.primeFactor();
				if (!polynomial.getLeadingCoefficient().remainder(p).equals(Expression.ZERO)) {
					var ok = true;
					for (var i = 0; i < polynomial.getDegree() && ok; i += 1) {
						var x = p._pow(polynomial.getDegree() - i);
						ok = polynomial.getCoefficient(i).gcd(x).abs().equals(x);
					}
					if (ok) {
						result = result.multiply(p);
						polynomial = polynomial._scaleRoots(p.inverse()).primitivePart();
					}
				}
				g = g.truncatingDivide(p);
			}
			return result;
		};
		var n = f(this);
		return n.divide(f(this._scaleRoots(n.inverse())._exponentiateRoots(-1)));
	};
	Polynomial.prototype._tryGoodSubstitution = function () {
		return this._scaleRoots(this._findGoodSubstitution());
	};
	Polynomial.prototype._getShiftToDepressed = function () {

		var n = this.getDegree();
		var a = this.getLeadingCoefficient();
		var b = this.getCoefficient(n - 1);
		var h = b.divide(Expression.Integer.fromNumber(n).multiply(a));

		return h;
	};
	Polynomial.prototype._factorizeOverTheIntegers = function () {
		return factorizeOverTheIntegers(this);
	};
	Polynomial.prototype._factorizeMultivariateIntegerPolynomial = function () {
		var varY = Polynomial._getY(this, this);
		var start = Date.now();
		var toTwoVariatePolynomial = function (polynomial, v2) {
			return polynomial.map(function (c) {
				return new Expression.Polynomial(Polynomial.toPolynomial(c, new Expression.Symbol(v2)));
			});
		};
		var f = factorizeOverTheIntegers._factorizeMultivariateIntegerPolynomial(toTwoVariatePolynomial(this, varY.symbol));
		var end = Date.now();
		if (end - start > 4) {
			console.log('_factorizeMultivariateIntegerPolynomial', end - start, this.toString());
		}
		if (f == null) {
			return null;
		}
		f = f.map(function (c) {
			return c.polynomial.calcAt(varY);
		});
		if (f.getLeadingCoefficient().isNegative()) {

			f = f.negate();
		}
		return f;
	};
	Polynomial.prototype.factorize = function () {

		if (this.getDegree() !== 1 && this.getCoefficient(0).equals(Expression.ZERO)) {

			return Polynomial.of(Expression.ZERO, Expression.ONE);
		}
		var content = this.getContent();
		if (!content.equals(Expression.ONE) && !content.equals(Expression.ONE.negate())) {
			throw new RangeError();
		}
		if (this.getDegree() === 1) {
			return null;
		}
		if (this.getDegree() === 2) {
			var discriminant = function (p) {
				console.assert(p.getDegree() === 2);
				var a = p.getCoefficient(2);
				var b = p.getCoefficient(1);
				var c = p.getCoefficient(0);
				return b.multiply(b).subtract(Expression.Integer.fromNumber(4).multiply(a).multiply(c));
			};
			var d = discriminant(this);

			if (d instanceof Expression.Integer && !d._isPerfectSquare()) {
				return null;
			}
		}
		var tmp = this.squareFreeFactors();
		if (tmp.a0.getDegree() > 0) {

			if (tmp.a1.getDegree() > 0) {
				return tmp.a1;
			}
			return tmp.a0;
		}
		if (this.getDegree() < 2) {
			return null;
		}

		if (this.hasIntegerCoefficients() && false) {
			var k = this._findGoodSubstitution();
			if (!k.equals(Expression.ONE)) {
				var newp = this._scaleRoots(k.inverse());
				newp = newp.scale(newp.getContent().inverse());
				console.log('_findGoodSubstitution', newp._log2hypot() / this._log2hypot());
				var f = newp.factorize();
				if (f != undefined) {
					return f._scaleRoots(k);
				}
				return null;
			}
		}

		var n = this.getDegree();
		var b = this.getCoefficient(n - 1);
		if (!b.equals(Expression.ZERO) && !this.hasIntegerCoefficients()) {

			var a = this.getLeadingCoefficient();
			var shift = b.divide(Expression.Integer.fromNumber(n).multiply(a));
			var depressed = this._translateRoots(shift);
			if (depressed.hasIntegerCoefficients()) {
				depressed = depressed.primitivePart();
				var factor = depressed.factorize();
				if (factor != null) {
					return factor._translateRoots(shift.negate()).primitivePart();
				}
				return null;
			} else {
				console.warn("???");
			}
		}

		if (this.isEven()) {
			if (this.hasIntegerCoefficients() && (!this.getCoefficient(0).abs()._isPerfectSquare() || !this.getCoefficient(this.getDegree()).abs()._isPerfectSquare())) {
				var f = this._exponentiateRoots(2).factorize();
				if (f != undefined) {
					return f._exponentiateRoots(1 / 2);
				}
				return null;
			}

		}

		var g = this.getGCDOfTermDegrees();
		if (g > 2) {
			var f = this._exponentiateRoots(g).factorize();
			if (f != undefined) {
				return f._exponentiateRoots(1 / g);
			}

		}

		if (!this.hasIntegerCoefficients() || this.getDegree() < 4 && this.getLeadingCoefficient().abs().bitLength() + this.getCoefficient(0).abs().bitLength() < 9) {

			var root = this.doRationalRootTest();
			if (root != null) {
				return Polynomial.of(root.getNumerator(), root.getDenominator().negate());
			}
			if (this.getDegree() < 4) {

				return null;
			}
		}

		var np = this;

		if (!np.hasIntegerCoefficients()) {
			if (np._hasIntegerLikeCoefficients() && Polynomial._getY(np, np) != null) {

				return np._factorizeMultivariateIntegerPolynomial();
			}

			return null;
		}
		return np._factorizeOverTheIntegers().next().value;

	};

	Polynomial.prototype.primitivePart = function () {

		return this.scale(this.getContent().inverse());
	};

	function extgcdByModularAlgorithm(A, B) {

		var U = null;

		var p = Expression.Integer.fromNumber(Math.floor(1 * Math.sqrt((Number.MAX_SAFE_INTEGER + 1) / (1 + Math.min(A.getDegree(), B.getDegree())))));
		var P = null;
		var c = 0;
		var c0 = 1;
		var crt = null;
		var buffer = [];
		var lastU = null;

		function fastCRT(array) {
			if (array.length === 1) {
				return array[0];
			}
			var m = array.length >> 1;
			var a = fastCRT(array.slice(0, m));
			var b = fastCRT(array.slice(m));
			return {
				polynomial: ChineseRemainderTheoremForPolynomialCoefficients(a.polynomial, b.polynomial, a.modulus, b.modulus),
				modulus: a.modulus.multiply(b.modulus)
			};
		}

		var rp = null;
		while (true) {
			c += 1;
			do {
				p = p.subtract(Expression.ONE);
			} while (!isPrime(p.toNumber()) || A.getLeadingCoefficient().remainder(p).equals(Expression.ZERO) || B.getLeadingCoefficient().remainder(p).equals(Expression.ZERO));
			var tmp = factorizeOverTheIntegers._extgcdOfPolynomialsOverFiniteField0(B, A, p.toNumber());
			tmp = {
				U: tmp.V,
				V: tmp.U,
				gcd: tmp.gcd
			};

			if (tmp.gcd.getDegree() !== 0 && c === 1) {

				console.warn('gcd != 1?');
				return A.modularInverse(B);
			}

			if (P != null && tmp.U.getDegree() > U.getDegree()) {
				P = null;
			}
			if (P === null) {
				U = tmp.U;
				buffer.length = 0;
				buffer.push({
					polynomial: tmp.U,
					modulus: p
				});

				P = p;

			} else {
				if (tmp.U.getDegree() === U.getDegree()) {

					U = tmp.U;

					buffer.push({
						polynomial: tmp.U,
						modulus: p
					});

					P = P.multiply(p);
				} else {
					console.log(tmp.U.getDegree());
				}
			}

			if (c >= c0) {
				c0 = Math.ceil(c0 * Math.sqrt(2));
				if (true) {

					var tmp = fastCRT(buffer);
					buffer.length = 0;
					if (lastU == null) {
						lastU = tmp;
					} else {
						lastU = {
							polynomial: ChineseRemainderTheoremForPolynomialCoefficients(lastU.polynomial, tmp.polynomial, lastU.modulus, tmp.modulus),
							modulus: P
						};
					}
					U = lastU.polynomial;

				}

				var BOUND = Expression.ONE.leftShift(Math.floor((P.bitLength() - 1 - 1) / 2));

				var r = recoverRational(U.getLeadingCoefficient().modulo(P), P, BOUND, BOUND);

				console.log(c);
				rp = r;
				if (r != null && rp != null && rp.equals(r)) {
					console.time('test');
					try {

						var scale = r.getDenominator();
						for (var i = U.getDegree(); i >= 0 && scale != null; i -= 1) {
							var c = U.getCoefficient(i).multiply(scale).modulo(P);
							var r = recoverRational(c, P, BOUND, BOUND);
							if (r == null) {
								scale = null;
							} else {
								if (!r.getDenominator().equals(Expression.ONE)) {
									scale = scale.multiply(r.getDenominator()).modulo(P);
								}
								if (i === U.getDegree()) {
									U = U.scale(scale).roundMod(P);
									scale = Expression.ONE;
								}
							}
						}
						var U1 = scale == null ? null : U.scale(scale).roundMod(P);

						if (U1 != null && A.multiply(U1).divideAndRemainder(B).remainder.getDegree() === 0) {

							return U1;
						} else {
							console.log('fail');
						}
					} finally {
						console.timeEnd('test');
					}
				}
				rp = r;
			}
		}
		console.log(tmp.U + '');
	}

	Polynomial._extgcdByModularAlgorithm = extgcdByModularAlgorithm;

	Polynomial.prototype.modularInverse = function (mod) {
		if (this.getDegree() < mod.getDegree() && mod.getDegree() <= 3) {

			var n = mod.getDegree();
			var e = this;
			var conjugate = Polynomial.of(n % 2 === 1 ? Expression.ONE : Expression.ONE.negate());
			while (e.getDegree() > 0) {
				var pseudoDivision = function (A, B) {
					var R = A;
					var Q = Polynomial.ZERO;
					while (R.getDegree() >= B.getDegree()) {
						var lc = R.getLeadingCoefficient();
						Q = Q.scale(B.getLeadingCoefficient());
						R = R.scale(B.getLeadingCoefficient());
						var q = Polynomial.of(lc).shift(R.getDegree() - B.getDegree());
						Q = Q.add(q);
						R = R.add(B.multiply(q.negate()));
					}
					return {
						Q: Q,
						R: R
					};
				};
				var tmp = pseudoDivision(mod, e);
				e = tmp.R;
				conjugate = conjugate.multiply(tmp.Q);
			}
			if (e.getDegree() === 0) {
				conjugate = conjugate.divideAndRemainder(mod).remainder;
				return conjugate;
			}
		}

		var m = mod;
		var g = Math.gcd(this.getGCDOfTermDegrees(), m.getGCDOfTermDegrees());
		if (g > 1) {
			return this._exponentiateRoots(g).modularInverse(m._exponentiateRoots(g)).primitivePart()._exponentiateRoots(1 / g);
		}
		if (this.hasIntegerCoefficients() && m.hasIntegerCoefficients()) {

			if (m.getDegree() >= 16) {

				return extgcdByModularAlgorithm(this, m);
			}
		}
		return this._modularInverseSimple(mod);
	};
	Polynomial.prototype._modularInverseSimple = function (m) {
		var start1 = Date.now();

		var a = this;
		var oldR = m;
		var r = a.getDegree() >= m.getDegree() ? Polynomial.pseudoRemainder(a, m).primitivePart() : a;

		var oldT = Polynomial.of(Expression.ZERO);
		var t = Polynomial.of(Expression.ONE);
		var type = a._hasIntegerLikeCoefficients() && m._hasIntegerLikeCoefficients() || true ? "primitive" : "subresultant";
		for (var iteratortmp = Polynomial._pseudoRemainderSequence(oldR, r, type)[globalThis.Symbol.iterator](), tmp = iteratortmp.next().value; tmp != null; tmp = iteratortmp.next().value) {
			var scale = r.getLeadingCoefficient()._pow(oldR.getDegree() - r.getDegree() + 1);
			var quotient = tmp.q;
			var α = tmp.α;
			var newT = oldT.scale(scale).subtract(quotient.multiply(t));
			if (type === "primitive") {
				if (false) {
					newT = newT.scale(α.inverse());
				} else {
					var g = newT.getContent().gcd(α);
					newT = newT.divideAndRemainder(Polynomial.of(g), "throw").quotient;
					t = t.scale(α.divide(g));
				}
			} else {
				newT = newT.divideAndRemainder(Polynomial.of(α), "throw").quotient;
			}
			var $newoldT = t;
			var $newt = newT;
			oldT = $newoldT;
			t = $newt;
			var newR = tmp.R;
			var $newoldR = r;
			var $newr = newR;
			oldR = $newoldR;
			r = $newr;
		}
		var gcd = oldR;
		if (gcd.getDegree() !== 0) {
			throw new TypeError();
		}

		oldT = oldT.primitivePart().scale(m.getLeadingCoefficient()._pow(Math.max(oldT.getDegree() + a.getDegree() - m.getDegree() + 1, 0)));
		var end1 = Date.now();
		var r = oldT.multiply(a).divideAndRemainder(m, "throw").remainder;
		if (r.getDegree() !== 0) {
			throw new TypeError();
		}

		return oldT;
	};

	var factorizeOverNumberField = function (u, fieldMinimalPolynomial) {

		var e = new Expression.Symbol('$$$e');
		var tmp = new Expression.Symbol('$$$');

		var N = null;
		var k = -1;
		do {

			k += 1;
			var p = u.map(function (c) {
				return c.calcAt(e);
			})._translateRoots(e.multiply(Expression.Integer.fromNumber(k)));
			N = Polynomial.toPolynomial(Polynomial.resultant(Polynomial.toPolynomial(p.calcAt(tmp), e), fieldMinimalPolynomial), tmp);
		} while (!N.isSquareFreePolynomial());
		var factors = factorizeOverTheIntegers(N);
		var iterator = {
			next: function () {
				var Ni = factors.next().value;
				if (Ni != undefined) {
					var g = _polynomialGCDModuloPolynomial(Ni._translateRoots(e.multiply(Expression.Integer.fromNumber(-k))).map(function (c) {
						return Polynomial.toPolynomial(c, e);
					}), u, fieldMinimalPolynomial);
					return {
						value: g,
						done: false
					};
				}
				return {
					value: undefined,
					done: true
				};
			}
		};
		iterator[globalThis.Symbol.iterator] = function () {
			return this;
		};
		return iterator;
	};
	Polynomial.prototype._factorizeOverGaussianIntegers = function () {
		var i = factorizeOverNumberField(this.map(function (c) {
			var tmp = Expression.getComplexNumberParts(c);
			return Polynomial.of(tmp.real, tmp.imaginary);
		}), Polynomial.of(Expression.ONE, Expression.ZERO, Expression.ONE));
		var iterator = {
			next: function () {
				var v = i.next().value;
				if (v != undefined) {
					return {
						value: v.map(function (c) {
							return c.polynomial.calcAt(Expression.I);
						}),
						done: false
					};
				}
				return {
					value: undefined,
					done: true
				};
			}
		};
		iterator[globalThis.Symbol.iterator] = function () {
			return this;
		};
		return iterator;
	};
	Polynomial.prototype._factorizeOverNumberField = function (p) {
		return factorizeOverNumberField(this, p);
	};

	function GraeffeMethod(p) {
		var tmp = [[], []];
		for (var i = 0; i <= p.getDegree(); i++) {
			tmp[i % 2].push(p.getCoefficient(i));
		}
		var p_e = Polynomial.from(tmp[0]);
		var p_o = Polynomial.from(tmp[1]);
		var q = p_e.multiply(p_e).subtract(p_o.multiply(p_o).shift(1)).scale(Expression.ONE.negate()._pow(p.getDegree()));
		return q;
	}

	globalThis.GraeffeMethod = GraeffeMethod;
	Polynomial.prototype.trace = function (i) {
		if (typeof i !== 'number') {
			throw new RangeError();
		}
		var polynomial = this;
		if (!this.getLeadingCoefficient().equals(Expression.ONE)) {

			return this.scale(this.getLeadingCoefficient().inverse()).trace(i);
		}

		var p = [];
		p.push(null);
		var j = 0;
		while (j < i) {
			j += 1;
			var t = Expression.ZERO;
			for (var k = 1; k <= j; k += 1) {
				t = t.subtract(polynomial.getCoefficient(polynomial.getDegree() - k).multiply(j === k ? Expression.Integer.fromNumber(j) : p[j - k]));
			}
			p.push(t);
		}
		return p[i];
	};
}

function MatrixClass() {
	function Matrix(data) {
		this.a = data;
	}

	Matrix.Zero = function (rows, cols) {
		var row = new Array(cols);
		for (var j = 0; j < cols; j += 1) {
			row[j] = Expression.ZERO;
		}
		var a = new Array(rows);
		for (var i = 0; i < rows; i += 1) {
			a[i] = row;
		}
		return new Matrix(a);
	};

	Matrix.I = function (n) {
		return Matrix.Zero(n, n).map(function (element, i, j) {
			return (i === j ? Expression.ONE : Expression.ZERO);
		});
	};

	Matrix.prototype.rows = function () {
		return this.a.length;
	};

	Matrix.prototype.cols = function () {
		return this.a.length > 0 ? this.a[0].length : 0;
	};

	Matrix.prototype.e = function (i, j) {
		return this.a[i][j];
	};

	Matrix.prototype.isSquare = function () {
		return this.rows() > 0 && this.rows() === this.cols();
	};

	Matrix.prototype.map = function (callback) {
		var rows = this.rows();
		var cols = this.cols();
		var c = new Array(rows);
		var i = -1;
		while (++i < rows) {
			var x = new Array(cols);
			var j = -1;
			while (++j < cols) {
				var e = callback.call(undefined, this.e(i, j), i, j, this);
				x[j] = e.simplifyExpression();
			}
			c[i] = x;
		}
		return new Matrix(c);
	};

	Matrix.prototype.transpose = function () {
		var that = this;
		return Matrix.Zero(that.cols(), that.rows()).map(function (element, i, j) {
			return that.e(j, i);
		});
	};

	Matrix.prototype.scale = function (k) {
		return this.map(function (element, i, j) {
			return element.multiply(k);
		});
	};

	Matrix.prototype.multiply = function (b) {
		var a = this;
		if (a.cols() !== b.rows()) {
			throw new RangeError("DimensionMismatchException");
		}
		return Matrix.Zero(a.rows(), b.cols()).map(function (element, i, j) {
			var rows = b.rows();
			var k = -1;
			while (++k < rows) {

				var current = a.e(i, k).multiply(b.e(k, j));
				element = k === 0 ? current : element.add(current);
			}
			return element;
		});
	};

	Matrix.prototype.add = function (b) {
		var a = this;
		if (a.rows() !== b.rows() || a.cols() !== b.cols()) {
			throw new RangeError("MatrixDimensionMismatchException");
		}
		return a.map(function (element, i, j) {
			return element.add(b.e(i, j));
		});
	};

	Matrix.prototype.augment = function (b) {
		if (this.rows() !== b.rows()) {

			throw new RangeError("RowCountMismatchException");
		}
		var a = this;
		return Matrix.Zero(a.rows(), a.cols() + b.cols()).map(function (element, i, j) {
			return (j < a.cols() ? a.e(i, j) : b.e(i, j - a.cols()));
		});
	};

	Matrix.prototype.rowReduce = function (targetRow, pivotRow, pivotColumn, currentOrPreviousPivot, currentOrPreviousPivotInv) {
		var rows = this.rows();
		var cols = this.cols();
		var c = new Array(rows);
		var i = -1;
		while (++i < rows) {
			if (targetRow === i) {
				var x = new Array(cols);
				var f = currentOrPreviousPivot == undefined ? this.e(targetRow, pivotColumn).divide(this.e(pivotRow, pivotColumn)) : undefined;
				var j = -1;
				while (++j < cols) {

					var e = undefined;
					if (currentOrPreviousPivot == undefined) {
						e = this.e(targetRow, j).subtract(f.multiply(this.e(pivotRow, j)));
					} else {
						var d = this.e(pivotRow, pivotColumn).multiply(this.e(targetRow, j)).subtract(this.e(targetRow, pivotColumn).multiply(this.e(pivotRow, j)));
						if (currentOrPreviousPivotInv != undefined) {
							e = d.multiply(currentOrPreviousPivotInv);
						} else {
							if (false) {
								e = d.divideExact(currentOrPreviousPivot);
							} else {
								e = d.divide(currentOrPreviousPivot);
							}
						}

					}
					x[j] = e.simplifyExpression();
				}
				c[i] = x;
			} else {
				c[i] = this.a[i];
			}
		}
		return new Matrix(c);
	};

	Matrix.prototype.swapRows = function (pivotRow, targetRow, preserveDeterminant) {
		var m = this;
		return m.map(function (e, i, j) {
			if (i === pivotRow) {
				return m.e(targetRow, j);
			}
			if (i === targetRow) {
				return preserveDeterminant ? m.e(pivotRow, j).negate() : m.e(pivotRow, j);
			}
			return e;
		});
	};

	var notEqualsZero = function (e, condition) {
		if (condition != undefined) {

			return condition.andZero(e).isFalse();
		}
		return !e.equals(Expression.ZERO);
	};

	Matrix.check = function (usage, matrix, from, to, condition) {
		for (var i = from; i < to; i += 1) {
			if (usage !== "solving" || notEqualsZero(matrix.e(i, matrix.cols() - 1), condition)) {
				var endColumnIndex = usage === "solving" ? matrix.cols() - 1 : (usage === "determinant" ? matrix.cols() : (usage === "inverse" ? Math.floor(matrix.cols() / 2) : -1));
				var j = 0;
				while (j < endColumnIndex && matrix.e(i, j).equals(Expression.ZERO)) {
					j += 1;
				}
				if (j === endColumnIndex) {
					return i;
				}
			}
		}
		return -1;
	};

	Matrix.toRowEchelonStep = function (m, pivotRow, pivotColumn, pivotOriginRow, previousPivot, options, condition) {
		var oldMatrix = undefined;
		var coefficient = undefined;
		var targetRow = 0;
		if (pivotOriginRow !== pivotRow) {
			oldMatrix = m;
			m = m.swapRows(pivotRow, pivotOriginRow, options.usage === "determinant");
			if (options.callback != undefined) {
				options.callback({
					previousPivot: undefined,
					newMatrix: m,
					oldMatrix: oldMatrix,
					type: options.usage === "determinant" ? "swap-negate" : "swap",
					targetRow: pivotRow,
					pivotRow: pivotOriginRow,
					pivotColumn: pivotColumn
				});
			}
		}

		if (options.method === Matrix.GaussJordan) {
			if (!m.e(pivotRow, pivotColumn).equals(Expression.ONE)) {
				oldMatrix = m;
				coefficient = Expression.ONE.divide(m.e(pivotRow, pivotColumn));
				m = m.map(function (e, i, j) {
					if (i !== pivotRow) {
						return e;
					}
					return e.multiply(coefficient);
				});
				if (options.callback != undefined) {
					options.callback({
						previousPivot: undefined,
						newMatrix: m,
						oldMatrix: oldMatrix,
						type: "divide",
						targetRow: pivotRow,
						pivotRow: pivotRow,
						pivotColumn: pivotColumn
					});
				}
			}
		}
		if (options.method === Matrix.Gauss || options.method === Matrix.GaussJordan) {
			targetRow = pivotRow;
			while (++targetRow < m.rows()) {
				if (!m.e(targetRow, pivotColumn).equals(Expression.ZERO)) {
					oldMatrix = m;
					m = m.rowReduce(targetRow, pivotRow, pivotColumn);
					if (options.callback != undefined) {
						options.callback({
							previousPivot: undefined,
							newMatrix: m,
							oldMatrix: oldMatrix,
							type: "reduce",
							targetRow: targetRow,
							pivotRow: pivotRow,
							pivotColumn: pivotColumn
						});
					}
					var stoppedAtRow = Matrix.check(options.usage, m, targetRow, targetRow + 1, condition);
					if (stoppedAtRow !== -1) {
						return {
							stoppedAtRow: stoppedAtRow,
							matrix: m
						};
					}
				}
			}
		}
		if (options.method === Matrix.GaussMontante) {

			var inv = Expression.has(previousPivot, Expression.ExpressionPolynomialRoot) ? previousPivot.inverse() : undefined;
			oldMatrix = m;
			targetRow = -1;
			while (++targetRow < m.rows()) {
				if (targetRow !== pivotRow) {
					m = m.rowReduce(targetRow, pivotRow, pivotColumn, previousPivot, inv);
				}
			}
			if (options.callback != undefined) {
				options.callback({
					previousPivot: previousPivot,
					newMatrix: m,
					oldMatrix: oldMatrix,
					type: "pivot",
					targetRow: -1,
					pivotRow: pivotRow,
					pivotColumn: pivotColumn
				});
			}
			var stoppedAtRow = Matrix.check(options.usage, m, 0, m.rows(), condition);
			if (stoppedAtRow !== -1) {
				return {
					stoppedAtRow: stoppedAtRow,
					matrix: m
				};
			}
		}
		return {
			stoppedAtRow: -1,
			matrix: m
		};
	};

	Matrix.toRowEchelonBackSubstitution = function (m, pivotRow, options) {

		if (options.method === Matrix.GaussJordan) {
			while (--pivotRow >= 0) {
				var pivotColumn = 0;
				while (pivotColumn < m.cols() && m.e(pivotRow, pivotColumn).equals(Expression.ZERO)) {
					pivotColumn += 1;
				}
				if (pivotColumn < m.cols()) {
					var targetRow = pivotRow;
					while (--targetRow >= 0) {
						if (!m.e(targetRow, pivotColumn).equals(Expression.ZERO)) {
							var oldMatrix = m;
							m = m.rowReduce(targetRow, pivotRow, pivotColumn);
							if (options.callback != undefined) {
								options.callback({
									previousPivot: undefined,
									newMatrix: m,
									oldMatrix: oldMatrix,
									type: "reduce",
									targetRow: targetRow,
									pivotRow: pivotRow,
									pivotColumn: pivotColumn
								});
							}
						}
					}
				}
			}
		}
		return m;
	};

	var isConditionValid = function (condition, matrix) {
		for (var i = 0; i < matrix.rows(); i++) {
			for (var j = 0; j < matrix.cols(); j++) {
				var e = matrix.e(i, j);
				if (!Polynomial._isIntegerLike(e)) {
					if (Polynomial._isIntegerLike(e.getNumerator())) {
						e = e.getDenominator().inverse();
					}
					if (condition.andZero(e).isFalse() && condition.andNotZero(e).isFalse()) {
						return false;
					}
				}
			}
		}
		return true;
	};

	Matrix.Gauss = "Gauss";
	Matrix.GaussJordan = "Gauss-Jordan";
	Matrix.GaussMontante = "Gauss-Montante";

	function ToRowEchelonOptions(method, usage, callback) {
		if (usage !== "determinant" && usage !== "inverse" && usage !== "solving" && usage !== "LU-decomposition" && usage !== "" && usage !== "row-reduction") {
			throw new RangeError();
		}
		if (method !== Matrix.Gauss && method !== Matrix.GaussJordan && method !== Matrix.GaussMontante) {
			throw new RangeError();
		}
		this.method = method;
		this.usage = usage;
		this.callback = callback;
	}

	Matrix.ToRowEchelonOptions = ToRowEchelonOptions;

	var COLUMN_LOOP = 0;
	var ZERO = 1;
	var NOT_ZERO = 2;
	Matrix.prototype.toRowEchelon = function (method, usage, callback) {
		var options = new Matrix.ToRowEchelonOptions(method, usage, callback);
		return this.toRowEchelonInternal(options, 0, -1, -1, Expression.ONE, COLUMN_LOOP, undefined);
	};
	Matrix.prototype.toRowEchelonXXX = function (method, usage, callback, condition) {
		var options = new Matrix.ToRowEchelonOptions(method, usage, callback);
		return this.toRowEchelonInternal(options, 0, -1, -1, Expression.ONE, COLUMN_LOOP, condition);
	};
	Matrix.prototype.toRowEchelonInternal = function (options, pivotRow, pivotColumn, pivotOriginRow, previousPivot, state, condition) {
		var matrix = this;

		if (condition != undefined && !condition.isTrue()) {
			matrix = matrix.map(function (e, i, j) {

				return condition.updateExpression(e);
			});
			previousPivot = condition.updateExpression(previousPivot);
		}

		var stoppedAtRow = Matrix.check(options.usage, matrix, 0, matrix.rows(), condition);
		if (stoppedAtRow !== -1) {
			return {
				stoppedAtRow: stoppedAtRow,
				matrix: matrix,
				condition: condition
			};
		}
		if (false) {

			if (options.usage === "solving" && pivotColumn === matrix.cols() - 1) {

				var c = condition.andZero(matrix.e(pivotRow, pivotColumn));
				return {
					stoppedAtRow: -1,
					matrix: matrix,
					condition: c
				};
			}

		}
		while (true) {
			switch (state) {
				case COLUMN_LOOP:
					pivotColumn += 1;
					if (pivotColumn >= matrix.cols()) {
						matrix = Matrix.toRowEchelonBackSubstitution(matrix, pivotRow, options);
						return {
							stoppedAtRow: -1,
							matrix: matrix,
							condition: condition
						};
					}
					if (pivotColumn > pivotRow && (options.usage === "determinant" || options.usage === "inverse")) {
						if (pivotColumn >= Math.floor(matrix.cols() / 2) && options.usage === "inverse") {
							matrix = Matrix.toRowEchelonBackSubstitution(matrix, pivotRow, options);
							return {
								stoppedAtRow: -1,
								matrix: matrix,
								condition: condition
							};
						}
						return {
							stoppedAtRow: pivotRow,
							matrix: matrix,
							condition: condition
						};
					}
					pivotOriginRow = pivotRow - 1;
					state = ZERO;
					break;
				case ZERO:

					if (condition == undefined) {
						pivotOriginRow += 1;
						if (pivotOriginRow < matrix.rows()) {
							if (matrix.e(pivotOriginRow, pivotColumn).equals(Expression.ZERO)) {
								state = ZERO;
							} else {
								state = NOT_ZERO;
							}
						} else {
							state = COLUMN_LOOP;
						}
					} else {
						if (pivotOriginRow >= pivotRow) {
							matrix = pivotRow >= matrix.rows() || matrix.e(pivotRow, pivotColumn).equals(Expression.ZERO) ? matrix : matrix.map(function (e, i, j) {

								return condition.updateExpression(e);
							});
							previousPivot = condition.updateExpression(previousPivot);
						}
						var found = false;
						if (pivotOriginRow === pivotRow - 1) {
							var row = pivotRow;
							while (row < matrix.rows() && !((condition.andZero(matrix.e(row, pivotColumn)).isFalse() || options.usage === "LU-decomposition") && !matrix.e(row, pivotColumn).equals(Expression.ZERO))) {
								row += 1;
							}
							if (row < matrix.rows()) {
								pivotOriginRow = row;
								found = true;
							}
						}
						if (!found) {
							pivotOriginRow += 1;
							if (pivotOriginRow < matrix.rows()) {
								var candidate = matrix.e(pivotOriginRow, pivotColumn);
								var c1 = condition.andNotZero(candidate);
								var c2 = condition.andZero(candidate);

								if (!c2.isFalse()) {

									if (!isConditionValid(c2, matrix)) {
										debugger;
										c2 = Condition.FALSE;
										condition = c1;
									}

								}

								if (c2.isFalse()) {
									state = NOT_ZERO;
								} else if (c1.isFalse()) {
									state = ZERO;
								} else {
									if (options.usage === "row-reduction") {
										var tmp = Matrix.toRowEchelonStep(matrix, pivotRow, pivotColumn, pivotOriginRow, previousPivot, Object.assign({}, options, {callback: null}), condition);
										var m = tmp.matrix.slice(pivotOriginRow + 1, matrix.rows(), pivotColumn, matrix.cols()).map(function (e, i, j) {
											return c2.updateExpression(e);
										});
										if (m.eql(Matrix.Zero(m.rows(), m.cols()))) {
											return matrix.toRowEchelonInternal(options, pivotRow, pivotColumn, pivotOriginRow, previousPivot, NOT_ZERO, condition);
										}
									}
									return {
										matrix: matrix,
										c1: c1,
										a1: function () {
											return matrix.toRowEchelonInternal(options, pivotRow, pivotColumn, pivotOriginRow, previousPivot, NOT_ZERO, c1);
										},
										c2: c2,
										a2: function () {
											return matrix.toRowEchelonInternal(options, pivotRow, pivotColumn, pivotOriginRow, previousPivot, ZERO, c2);
										}
									};
								}
							} else {
								state = COLUMN_LOOP;
							}
						} else {
							state = NOT_ZERO;
						}
					}
					break;
				case NOT_ZERO:
					var tmp = Matrix.toRowEchelonStep(matrix, pivotRow, pivotColumn, pivotOriginRow, previousPivot, options, condition);
					var stoppedAtRow = tmp.stoppedAtRow;
					matrix = tmp.matrix;
					if (stoppedAtRow !== -1) {
						return {
							stoppedAtRow: stoppedAtRow,
							matrix: matrix,
							condition: condition
						};
					}
					previousPivot = matrix.e(pivotRow, pivotColumn);
					pivotRow += 1;
					state = COLUMN_LOOP;
					break;
			}
		}
	};

	Matrix.prototype.determinant = function () {
		var n = this.rows();
		if (!this.isSquare() || n === 0) {
			throw new RangeError("NonSquareMatrixException");
		}
		if (false && !Expression.has(this.e(0, 0), Expression.Polynomial)) {
			var tmp = this.toRowEchelon(Matrix.Gauss, "determinant", undefined);
			var stoppedAtRow = tmp.stoppedAtRow;
			var rowEchelonMatrix = tmp.matrix;
			if (stoppedAtRow !== -1) {
				return Expression.ZERO;
			}
			var det = rowEchelonMatrix.e(0, 0);
			for (var j = 1; j < rowEchelonMatrix.rows(); j += 1) {
				det = det.multiply(rowEchelonMatrix.e(j, j));
			}
			return det;
		}
		var tmp = this.toRowEchelon(Matrix.GaussMontante, "determinant", undefined);
		var stoppedAtRow = tmp.stoppedAtRow;
		var rowEchelonMatrix = tmp.matrix;
		if (stoppedAtRow !== -1) {
			return Expression.ZERO;
		}
		return rowEchelonMatrix.e(n - 1, n - 1);
	};

	Matrix.prototype.trace = function () {
		var n = this.rows();
		if (!this.isSquare() || n === 0) {
			throw new RangeError("NonSquareMatrixException");
		}
		var s = null;
		for (var i = 0; i < n; i += 1) {
			var e = this.e(i, i);
			s = s == null ? e : s.add(e);
		}
		return s;
	};

	Matrix.prototype.rank = function () {

		var m = this.toRowEchelon(Matrix.GaussMontante, "", undefined).matrix;
		var result = 0;
		var pivotRow = 0;
		var pivotColumn = 0;
		while (pivotRow < m.rows()) {
			while (pivotColumn < m.cols() && m.e(pivotRow, pivotColumn).equals(Expression.ZERO)) {
				pivotColumn += 1;
			}
			if (pivotColumn < m.cols()) {
				result += 1;
			}
			pivotRow += 1;
		}
		return result;
	};

	Matrix.prototype.inverse = function () {
		if (!this.isSquare()) {
			throw new RangeError("NonSquareMatrixException");
		}
		if (this.rows() === 2) {
			var a = this.e(0, 0);
			var b = this.e(0, 1);
			var c = this.e(1, 0);
			var d = this.e(1, 1);
			var det = a.multiply(d).subtract(b.multiply(c));
			if (det.equals(Expression.ZERO)) {
				throw new RangeError("SingularMatrixException");
			}
			return Matrix.Zero(this.rows(), this.rows()).map(function (e, i, j) {
				return (i === 0 ? (j === 0 ? d : b.negate()) : (j === 0 ? c.negate() : a)).divide(det);
			});
		}
		var m = this.augment(Matrix.I(this.rows()));

		m = m.toRowEchelon(Matrix.GaussMontante, "inverse", undefined).matrix;

		return Matrix.Zero(m.rows(), m.rows()).map(function (element, i, j) {
			var e = m.e(i, i);
			if (e.equals(Expression.ZERO)) {
				throw new RangeError("SingularMatrixException");
			}
			var x = m.e(i, j + m.rows());
			return e.equals(Expression.ONE) ? x : x.divide(e);
		});
	};

	Matrix.prototype.toString = function (options) {
		var result = "";
		var rows = this.rows();
		var cols = this.cols();
		if (rows === 0 && cols === 0) {
			throw new RangeError();
		}
		var j = -1;
		result += "{";
		while (++j < rows) {
			if (j !== 0) {
				result += ",";
			}
			result += "{";
			var i = -1;
			while (++i < cols) {
				if (i !== 0) {
					result += ",";
				}
				result += this.e(j, i).toString(options);
			}
			result += "}";
		}
		result += "}";
		return result;
	};

	Matrix.prototype.negate = function () {
		return this.map(function (element, i, j) {
			return element.negate();
		});
	};

	Matrix.prototype.subtract = function (b) {
		return this.add(b.negate());
	};

	Matrix.prototype.getElements = function () {
		var rows = this.rows();
		var cols = this.cols();
		var elements = new Array(rows);
		for (var i = 0; i < rows; i += 1) {
			var row = new Array(cols);
			for (var j = 0; j < cols; j += 1) {
				row[j] = this.e(i, j).toString();
			}
			elements[i] = row;
		}
		return elements;
	};

	Matrix.prototype.slice = function (rowsStart, rowsEnd, colsStart, colsEnd) {
		var that = this;
		return Matrix.Zero(rowsEnd - rowsStart, colsEnd - colsStart).map(function (e, i, j) {
			return that.e(i + rowsStart, j + colsStart);
		});
	};

	Matrix.prototype.isExact = function () {
		var rows = this.rows();
		var cols = this.cols();
		for (var i = 0; i < rows; i += 1) {
			for (var j = 0; j < cols; j += 1) {
				if (!this.e(i, j).isExact()) {
					return false;
				}
			}
		}
		return true;
	};

	Matrix.prototype.eql = function (b) {
		var a = this;
		if (a.rows() !== b.rows() || a.cols() !== b.cols()) {
			return false;
		}
		for (var i = 0; i < a.rows(); i += 1) {
			for (var j = 0; j < a.cols(); j += 1) {
				if (!a.e(i, j).equals(b.e(i, j))) {
					return false;
				}
			}
		}
		return true;
	};

	Matrix.prototype.pow = function (n) {
		if (!(n >= 0 && n <= Number.MAX_SAFE_INTEGER)) {
			throw new RangeError();
		}
		var pow = function (x, count, accumulator) {
			return (count < 1 ? accumulator : (2 * Math.floor(count / 2) !== count ? pow(x, count - 1, accumulator.multiply(x)) : pow(x.multiply(x), Math.floor(count / 2), accumulator)));
		};
		return pow(this, n, Matrix.I(this.rows()));
	};

	Matrix.split = function (input) {
		input = input.replace(/\b(sin|cos)\x20/g, '$1\u200B');
		var result = [];
		var m = input;
		if (/^\s*\[[^\[\]]*\]\s*$/.exec(m) != undefined) {
			m = m.replace(/\[/g, " ");
			m = m.replace(/\]/g, " ");
		}
		if (m.replace(/^[\s\u200B]+|[\s\u200B]+$/g, "") !== "") {
			m = m.replace(/;/g, "\n");
			m = m.replace(/\r/g, "\n");
			var row = [];
			result.push(row);
			var position = 0;
			var match = undefined;
			while ((match = /^[\s\u200B]*[^\s\u200B][^\s]*/.exec(m.slice(position))) != undefined) {
				var t = match[0];
				if (t.indexOf("\n") !== -1 && row.length !== 0) {
					row = [];
					result.push(row);
					t = t.replace(/\n/g, " ");
				}
				row.push(t);
				position += t.length;
			}
		}

		for (var i = 0; i < result.length; i++) {
			if (result[i].length === 1 && /,/.test(result[i][0])) {
				result[i] = result[i][0].split(',');
			}
		}
		return result;
	};

	Matrix.padRows = function (array, convertFunction) {
		var rows = array.length;
		var cols = 0;
		for (var k = 0; k < array.length; k += 1) {
			cols = Math.max(cols, array[k].length);
		}
		var data = new Array(rows);
		for (var i = 0; i < rows; i += 1) {
			var y = array[i];
			var x = new Array(cols);
			for (var j = 0; j < cols; j += 1) {
				x[j] = j < y.length ? (convertFunction != null ? convertFunction(y[j]) : y[j]) : Expression.ZERO;
			}
			data[i] = x;
		}
		return new Matrix(data);
	};

	Matrix.solveByGaussNext = function (m, callback) {
		var pivotRows = new Array(m.cols() - 1);
		for (var k = 0; k < m.cols() - 1; k += 1) {
			pivotRows[k] = -1;
		}
		for (var i = m.rows() - 1; i >= 0; i -= 1) {
			var j = 0;
			while (j < m.cols() - 1 && m.e(i, j).equals(Expression.ZERO)) {
				j += 1;
			}

			if (j < m.cols() - 1) {
				pivotRows[j] = i;
				var oldMatrix1 = m;

				for (var k = j + 1; k < m.cols() - 1; k += 1) {
					if (!m.e(i, k).equals(Expression.ZERO)) {
						var pivotRow = pivotRows[k];
						if (pivotRow !== -1) {
							m = m.rowReduce(i, pivotRow, k);
						}
					}
				}
				var oldMatrix2 = m;

				if (!m.e(i, j).equals(Expression.ONE)) {
					var c = m.e(i, j);
					m = m.map(function (e, row, column) {
						return row === i ? e.divide(c) : e;
					});
				}
				if (callback != undefined) {
					callback(m, oldMatrix1, oldMatrix2, i, j);
				}
			}
		}
		return m;
	};

	Matrix.getPivotRow = function (m, k) {
		var i = m.rows() - 1;
		while (i >= 0 && m.e(i, k).equals(Expression.ZERO)) {
			i -= 1;
		}
		if (i >= 0) {
			var j = k - 1;
			while (j >= 0 && m.e(i, j).equals(Expression.ZERO)) {
				j -= 1;
			}
			if (j < 0) {
				return i;
			}
		}
		return -1;
	};

	Matrix.getSolutionSet = function (m) {
		var result = {
			basisVectors: [],
			variables: []
		};
		for (var k = 0; k < m.cols() - 1; k += 1) {
			if (Matrix.getPivotRow(m, k) === -1) {

				var bx = new Array(m.cols() - 1);
				for (var j = 0; j < m.cols() - 1; j += 1) {
					var i = Matrix.getPivotRow(m, j);
					bx[j] = i !== -1 ? m.e(i, k).negate() : (j === k ? Expression.ONE : Expression.ZERO);
				}
				var basisVector = new Vector(bx);
				result.basisVectors.push(basisVector);
				result.variables.push(k);
			}
		}
		return result;
	};

	Matrix.prototype.minorMatrix = function (k, l) {
		var that = this;
		return Matrix.Zero(this.rows() - 1, this.cols() - 1).map(function (e, i, j) {
			return that.e(i < k ? i : i + 1, j < l ? j : j + 1);
		});
	};

	Matrix.toRowEchelonWithCallback = function (matrix, method, usage, changeCallback, resultCallback) {
		var result = matrix.toRowEchelonXXX(method, usage, changeCallback, Condition.TRUE);
		var w = function (result) {
			if (result.c1 == undefined && result.c2 == undefined) {
				resultCallback(result);
			} else {
				w(result.a1());
				w(result.a2());
			}
		};
		w(result);
	};

	Matrix.prototype.isDiagonal = function () {
		return this.eql(this.map(function (e, i, j) {
			return i !== j ? Expression.ZERO : e;
		}));
	};
	Matrix.prototype.isScalar = function () {
		var that = this;
		return this.eql(this.map(function (e, i, j) {
			return i !== j ? Expression.ZERO : that.e(0, 0);
		}));
	};
	Matrix.prototype.isNilpotent = function () {
		var x = this.map(function (e, i, j) {
			return j <= i ? Expression.ZERO : e;
		});
		if (this.eql(x)) {

			return true;
		}

		return this.pow(this.cols()).eql(Matrix.Zero(this.cols(), this.cols()));
	};

	Matrix.prototype.isJordanMatrix = function () {
		var that = this;
		return this.eql(this.map(function (e, i, j) {
			return i === j ? e : (j === i + 1 && that.e(i, i).equals(that.e(i + 1, i + 1)) && !that.e(i, j).equals(Expression.ZERO) ? Expression.ONE : Expression.ZERO);
		}));
	};
	Matrix.prototype.isZero = function () {
		return this.eql(Matrix.Zero(this.rows(), this.cols()));
	};

	function Vector(elements) {
		this.elements = elements;
	}

	Vector.prototype.e = function (index) {
		return this.elements[index];
	};

	Vector.prototype.dimensions = function () {
		return this.elements.length;
	};

	Vector.prototype.rows = function () {
		return this.dimensions();
	};
	Vector.prototype.cols = function () {
		return 1;
	};
	Vector.prototype.isExact = function () {
		for (var i = 0; i < this.dimensions(); i += 1) {
			if (!this.e(i).isExact()) {
				return false;
			}
		}
		return true;
	};

	Vector.prototype.toString = function (options) {
		return Matrix.prototype.toString.call(this, options);
	};

	Vector.prototype.dot = function (other) {
		var result = Expression.ZERO;
		var d = Math.max(this.dimensions(), other.dimensions());
		for (var i = 0; i < d; i += 1) {
			var s = this.e(i).multiply(other.e(i).complexConjugate());
			result = result === Expression.ZERO ? s : result.add(s);
		}
		return result;
	};
	Vector.prototype.toUnitVector = function () {
		var norm = this.dot(this).squareRoot();
		return this.scale(norm.inverse());
	};

	Vector.prototype.scale = function (s) {
		return new Vector(this.elements.map(function (e) {
			return s.multiply(e);
		}));
	};
	Vector.prototype.subtract = function (other) {
		if (this.dimensions() !== other.dimensions()) {
			throw new RangeError("MatrixDimensionMismatchException");
		}
		var n = this.dimensions();
		var result = new Array(n);
		for (var i = 0; i < n; i += 1) {
			result[i] = this.e(i).subtract(other.e(i));
		}
		return new Vector(result);
	};

	Vector.prototype.eql = function (other) {
		if (this.dimensions() !== other.dimensions()) {
			throw new RangeError("MatrixDimensionMismatchException");
		}
		var n = this.dimensions();
		for (var i = 0; i < n; i += 1) {
			if (!this.e(i).equals(other.e(i))) {
				return false;
			}
		}
		return true;
	};
	Vector.Zero = function (n) {
		return new Vector(new Array(n).fill(Expression.ZERO));
	};

	Matrix.Vector = Vector;

	Matrix.prototype.row = function (i) {
		var elements = new Array(this.cols());
		for (var j = 0; j < this.cols(); j += 1) {
			elements[j] = this.e(i, j);
		}
		return new Vector(elements);
	};
	Matrix.prototype.col = function (j) {
		var elements = new Array(this.rows());
		for (var i = 0; i < this.rows(); i += 1) {
			elements[i] = this.e(i, j);
		}
		return new Vector(elements);
	};

	Matrix.prototype.rowVectors = function () {
		var result = [];
		for (var i = 0; i < this.rows(); i += 1) {
			result.push(this.row(i));
		}
		return result;
	};

	self.Matrix = Matrix;
}

function Combinations() {
	function combinations(n, k) {
		n = n | 0;
		k = k | 0;
		if (k < 1) {
			throw new RangeError();
		}
		var indexes = [];
		for (var i = 0; i < k; i++) {
			indexes.push(n - k + i);
		}
		indexes[0] = -1;
		var result = {
			value: indexes,
			done: false
		};
		var done = {
			value: undefined,
			done: true
		};
		var iterator = {
			next: function () {
				var i = indexes[k - 1];
				if (i < n - 1) {
					indexes[k - 1] = i + 1;
					return result;
				}
				var depth = k - 1;
				while (depth >= 0 && indexes[depth] === n - k + depth) {
					depth -= 1;
				}
				if (depth >= 0) {
					var j = indexes[depth];
					while (depth < k) {
						j += 1;
						indexes[depth] = j;
						depth += 1;
					}
					return result;
				}
				return done;
			}
		};
		iterator[globalThis.Symbol.iterator] = function () {
			return this;
		};
		return iterator;
	}

	self.combinations = combinations;
}

function BinaryPacking() {
	var u8 = typeof Uint8Array !== 'undefined' ? new Uint8Array(4) : null;
	var td = typeof TextDecoder !== 'undefined' ? new TextDecoder() : null;
	var te = typeof TextEncoder !== 'undefined' ? new TextEncoder() : null;

	function detectBigEndian() {
		var u32 = new Uint32Array(u8.buffer);
		u32[0] = 1;
		return u8[0] === 0;
	}

	function bswap32(a) {
		a = a | 0;
		return (a << 24) | ((a & 0x0000FF00) << 8) | ((a & 0x00FF0000) >>> 8) | (a >>> 24);
	}

	var isBigEndian = u8 != null && detectBigEndian();

	function packBigInt17(blocks, blockSize) {
		blockSize |= 0;
		if (blockSize > 32) {
			if (blockSize % 2 !== 0) {
				throw new RangeError();
			}
			var s = Math.pow(2, blockSize >> 1);
			var sInv = 1 / s;
			var blocks2 = new Array(blocks.length * 2);
			var k = 0;
			for (var i = 0; i < blocks.length; i += 1) {
				var b = blocks[i];
				var q = -0 + Math.floor(b * sInv);
				blocks2[k] = b - q * s;
				blocks2[k + 1] = q;
				k += 2;
			}
			return packBigInt17(blocks2, blockSize >> 1);
		}
		var length = (Math.ceil(blocks.length * blockSize / 16) + 1) | 0;
		if (u8.length < length * 4) {
			u8 = new Uint8Array(length * 4);
		}
		var k = (length - 1) | 0;
		var buffer = 0;
		var bits = 0;
		var count = blocks.length | 0;
		var u32 = new Uint32Array(u8.buffer);
		for (var i = 0; i < count; i = (i + 1) | 0) {
			var block = blocks[i] | 0;
			buffer = buffer | (block << bits);
			bits = (bits + blockSize) | 0;
			var z = ((i + 1) | 0) < count ? 16 - 1 : 0;
			while ((bits | 0) > z) {
				bits = (bits - 16) | 0;

				var e = buffer & 0xFFFF;
				e = (e | (e << 24)) & 0xFF00FF00;
				e = (e | (e >>> 12)) & 0x0F0F0F0F;
				var m = (e + 0x16161616) & 0x20202020;
				e = ((e + 0x30303030) + (m) + (m >>> 2) - (m >>> 5)) | 0;
				if (isBigEndian) {
					e = bswap32(e);
				}
				u32[k] = e;
				k = (k - 1) | 0;
				buffer = (bits === 0 ? 0 : (block >>> (blockSize - bits))) | 0;
			}
		}

		u32[0] = 0x30303030;
		u8[1] = 0x78;
		return BigInt(td.decode(u8.subarray(0, length * 4)));
	}

	function unpackBigInt17(bigint, blocksCount, blockSize) {
		bigint = BigInt(bigint);
		blocksCount |= 0;
		blockSize |= 0;
		if (blockSize > 32) {
			if (blockSize % 2 !== 0) {
				throw new RangeError();
			}
			var s = Math.pow(2, blockSize >> 1);
			var sInv = 1 / s;
			var blocks2 = unpackBigInt17(bigint, blocksCount * 2, blockSize >> 1);
			var blocks = new Array(blocksCount);
			var k = 0;
			for (var i = 0; i < blocks.length; i += 1) {
				blocks[i] = blocks2[k + 1] * s + blocks2[k];
				k += 2;
			}
			return blocks;
		}
		var s = bigint.toString(16);
		var length = Math.ceil(s.length / 4) | 0;
		if (u8.length < length * 4) {
			u8 = new Uint8Array(length * 4);
		}
		var u32 = new Uint32Array(u8.buffer);
		u32[0] = 0x30303030;
		te.encodeInto(s, u8.subarray(length * 4 - s.length, length * 4));
		var blocks = new Array(blocksCount);
		var k = 0;
		var buffer = 0;
		var bits = 0;
		var zeroBits = (length * (4 * 4) - Math.min(blocksCount * blockSize, s.length * 4)) | 0;
		var mask = (blockSize === 32 ? -1 : ~(-1 << blockSize)) | 0;
		for (var i = (length - 1) | 0; i >= 0; i = (i - 1) | 0) {
			var a = u32[i] | 0;
			if (isBigEndian) {
				a = bswap32(a) | 0;
			}
			var m = ((a + 0x1F1F1F1F) & 0x80808080);
			a = ((a - 0x30303030) - (m >>> 2) - (m >>> 4) + (m >>> 7)) | 0;
			a = (a | (a << 12)) & 0xFF00FF00;
			a = (a | (a >>> 24)) & 0x0000FFFF;
			buffer = buffer | (a << bits);
			var s = 16 - (i === 0 ? zeroBits : 0);
			bits = (bits + s) | 0;
			while (bits >= blockSize) {
				bits = (bits - blockSize) | 0;
				var e = buffer & mask;
				blocks[k] = -0 + e;
				k = (k + 1) | 0;
				buffer = (a >>> (s - bits)) | 0;
			}
		}
		if (bits > 0) {
			var e = buffer & mask;
			blocks[k] = -0 + e;
			k = (k + 1) | 0;
		}
		while (k < blocksCount) {
			blocks[k] = -0;
			k = (k + 1) | 0;
		}
		return blocks;
	}

	self.unpackBigInt17 = unpackBigInt17;
	;globalThis.packBigInt17 = packBigInt17;
	globalThis.unpackBigInt17 = unpackBigInt17;
}

function IntegerPolynomial() {
	function makeArray(size) {

		var x = new Array(size);
		for (var i = 0; i < size; i += 1) {
			x[i] = -0;
		}
		return x;
	}

	var floor = Math.floor;
	var ceil = Math.ceil;

	function modulo(a, b, bInv) {

		var x = a - ceil(a * bInv) * b;
		x = x < -0.0 ? x + b : x;
		return x;
	}

	function check(number) {
		if (typeof number !== "number" || Math.abs(number) > Number.MAX_SAFE_INTEGER) {
			throw new RangeError();
		}
	}

	function schoolbook(a, b, options) {
		if (a.length === 0) {
			return a;
		}
		if (b.length === 0) {
			return b;
		}
		var squaring = a === b;
		var to = (a.length - 1 + b.length - 1 + 1);
		if (options != null && options.low != null) {
			to = Math.max(0, Math.min(to, (options.low | 0)));
		}
		var c = makeArray(to);
		for (var i = 0; i < c.length; i += 1) {
			var from = Math.max(0, i - (b.length - 1));
			var to = Math.min(i, a.length - 1);
			if (squaring) {
				from = (i + 1) >> 1;
			}
			var e = a[from] * b[i - from];
			var s = e;
			for (var j = from + 1; j <= to; j += 1) {
				s += a[j] * b[i - j];
			}
			if (squaring) {
				s = ((i & 1) === 0 ? s - e : s) + s;
			}
			c[i] = s;
		}
		return c;
	}

	function absMax(array) {
		var max = -0;
		for (var i = 0; i < array.length; i += 1) {
			max = Math.max(max, Math.abs(array[i]));
		}
		return max;
	}

	var supportsLargeBigintCache = undefined;

	function supportsLargeBigint() {
		if (supportsLargeBigintCache == undefined) {
			try {
				supportsLargeBigintCache = (BigInt(1) << BigInt(Math.pow(2, 20))) !== BigInt(0);
			} catch (error) {
				supportsLargeBigintCache = false;
			}
		}
		return supportsLargeBigintCache;
	}

	var hasFastBigIntMultiplication = supportsLargeBigint() && typeof TextEncoder != undefined && typeof TextDecoder != undefined && typeof Uint32Array != undefined && typeof Uint8Array != undefined;

	function multiply(A, B, options) {
		options = options == undefined ? null : options;

		if (A.length > 128 && B.length > 128 && hasFastBigIntMultiplication) {
			return multiplyByKroneckerSubstitution(A, B, options);
		}
		return schoolbook(A, B, options);
	}

	function add(a, b) {
		var c = makeArray(Math.max(a.length, b.length));
		var min = Math.min(a.length, b.length);
		for (var i = 0; i < min; i += 1) {
			c[i] = a[i] + b[i];
		}
		for (var i = min; i < a.length; i += 1) {
			c[i] = a[i];
		}
		for (var i = min; i < b.length; i += 1) {
			c[i] = b[i];
		}
		return c;
	}

	function subtract(a, b) {
		var c = makeArray(Math.max(a.length, b.length));
		var min = Math.min(a.length, b.length);
		for (var i = 0; i < min; i += 1) {
			c[i] = a[i] - b[i];
		}
		for (var i = min; i < a.length; i += 1) {
			c[i] = a[i];
		}
		for (var i = min; i < b.length; i += 1) {
			c[i] = -b[i];
		}
		return c;
	}

	function IntPolynomial(coefficients) {
		var k = coefficients.length;
		while (k > 0 && coefficients[k - 1] === -0) {
			k -= 1;
		}
		if (coefficients.length !== k) {
			if (coefficients instanceof Float64Array) {
				coefficients = coefficients.subarray(0, k);
			} else {
				coefficients.length = k;
			}
		}

		this.coefficients = coefficients;
	}

	IntPolynomial.prototype.add = function (other) {
		var a = this.coefficients;
		var b = other.coefficients;
		return new IntPolynomial(add(a, b));
	};
	IntPolynomial.prototype.subtract = function (other) {
		var a = this.coefficients;
		var b = other.coefficients;
		return new IntPolynomial(subtract(a, b));
	};
	IntPolynomial.prototype.multiply = function (other, options) {
		options = options == undefined ? null : options;

		var a = this.coefficients;
		var b = other.coefficients;
		return new IntPolynomial(multiply(a, b, options));
	};
	IntPolynomial.prototype.divideAndRemainderModP = function (other, m) {

		var a = this.coefficients;
		var b = other.coefficients;
		if (a.length < b.length) {
			return {
				quotient: new IntPolynomial(makeArray(0)),
				remainder: this.mod(m)
			};
		}
		if (b.length === 0) {
			throw new RangeError();
		}
		var lc = b[b.length - 1];
		if (lc !== (-0 + 1)) {
			throw new RangeError();
		}

		var remainder = makeArray(a.length);
		for (var i = 0; i < a.length; i += 1) {
			remainder[i] = a[i];
		}
		var remainderDegree = remainder.length - 1;
		var quotient = makeArray(a.length - b.length + 1);

		for (var i = 0; i < quotient.length; i += 1) {
			quotient[i] = -0;
		}
		var mInv = 1.0 / m;
		while (remainderDegree >= b.length - 1) {
			var n = remainderDegree - b.length + 1;
			var q = modulo(remainder[remainderDegree], m, mInv);
			quotient[n] = q;
			if (q !== -0) {
				if (q === (-0 + 1)) {
					for (var j = b.length - 1; j >= 0; j -= 1) {
						remainder[j + n] -= b[j];
					}
				} else {
					for (var j = b.length - 1; j >= 0; j -= 1) {
						remainder[j + n] -= q * b[j];
					}
				}
			}
			while (remainderDegree >= 0 && modulo(remainder[remainderDegree], m, mInv) === -0) {
				remainder[remainderDegree] = -0;
				remainderDegree -= 1;
			}
		}
		for (var j = 0; j <= remainderDegree; j += 1) {
			remainder[j] = modulo(remainder[j], m, mInv);
		}
		return {
			quotient: new IntPolynomial(quotient),
			remainder: new IntPolynomial(remainder)
		};
	};

	IntPolynomial.prototype.negate = function (s) {
		var A = this.coefficients;
		var c = makeArray(A.length);
		for (var i = 0; i < A.length; i += 1) {
			c[i] = -0 - A[i];
		}
		return new IntPolynomial(c);
	};
	IntPolynomial.prototype.scale = function (s) {
		var A = this.coefficients;
		var c = makeArray(A.length);
		for (var i = 0; i < A.length; i += 1) {
			c[i] = A[i] * s;
		}
		return new IntPolynomial(c);
	};
	IntPolynomial.prototype.unscale = function (s) {
		var A = this.coefficients;
		var c = makeArray(A.length);
		for (var i = 0; i < A.length; i += 1) {
			c[i] = -0 + Math.floor(A[i] / s);
		}
		return new IntPolynomial(c);
	};
	IntPolynomial.prototype.mod = function (p) {
		var A = this.coefficients;
		var c = makeArray(A.length);
		var pInv = 1.0 / p;
		for (var i = 0; i < A.length; i += 1) {
			c[i] = modulo(A[i], p, pInv);
		}
		return new IntPolynomial(c);
	};

	IntPolynomial.prototype.getDegree = function () {
		return this.coefficients.length - 1;
	};
	IntPolynomial.prototype.getLeadingCoefficient = function () {
		if (this.coefficients.length === 0) {
			throw new RangeError();
		}
		return this.coefficients[this.coefficients.length - 1];
	};
	IntPolynomial.prototype.getCoefficient = function (degree) {
		if (degree >= this.coefficients.length) {
			throw new RangeError();
		}
		return this.coefficients[degree];
	};
	IntPolynomial.prototype.derive = function (p) {
		var c = makeArray(this.coefficients.length - 1);
		for (var i = 0; i < c.length; i += 1) {
			c[i] = (i + 1) * this.coefficients[i + 1];
		}
		return new IntPolynomial(c);
	};
	IntPolynomial.prototype.toString = function () {
		var s = '';
		var c = this.coefficients;
		for (var i = c.length - 1; i >= 0; i -= 1) {
			s += (c[i] >= 0 && i !== c.length ? '+' : '');
			s += c[i].toString();
			if (i === 1) {
				s += 'x';
			} else if (i !== 0) {
				s += 'x^';
				s += i;
			}
		}
		return s;
	};
	IntPolynomial.from = function (coefficients) {
		var c = makeArray(coefficients.length);
		for (var i = 0; i < coefficients.length; i += 1) {
			c[i] = -0.0 + coefficients[i];
		}
		return new IntPolynomial(c);
	};

	IntPolynomial.prototype.shift = function (n) {
		var coefficients = this.coefficients;
		var c = makeArray(coefficients.length + n);
		for (var i = 0; i < n; i += 1) {
			c[i] = -0.0;
		}
		for (var i = 0; i < coefficients.length; i += 1) {
			c[i + n] = coefficients[i];
		}
		return new IntPolynomial(c);
	};

	self.IntPolynomial = IntPolynomial;

	var cache = typeof WeakMap !== 'undefined' ? new WeakMap() : null;

	function fromCache(coefficients, blockSize) {
		var e = cache == null ? null : cache.get(coefficients);
		return e != null && e.blockSize === blockSize ? e.bigint : null;
	}

	function toCache(coefficients, blockSize, bigint) {
		if (cache != null) {
			cache.set(coefficients, {
				blockSize: blockSize,
				bigint: bigint
			});
		}
	}

	function multiplyByKroneckerSubstitution(A, B, options) {
		options = options == undefined ? null : options;

		var amax = -1 / 0;
		var amin = 1 / 0;
		for (var i = 0; i < A.length; i += 1) {
			amax = Math.max(amax, A[i]);
			amin = Math.min(amin, A[i]);
		}
		var bmax = amax;
		var bmin = amin;
		if (A !== B) {
			bmax = -1 / 0;
			bmin = 1 / 0;
			for (var i = 0; i < B.length; i += 1) {
				bmax = Math.max(bmax, B[i]);
				bmin = Math.min(bmin, B[i]);
			}
		}
		if (bmin < 0 || amin < 0) {

			return schoolbook(A, B, options);
		}

		var blockDigit = amax * bmax * Math.min(A.length, B.length) + 1;
		var blockSize = Math.ceil(Math.log2(blockDigit));
		if (Math.pow(2, blockSize) <= blockDigit) {
			blockSize += 1;
		}

		if (blockSize > 32) {
			blockSize = Math.ceil(blockSize / 2) * 2;
		}

		var Ai = packBigInt17(A, blockSize);
		var Bi = A === B ? Ai : (fromCache(B, blockSize) || packBigInt17(B, blockSize));
		if (A !== B) {
			toCache(B, blockSize, Bi);
		}
		var blocksCount = A.length + B.length - 1;
		if (options != null && options.low != null) {
			blocksCount = options.low | 0;
		}
		var P = BigInt.asUintN(blockSize * blocksCount, Ai * Bi);
		var C = unpackBigInt17(P, blocksCount, blockSize);
		return C;
	}

	function low(p, n) {
		return new p.constructor(p.coefficients.slice(0, n));
	}

	function high(p, n) {
		return new p.constructor(p.coefficients.slice(n));
	}

	var zero = IntPolynomial.from([]);
	var one = IntPolynomial.from([1]);

	var multiplyLow = function (a, b, k) {
		return low(a.multiply(b, {low: k}), k);
	};

	var reversal = function (p) {
		return new p.constructor(p.coefficients.slice(0).reverse());
	};

	var inv = function (g, k, p) {

		var h = IntPolynomial.from([modInverseSmall(g.getCoefficient(0), p)]);
		var e = 1;
		while (e < k) {
			e *= 2;

			h = low(h.add(h).subtract(multiplyLow(low(g, e), h.multiply(h).mod(p), e)).mod(p), e);
			var c = 1;
			while (e * c < k) {
				c *= 2;
			}
			if ((e - 1) * c >= k) {
				e -= 1;
				h = low(h, e);
			}
		}
		return low(h, e);
	};

	function barrettPreinvert(B, p) {

		var modInv = inv(reversal(B), (2 * B.getDegree() - 2) - B.getDegree() + 1, p);

		return modInv;

	}

	function barrettReduce(A, B, BRevModInv, p) {

		var n = A.getDegree();
		var m = B.getDegree();
		var e = n - m + 1;
		if (e <= 0) {
			return A;
		}

		var revQ = multiplyLow(low(reversal(A), e), BRevModInv, e);
		var Q = reversal(revQ).shift(e - 1 - revQ.getDegree()).mod(p);
		return low(A, m).subtract(multiplyLow(low(Q, m), B, m)).mod(p);
	}

	IntPolynomial._barrettPreinvert = barrettPreinvert;
	IntPolynomial._barrettReduce = barrettReduce;

	function modPow(polynomial, n, m, q) {
		if (polynomial.getDegree() >= m.getDegree()) {
			polynomial = polynomial.divideAndRemainderModP(m, q).remainder;
		}
		if (polynomial.getDegree() < 0) {
			return polynomial;
		}

		var mInv = IntPolynomial._barrettPreinvert(m, q);

		var e = n.toBigInt().toString(2);
		var accumulator = null;
		for (var i = 0; i < e.length; i += 1) {
			if (accumulator != null) {
				accumulator = IntPolynomial._barrettReduce(accumulator.multiply(accumulator).mod(q), m, mInv, q);
			}
			if (e.charCodeAt(i) === '1'.charCodeAt(0)) {
				if (accumulator == null) {
					accumulator = polynomial;
				} else {
					accumulator = IntPolynomial._barrettReduce(accumulator.multiply(polynomial).mod(q), m, mInv, q);
				}
			}
		}
		return accumulator;
	}

	IntPolynomial.modPow = modPow;

	function modInverseSmall(a, m) {
		if (typeof a !== 'number' || typeof m !== 'number') {
			throw new TypeError();
		}
		if (m < 0) {
			throw new RangeError();
		}
		console.assert(a >= 0);
		if (a >= m) {
			a = a - Math.floor(a / m) * m;
		}
		var oldR = a;
		var r = m;
		var oldX = 1;
		var x = 0;
		while (r !== 0) {
			var q = Math.floor(oldR / r);
			var newR = oldR - q * r;
			oldR = r;
			r = newR;
			var newX = oldX - q * x;
			oldX = x;
			x = newX;
		}
		var inv = oldX;
		inv = inv < 0 ? inv + m : inv;
		console.assert(inv >= 0 && inv < m);
		return inv;
	}

	var halfExtended = true;

	function halfgcd(a, b, p, extended, truehalfgcd) {
		extended = extended == undefined ? true : extended;
		truehalfgcd = truehalfgcd == undefined ? true : truehalfgcd;

		extended = extended || truehalfgcd;

		var A = one;
		var B = zero;
		var C = zero;
		var D = one;
		var step = 0;
		if (a.getDegree() < b.getDegree()) {
			var tmp = a;
			a = b;
			b = tmp;
			step += 1;
			if (extended) {
				var $newB = D;
				var $newD = B;
				B = $newB;
				D = $newD;
				if (truehalfgcd || !halfExtended) {
					var $newA = C;
					var $newC = A;
					A = $newA;
					C = $newC;
				}
			}
		}
		var s = a.getDegree();
		while (b.getDegree() >= 0) {
			step += 1;
			if (b.getDegree() >= (truehalfgcd ? 32 : (extended ? 8 : 128))) {

				var m = truehalfgcd ? Math.max(0, Math.ceil((a.getDegree() - D.getDegree()) / 2)) : (extended ? 0 : Math.floor(a.getDegree() * (2 / 3)));
				if (truehalfgcd) {

					if (D.getDegree() >= m) {
						break;
					}
				}
				var $tmpA1_B1_C1_D1_ahi1_bhi1 = halfgcd(m === 0 ? a : high(a, m), m === 0 ? b : high(b, m), p);
				var A1 = $tmpA1_B1_C1_D1_ahi1_bhi1[0];
				var B1 = $tmpA1_B1_C1_D1_ahi1_bhi1[1];
				var C1 = $tmpA1_B1_C1_D1_ahi1_bhi1[2];
				var D1 = $tmpA1_B1_C1_D1_ahi1_bhi1[3];
				var ahi1 = $tmpA1_B1_C1_D1_ahi1_bhi1[4];
				var bhi1 = $tmpA1_B1_C1_D1_ahi1_bhi1[5];
				if (B1.getDegree() >= 0) {
					if (extended) {
						if (step === 1) {
							var $newA = A1;
							var $newB = B1;
							var $newC = C1;
							var $newD = D1;
							A = $newA;
							B = $newB;
							C = $newC;
							D = $newD;
						} else {

							var $newB = A1.multiply(B).add(B1.multiply(D)).mod(p);
							var $newD = C1.multiply(B).add(D1.multiply(D)).mod(p);
							B = $newB;
							D = $newD;
							if (truehalfgcd || !halfExtended) {
								var $newA = A1.multiply(A).add(B1.multiply(C)).mod(p);
								var $newC = C1.multiply(A).add(D1.multiply(C)).mod(p);
								A = $newA;
								C = $newC;
							}
						}
					}
					if (m === 0) {
						a = ahi1;
						b = bhi1;
					} else {
						var alo = low(a, m);
						var blo = low(b, m);
						var a1 = A1.multiply(alo).add(B1.multiply(blo)).add(ahi1.shift(m)).mod(p);
						var b1 = C1.multiply(alo).add(D1.multiply(blo)).add(bhi1.shift(m)).mod(p);
						a = a1;
						b = b1;
					}
					continue;
				}
			}
			var lc = b.getLeadingCoefficient();
			if (lc !== 1.0) {
				var scale = -0 + modInverseSmall(lc, p);
				b = b.scale(scale).mod(p);
				if (extended) {
					D = D.scale(scale).mod(p);
					if (truehalfgcd || !halfExtended) {
						C = C.scale(scale).mod(p);
					}
				}
			}
			var tmp = a.divideAndRemainderModP(b, p);
			var q = tmp.quotient;
			var b1 = tmp.remainder;
			if (extended) {
				var D1 = B.subtract(q.multiply(D)).mod(p);
				if (truehalfgcd) {
					if (D1.getDegree() > b1.getDegree()) {
						break;
					}
				}
				B = D;
				D = D1;
				if (truehalfgcd || !halfExtended) {
					var C1 = A.subtract(q.multiply(C)).mod(p);
					A = C;
					C = C1;
				}
			}
			a = b;
			b = b1;
		}
		if (truehalfgcd) {

			if (a.getDegree() < Math.ceil(s / 2)) {
				throw new TypeError();
			}
		}
		return [A, B, C, D, a, b];
	}

	IntPolynomial.gcdext = function (a, b, p) {
		var $tmpA_B_C_D_a1_b1 = halfgcd(a, b, p, true, false);
		var A = $tmpA_B_C_D_a1_b1[0];
		var B = $tmpA_B_C_D_a1_b1[1];
		var C = $tmpA_B_C_D_a1_b1[2];
		var D = $tmpA_B_C_D_a1_b1[3];
		var a1 = $tmpA_B_C_D_a1_b1[4];
		var b1 = $tmpA_B_C_D_a1_b1[5];
		if (halfExtended) {
			var lc = a.getLeadingCoefficient();
			var scale = modInverseSmall(lc, p);
			A = a1.subtract(B.multiply(b)).mod(p).scale(scale).mod(p).divideAndRemainderModP(a.scale(scale).mod(p), p).quotient;
		}
		return {
			U: A,
			V: B,
			gcd: a1
		};
	};

	IntPolynomial.gcd = function (a, b, p) {
		var $tmpA_B_C_D_a1_b1 = halfgcd(a, b, p, false, false);
		var A = $tmpA_B_C_D_a1_b1[0];
		var B = $tmpA_B_C_D_a1_b1[1];
		var C = $tmpA_B_C_D_a1_b1[2];
		var D = $tmpA_B_C_D_a1_b1[3];
		var a1 = $tmpA_B_C_D_a1_b1[4];
		var b1 = $tmpA_B_C_D_a1_b1[5];
		return a1;
	};
}

function LLL() {
	function Fraction(numerator, denominator) {
		this.numerator = numerator;
		this.denominator = denominator;
	}

	function assertBigInt(x) {
		if (!(x instanceof JSBI)) {
			throw new TypeError();
		}
		return x;
	}

	Fraction.prototype.toNumber = function () {
		var a = assertBigInt(this.numerator);
		var b = assertBigInt(this.denominator);
		var na = JSBI.toNumber(a);
		var nb = JSBI.toNumber(b);
		if (na !== -1 / 0 && na !== 1 / 0 && nb !== -1 / 0 && nb !== 1 / 0) {
			return na / nb;
		}
		return JSBI.toNumber(JSBI.divide(JSBI.leftShift(a, JSBI.BigInt(64)), b)) * Math.pow(2, -64);
	};
	Fraction.prototype.round = function () {
		var a = assertBigInt(this.numerator);
		var b = assertBigInt(this.denominator);
		if (JSBI.lessThanOrEqual(b, JSBI.BigInt(0))) {
			throw new RangeError();
		}
		return JSBI.divide(JSBI.lessThan(a, JSBI.BigInt(0)) ? JSBI.subtract(a, JSBI.signedRightShift(b, JSBI.BigInt(1))) : JSBI.add(a, JSBI.signedRightShift(b, JSBI.BigInt(1))), b);
	};
	Fraction.prototype.divide = function (other) {
		var a = assertBigInt(this.numerator);
		var b = assertBigInt(this.denominator);
		var c = assertBigInt(other.numerator);
		var d = assertBigInt(other.denominator);
		return new Fraction(JSBI.multiply(a, d), JSBI.multiply(b, c));
	};

	function Vector(elements) {
		this.elements = elements;
	}

	Vector.prototype.dot = function (other) {
		var a = this.elements;
		var b = other.elements;
		var s = JSBI.BigInt(0);
		var n = Math.min(a.length, b.length);
		for (var i = 0; i < n; i += 1) {
			s = JSBI.add(s, JSBI.multiply(assertBigInt(a[i]), assertBigInt(b[i])));
		}
		return s;
	};
	Vector.prototype.submul = function (other, alpha) {
		if (!(alpha instanceof JSBI)) {
			throw new TypeError();
		}
		var a = this.elements;
		var b = other.elements;
		var n = Math.min(a.length, b.length);
		var c = new Array(n);
		if (JSBI.equal(alpha, JSBI.BigInt(1))) {
			for (var i = 0; i < n; i += 1) {
				c[i] = JSBI.subtract(assertBigInt(a[i]), assertBigInt(b[i]));
			}
		} else if (JSBI.equal(alpha, JSBI.unaryMinus(JSBI.BigInt(1)))) {
			for (var i = 0; i < n; i += 1) {
				c[i] = JSBI.add(assertBigInt(a[i]), assertBigInt(b[i]));
			}
		} else {
			for (var i = 0; i < n; i += 1) {
				c[i] = JSBI.subtract(assertBigInt(a[i]), JSBI.multiply(alpha, assertBigInt(b[i])));
			}
		}
		return new Vector(c);
	};
	Vector.prototype.isZero = function () {
		var a = this.elements;
		var n = a.length;
		for (var i = 0; i < n; i += 1) {
			if (JSBI.notEqual(a[i], JSBI.BigInt(0))) {
				return false;
			}
		}
		return true;
	};

	function GramSchmidt(vectors) {

		this.b = vectors;
		var n = vectors.length;
		this.dmu = new Array(n).fill(null).map(function (x) {
			return new Array(n).fill(JSBI.BigInt(0));
		});
		this.d = new Array(n + 1).fill(JSBI.BigInt(0));
		this.d[0] = JSBI.BigInt(1);
		this.computedCount = 0;

	}

	GramSchmidt.prototype.computeUpTo = function (k) {
		var b = this.b;
		var dmu = this.dmu;
		var d = this.d;
		for (var i = this.computedCount; i <= k; i += 1) {
			for (var j = 0; j <= i; j += 1) {
				var sigma = JSBI.BigInt(0);
				for (var l = 0; l < j; l += 1) {
					sigma = JSBI.divide(JSBI.add(JSBI.multiply(d[l + 1], sigma), JSBI.multiply(assertBigInt(dmu[i][l]), dmu[j][l])), d[l]);
				}

				dmu[i][j] = JSBI.subtract(JSBI.multiply(d[j], assertBigInt(b[i].dot(b[j]))), sigma);
			}
			d[i + 1] = dmu[i][i];

			this.computedCount = i + 1;
		}
		return this;
	};
	GramSchmidt.prototype.squaredNorm = function (i) {
		return new Fraction(this.d[i + 1], this.d[i]);
	};

	GramSchmidt.prototype.mu = function (i, j) {
		return new Fraction(this.dmu[i][j], this.d[j + 1]);
	};
	GramSchmidt.prototype.reduceVector = function (k, j, alpha) {
		if (!(alpha instanceof JSBI)) {
			throw new TypeError();
		}
		var dmu = this.dmu;
		var dmu_k = dmu[k];
		var dmu_j = dmu[j];
		if (JSBI.equal(alpha, JSBI.BigInt(1))) {
			for (var i = 0; i <= j; i += 1) {
				dmu_k[i] = JSBI.subtract(assertBigInt(dmu_k[i]), assertBigInt(dmu_j[i]));
			}
		} else if (JSBI.equal(alpha, JSBI.unaryMinus(JSBI.BigInt(1)))) {
			for (var i = 0; i <= j; i += 1) {
				dmu_k[i] = JSBI.add(assertBigInt(dmu_k[i]), assertBigInt(dmu_j[i]));
			}
		} else {
			for (var i = 0; i <= j; i += 1) {
				dmu_k[i] = JSBI.subtract(assertBigInt(dmu_k[i]), JSBI.multiply(alpha, assertBigInt(dmu_j[i])));
			}
		}
	};
	GramSchmidt.prototype.swapVectorKAndKminusOne = function (k) {
		var dmu = this.dmu;
		var d = this.d;

		for (var j = 0; j < k - 1; j += 1) {
			var dmu_k_j = dmu[k][j];
			var dmu_km1_j = dmu[k - 1][j];
			dmu[k - 1][j] = dmu_k_j;
			dmu[k][j] = dmu_km1_j;
		}
		var dmu_k_km1 = assertBigInt(dmu[k][k - 1]);
		var d_k = d[k];
		var d_kp1 = assertBigInt(d[k + 1]);
		var d_km1 = assertBigInt(d[k - 1]);
		dmu[k - 1][k - 1] = JSBI.divide(JSBI.add(JSBI.multiply(d_kp1, d_km1), JSBI.multiply(dmu_k_km1, dmu_k_km1)), d_k);

		for (var i = k + 1; i < this.computedCount; i += 1) {
			var dmu_i_k = dmu[i][k];
			var dmu_i_km1 = dmu[i][k - 1];
			dmu[i][k - 1] = JSBI.divide(JSBI.add(JSBI.multiply(dmu_i_km1, dmu_k_km1), JSBI.multiply(dmu_i_k, d_km1)), d_k);
			dmu[i][k] = JSBI.divide(JSBI.subtract(JSBI.multiply(dmu_i_km1, d_kp1), JSBI.multiply(dmu_i_k, dmu_k_km1)), d_k);
		}

		d[k] = dmu[k - 1][k - 1];

	};

	function LLL(latticeBasis, δ, η) {
		δ = δ == undefined ? 3 / 4 : δ;
		η = η == undefined ? 1 / 2 : η;

		var b = latticeBasis.map(function (array) {
			return new Vector(array.map(function (e) {
				return JSBI.BigInt(e);
			}));
		});
		var gs = new GramSchmidt(b);

		function sizeReduceVectorK(k) {

			for (var j = k - 1; j >= 0; j -= 1) {
				var mu_k_j = gs.mu(k, j);
				if (Math.abs(mu_k_j.toNumber()) > η) {
					globalThis.reductions += 1;
					var alpha = mu_k_j.round();
					b[k] = b[k].submul(b[j], alpha);
					gs.reduceVector(k, j, alpha);
				}
			}
		}

		globalThis.swaps = 0;
		globalThis.reductions = 0;

		function swapVectorKAndKminusOne(k) {
			var b_k = b[k];
			b[k] = b[k - 1];
			b[k - 1] = b_k;
			gs.swapVectorKAndKminusOne(k);
		}

		var k = 1;
		while (k < b.length) {
			gs.computeUpTo(k);

			sizeReduceVectorK(k);
			if (b[k].isZero()) {

				b.splice(k, 1);

				var old = gs.computedCount;
				gs.computedCount = k;
				console.time('recompute');
				gs.computeUpTo(old - 2);
				console.timeEnd('recompute');
				k = Math.max(k - 1, 1);

				continue;
			}
			var mu_k_km1 = gs.mu(k, k - 1);

			if (gs.squaredNorm(k).divide(gs.squaredNorm(k - 1)).toNumber() < δ - Math.pow(mu_k_km1.toNumber(), 2)) {
				swapVectorKAndKminusOne(k);
				k = Math.max(k - 1, 1);
			} else {
				k = k + 1;
			}
		}

		return b.map(function (vector) {
			return vector.elements;
		});
	}

	LLL.testables = {
		Vector: Vector,
		GramSchmidt: GramSchmidt
	};
	globalThis.LLL = LLL;
}

function FastLLL() {
	var floatTypeSize = 3;
	var floatTypeMaxValue = 9007199254740992.0 * 0.5;
	var floatTypeArray = function (buffer, offset, n) {
		return new Float64Array(buffer, offset, n);
	};
	var wasmCode = typeof Uint8Array !== 'undefined' ? new Uint8Array([0, 97, 115, 109, 1, 0, 0, 0, 1, 24, 3, 96, 3, 127, 127, 127, 1, 124, 96, 4, 127, 127, 127, 124, 0, 96, 5, 127, 127, 127, 124, 124, 1, 127, 2, 15, 1, 3, 101, 110, 118, 6, 109, 101, 109, 111, 114, 121, 2, 0, 0, 3, 4, 3, 0, 1, 2, 7, 44, 3, 7, 100, 111, 116, 83, 105, 109, 100, 0, 0, 10, 97, 100, 100, 109, 117, 108, 83, 105, 109, 100, 0, 1, 17, 97, 100, 100, 109, 117, 108, 67, 104, 101, 99, 107, 101, 100, 83, 105, 109, 100, 0, 2, 10, 204, 4, 3, 140, 2, 3, 4, 123, 2, 127, 2, 124, 32, 2, 32, 2, 65, 8, 111, 107, 34, 7, 65, 0, 74, 4, 124, 3, 64, 32, 0, 253, 0, 4, 0, 32, 1, 253, 0, 4, 0, 253, 242, 1, 32, 5, 253, 240, 1, 33, 5, 32, 0, 253, 0, 4, 16, 32, 1, 253, 0, 4, 16, 253, 242, 1, 32, 6, 253, 240, 1, 33, 6, 32, 0, 253, 0, 4, 32, 32, 1, 253, 0, 4, 32, 253, 242, 1, 32, 4, 253, 240, 1, 33, 4, 32, 0, 253, 0, 4, 48, 32, 1, 253, 0, 4, 48, 253, 242, 1, 32, 3, 253, 240, 1, 33, 3, 32, 0, 65, 64, 107, 33, 0, 32, 1, 65, 64, 107, 33, 1, 32, 8, 65, 8, 106, 34, 8, 32, 7, 72, 13, 0, 11, 32, 5, 32, 4, 253, 240, 1, 33, 4, 32, 6, 32, 3, 253, 240, 1, 33, 3, 32, 2, 65, 0, 72, 4, 64, 65, 0, 32, 4, 253, 11, 4, 0, 65, 16, 32, 3, 253, 11, 4, 0, 11, 32, 4, 32, 3, 253, 240, 1, 34, 3, 253, 33, 0, 32, 3, 253, 33, 1, 160, 5, 68, 0, 0, 0, 0, 0, 0, 0, 0, 11, 33, 9, 3, 64, 32, 2, 32, 7, 74, 4, 64, 32, 0, 43, 3, 0, 32, 1, 43, 3, 0, 162, 32, 10, 160, 33, 10, 32, 0, 65, 8, 106, 33, 0, 32, 1, 65, 8, 106, 33, 1, 32, 7, 65, 1, 106, 33, 7, 12, 1, 11, 11, 32, 9, 32, 10, 160, 11, 135, 1, 2, 2, 127, 1, 123, 32, 2, 32, 2, 65, 2, 111, 107, 33, 4, 32, 3, 253, 20, 33, 6, 3, 64, 32, 4, 32, 5, 74, 4, 64, 32, 0, 32, 6, 32, 1, 253, 0, 4, 0, 253, 242, 1, 32, 0, 253, 0, 4, 0, 253, 240, 1, 253, 11, 4, 0, 32, 0, 65, 16, 106, 33, 0, 32, 1, 65, 16, 106, 33, 1, 32, 5, 65, 2, 106, 33, 5, 12, 1, 11, 11, 3, 64, 32, 2, 32, 4, 74, 4, 64, 32, 0, 32, 3, 32, 1, 43, 3, 0, 162, 32, 0, 43, 3, 0, 160, 57, 3, 0, 32, 0, 65, 8, 106, 33, 0, 32, 1, 65, 8, 106, 33, 1, 32, 4, 65, 1, 106, 33, 4, 12, 1, 11, 11, 11, 178, 1, 3, 2, 127, 3, 123, 1, 124, 32, 2, 32, 2, 65, 2, 111, 107, 33, 5, 32, 3, 253, 20, 33, 7, 32, 4, 253, 20, 33, 8, 3, 64, 32, 5, 32, 6, 74, 4, 64, 32, 7, 32, 1, 253, 0, 4, 0, 253, 242, 1, 32, 0, 253, 0, 4, 0, 253, 240, 1, 34, 9, 253, 236, 1, 32, 8, 253, 76, 253, 83, 4, 64, 32, 6, 15, 11, 32, 0, 32, 9, 253, 11, 4, 0, 32, 0, 65, 16, 106, 33, 0, 32, 1, 65, 16, 106, 33, 1, 32, 6, 65, 2, 106, 33, 6, 12, 1, 11, 11, 3, 64, 32, 2, 32, 5, 74, 4, 64, 32, 3, 32, 1, 43, 3, 0, 162, 32, 0, 43, 3, 0, 160, 34, 10, 153, 32, 4, 102, 4, 64, 32, 5, 15, 11, 32, 0, 32, 10, 57, 3, 0, 32, 0, 65, 8, 106, 33, 0, 32, 1, 65, 8, 106, 33, 1, 32, 5, 65, 1, 106, 33, 5, 12, 1, 11, 11, 32, 2, 11]) : null;

	var memory = null;
	var wasmDot = null;
	var wasmAddmul = null;
	var wasmAddmulChecked = null;

	try {
		memory = new WebAssembly.Memory({initial: 0});
		var wasmModule = new WebAssembly.Module(wasmCode)
		var exports = new WebAssembly.Instance(wasmModule, {env: {memory: memory}}).exports;
		wasmDot = exports.dotSimd;
		wasmAddmul = exports.addmulSimd;
		wasmAddmulChecked = exports.addmulCheckedSimd;
	} catch (error) {
		console.log(error);
	}

	var byteOffset = 0;

	function align(n) {
		var r = (1 << (4 - floatTypeSize));
		n = n + (n % r !== 0 ? r - n % r : 0);
		return n;
	}

	function createArray(n) {

		var offset = byteOffset;
		byteOffset += align(n) << floatTypeSize;
		return floatTypeArray(memory.buffer, offset, n).fill(0.0);
	}

	function IntVector(isBig, fpComputed, bigint, fp) {
		this.isBig = isBig;
		this.bigint = bigint;
		this.fpComputed = fpComputed;
		this.fp = fp;
	}

	IntVector.prototype._computeBigint = function () {
		if (this.bigint == null) {
			var fp = this.fp;
			var n = fp.length;
			var a = new Array(n);
			for (var i = 0; i < n; i += 1) {
				a[i] = BigInt(fp[i]);
			}
			this.bigint = a;
		}
	};
	IntVector.prototype._computeFp = function () {
		if (!this.fpComputed) {
			var big = false;
			var fp = this.fp;
			var bigint = this.bigint;
			var n = bigint.length;
			for (var i = 0; i < n; i += 1) {
				var v = -0.0 + Number(bigint[i]);
				fp[i] = v;
				if (Math.abs(v) >= floatTypeMaxValue) {
					big = true;
				}
			}
			this.isBig = big;
			this.fpComputed = true;
		}
	};
	IntVector.prototype.fastDot = function (other) {
		this._computeFp();
		var n = Math.min(this.fp.length, other.fp.length);
		return dot(this.fp, other.fp, n);
	};
	IntVector.prototype.isZero = function () {
		this._computeFp();
		var a = this.fp;
		var n = a.length;
		for (var i = 0; i < n; i += 1) {
			if (a[i] !== -0.0) {
				return false;
			}
		}
		return true;
	};
	IntVector.prototype.dot = function (other) {
		this._computeBigint();
		var a = this.bigint;
		other._computeBigint();
		var b = other.bigint;
		var s = BigInt(0);
		var n = Math.min(a.length, b.length);
		for (var i = 0; i < n; i += 1) {
			s += a[i] * b[i];
		}
		return s;
	};
	IntVector.prototype.addmul = function (other, scale) {
		if (!this.isBig && !other.isBig) {
			var S = -0.0 + Number(scale);
			var a = this.fp;
			var b = other.fp;
			var n = Math.min(a.length, b.length);
			var k = addmulChecked(a, b, n, S, floatTypeMaxValue);
			this.bigint = null;
			if (k !== n) {
				console.warn('overflow');
				var c = new Array(n);
				for (var i = 0; i < k; i += 1) {
					c[i] = BigInt(a[i]);
				}
				var s = BigInt(S);
				for (var i = k; i < n; i += 1) {
					c[i] = BigInt(a[i]) + s * BigInt(b[i]);
				}
				this.isBig = true;
				this.bigint = c;
				this.fpComputed = false;
			}
		} else {
			this._computeBigint();
			var a = this.bigint;
			other._computeBigint();
			var b = other.bigint;
			var n = Math.min(a.length, b.length);
			var c = new Array(n);
			var S = BigInt(scale);
			for (var i = 0; i < n; i += 1) {
				c[i] = a[i] + S * b[i];
			}
			this.isBig = true;
			this.bigint = c;
			this.fpComputed = false;
		}
	};
	IntVector.prototype.toArray = function () {
		return Array.from(!this.isBig ? this.fp : this.bigint);
	};
	IntVector.from = function (elements, fpStorage) {
		for (var i = 0; i < elements.length; i += 1) {
			fpStorage[i] = -0.0 + Number(elements[i]);
		}
		for (var i = 0; i < elements.length; i += 1) {
			var e = fpStorage[i];
			if (Math.abs(e) >= floatTypeMaxValue) {
				console.warn('overflow');
				var bigintStorage = new Array(elements.length);
				for (var i = 0; i < elements.length; i += 1) {
					bigintStorage[i] = BigInt(elements[i]);
				}
				return new IntVector(true, true, bigintStorage, fpStorage);
			}
		}
		return new IntVector(false, true, null, fpStorage);
	};

	function jsDot(a, b, n) {
		var s = -0.0;
		for (var i = 0; i < n; i += 1) {
			s += a[i] * b[i];
		}
		return s;
	}

	function jsAddmul(a, b, n, alpha) {
		for (var i = 0; i < n; i += 1) {
			a[i] = a[i] + alpha * b[i];
		}
	}

	function jsAddmulChecked(a, b, n, S, B) {
		for (var i = 0; i < n; i += 1) {
			var x = a[i] + S * b[i];
			if (Math.abs(x) >= B) {
				return i;
			}
			a[i] = x;
		}
		return n;
	}

	function dot(a, b, n) {
		if (wasmDot != null) {
			return wasmDot(a.byteOffset, b.byteOffset, n);
		}
		return jsDot(a, b, n);
	}

	function addmulChecked(a, b, n, S, B) {
		if (wasmAddmulChecked != null) {
			return wasmAddmulChecked(a.byteOffset, b.byteOffset, n, S, B);
		}
		return jsAddmulChecked(a, b, n, S, B);
	}

	function addmul(a, b, n, alpha) {
		if (wasmAddmul != null) {
			wasmAddmul(a.byteOffset, b.byteOffset, n, alpha);
		} else {
			jsAddmul(a, b, n, alpha);
		}
	}

	function SWAP_GRAM(G, k, computedGRows) {
		for (var j = 0; j < k - 1; j += 1) {
			var tmp = G[k][j];
			G[k][j] = G[k - 1][j];
			G[k - 1][j] = tmp;
		}

		var tmp = G[k][k];
		G[k][k] = G[k - 1][k - 1];
		G[k - 1][k - 1] = tmp;
		for (var j = k + 1; j < computedGRows; j += 1) {
			var tmp = G[j][k];
			G[j][k] = G[j][k - 1];
			G[j][k - 1] = tmp;
		}
	}

	globalThis.dotC = 0;
	globalThis.subs = 0;
	globalThis.checks1 = 0;
	globalThis.checks2 = 0;
	globalThis.swaps = 0;

	function l3fp(latticeBasis, δ, η) {
		δ = δ == undefined ? 0.99 : δ;
		η = η == undefined ? 0.51 : η;

		byteOffset = 0;
		var memorySize = (latticeBasis.length * align(latticeBasis[0].length) + latticeBasis.length * align(latticeBasis.length) + align(latticeBasis.length)) * (1 << floatTypeSize);
		if (memory.buffer.byteLength < memorySize) {
			memory.grow(Math.ceil((memorySize - memory.buffer.byteLength) / (64 * 1024)));
		}

		var b = latticeBasis.map(function (array) {
			return IntVector.from(array, createArray(array.length));
		});

		var m = b.length;
		var k = 1;
		var mu = new Array(m).fill(null).map(function (x) {
			return createArray(m);
		});
		for (var i = 0; i < m; i += 1) {
			mu[i][i] = 1.0;
		}

		var c = new Array(m).fill(-0.0);
		var fpbb = new Array(m).fill(-0.0);
		var fpG = new Array(m).fill(null).map(function (x) {
			return new Array(m).fill(0 / 0);
		});
		var computedGRows = 0;

		var recomputeOnChanged = true;

		for (var i = 0; i < m; i += 1) {
			fpbb[i] = b[i].fastDot(b[i]);
		}

		var cmu_k = createArray(m);

		function computeMuKJ() {
			computedGRows = Math.max(computedGRows, k + 1);

			var c_k = fpbb[k];
			if (k === 1) {
				c[0] = fpbb[0];
			}

			for (var j = 0; j < k; j += 1) {
				var s = fpG[k][j];
				if (s !== s) {
					s = b[k].fastDot(b[j]);
					globalThis.dotC += 1;
					var y = Math.sqrt(fpbb[k]) * Math.sqrt(fpbb[j]);
					if (Math.abs(s) === 1 / 0) {
						console.warn('?');
					}

					if (y >= (floatTypeSize === 3 ? Math.pow(2, 53) : Math.pow(2, 24)) && Math.abs(s) < (floatTypeSize === 3 ? Math.pow(2, -53 / 2 + 33 / 2) : Math.pow(2, -24 / 2 + 7 / 2)) * y) {
						s = -0.0 + Number(b[k].dot(b[j]));
						globalThis.checks2 += 1;
					}
					fpG[k][j] = s;
				}

				s = s - dot(mu[j], cmu_k, j);

				cmu_k[j] = s;
				mu[k][j] = s / c[j];
				c_k = c_k - s * (s / c[j]);
			}
			c[k] = c_k;
		}

		function sizeReduceBK() {
			var b_k_changed = false;
			for (var j = k - 1; j >= 0; j -= 1) {

				var x = mu[k][j];
				if (Math.abs(x) > η) {
					var alpha = -0.0 + Math.ceil(Math.abs(x) <= Math.pow(2, 52) ? x - 0.5 : x);
					addmul(mu[k], mu[j], j + 1, -alpha);
					b[k].addmul(b[j], -alpha);
					globalThis.subs += 1;
					b_k_changed = true;
				}
			}
			if (b_k_changed) {
				fpbb[k] = b[k].fastDot(b[k]);
				for (var i = 0; i <= k; i += 1) {
					fpG[k][i] = 0 / 0;
				}
				for (var i = k + 1; i < computedGRows; i += 1) {
					fpG[i][k] = 0 / 0;
				}
			}
			return b_k_changed;
		}

		var c1 = 0;
		while (k < m) {
			c1 += 1;
			if (c1 > 10) {

				console.warn('It does not work!');
				k = m;
				continue;
			}

			computeMuKJ();
			var b_k_changed = sizeReduceBK();
			if (b[k].isZero()) {

				console.warn('splice');
				b.splice(k, 1);
				fpbb.splice(k, 1);
				for (var i = 0; i < m; i += 1) {
					fpG[i].splice(k, 1);
				}
				fpG.splice(k, 1);
				m -= 1;
				computedGRows = Math.min(computedGRows, m);

				k = Math.max(k - 1, 1);
				continue;
			}
			if (recomputeOnChanged && b_k_changed) {
				k = k;
				continue;
			}
			c1 = 0;
			if (δ * c[k - 1] > c[k] + mu[k][k - 1] * mu[k][k - 1] * c[k - 1]) {
				globalThis.swaps += 1;

				var b_k = b[k];
				b[k] = b[k - 1];
				b[k - 1] = b_k;

				var fpbb_k = fpbb[k];
				fpbb[k] = fpbb[k - 1];
				fpbb[k - 1] = fpbb_k;

				SWAP_GRAM(fpG, k, computedGRows);

				k = Math.max(k - 1, 1);
			} else {
				k = k + 1;
			}
		}
		return b.map(function (v) {
			return v.toArray();
		});
	}

	globalThis.l3fp = l3fp;
}

function PolynomialFactorization() {
	function toInt(c, p) {
		if (p instanceof Expression.Integer || p instanceof Expression.Polynomial) {
			return Expression.Integer.fromBigInt(c);
		}
		return c;
	}

	function fromInt(c) {
		if (c instanceof Expression.Integer || c instanceof Expression.Polynomial) {
			return c;
		}
		return Expression.Integer.fromBigInt(c);
	}

	function toIntPolynomial(f, p) {
		if (p instanceof Expression.Integer) {
			return f.mod(p);
		}
		var ep = Expression.Integer.fromBigInt(p);
		var coefficients = new Array(f.getDegree() + 1).fill(-0.0);
		for (var i = 0; i < f.a.coefficients.length; i += 1) {
			coefficients[f.a.degree(i)] = f.a.coefficient(i).modulo(ep).toNumber();
		}
		return IntPolynomial.from(coefficients);
	}

	function fromIntPolynomial(f) {
		var coefficients = new Array(f.getDegree() + 1);
		for (var i = 0; i < coefficients.length; i += 1) {
			coefficients[i] = Expression.Integer.fromNumber(f.getCoefficient(i));
		}
		return Polynomial.from(coefficients);
	}

	var isPrime = primeFactor._isPrime;

	function ExtendedEuclideanAlgorithm(a, b, p) {

		a = a.mod(p);
		b = b.mod(p);

		var ZERO = Polynomial.of(Expression.ZERO);
		var ONE = Polynomial.of(p.divide(p));
		var A = ONE;
		var B = ZERO;
		var C = ZERO;
		var D = ONE;
		while (b.getDegree() >= 0) {
			var multiplier = b.getLeadingCoefficient().modInverse(p);
			b = b.scale(multiplier).mod(p);
			C = C.scale(multiplier).mod(p);
			D = D.scale(multiplier).mod(p);
			var tmp = a.divideAndRemainderModP(b, p);
			var q = tmp.quotient;
			var r = tmp.remainder;
			a = b;
			b = r;
			var C1 = A.subtract(C.multiply(q)).mod(p);
			var D1 = B.subtract(D.multiply(q)).mod(p);
			A = C;
			B = D;
			C = C1;
			D = D1;
		}
		var k = a.getLeadingCoefficient().modInverse(p);
		var gcd = a.scale(k).mod(p);
		var U = A.scale(k).mod(p);
		var V = B.scale(k).mod(p);

		return {
			U: U,
			V: V,
			gcd: gcd
		};
	}

	function multipleGCDs(hs, fStar, q) {
		var one = fStar.constructor.from([toInt(1, q)]);
		var fStarInv = IntPolynomial._barrettPreinvert(fStar, q);
		var hp = one;
		var hps = new Array(hs.length);
		for (var i = 0; i < hs.length; i += 1) {
			var h = hs[i];
			hp = hp.multiply(h).mod(q);

			hp = IntPolynomial._barrettReduce(hp, fStar, fStarInv, q);
			hps[i] = hp;
		}
		var gg = IntPolynomial.gcd(fStar, hp, q);
		var gcds = new Array(hs.length);
		for (var j = hs.length - 1; j >= 0; j -= 1) {
			if (gg.getDegree() !== 0) {
				var gg1 = j === 0 ? one : IntPolynomial.gcd(gg, hps[j - 1], q);
				gcds[j] = gg.divideAndRemainderModP(gg1, q).quotient;
				gg = gg1;
			} else {
				gcds[j] = one;
			}
		}
		return gcds;
	}

	function distinctDegreeFactorization(f, p) {
		f = f.mod(p);

		var S = [];
		var fStar = f;
		fStar = toMonic(fStar, p);
		var q = p;
		var x = f.constructor.from([toInt(1, p)]).shift(1);
		var i = 0;
		var xInQInI = x;

		var hs = [];
		var step = 7;

		while (fStar.getDegree() >= 2 * i) {
			xInQInI = IntPolynomial.modPow(xInQInI, fromInt(q), fStar, q);
			var h = xInQInI.subtract(x).divideAndRemainderModP(fStar, q).remainder;
			i += 1;

			var gcds = [];
			if (step !== 1) {
				hs.push(h);
				if (i % step === 0 || fStar.getDegree() < 2 * i) {
					gcds = multipleGCDs(hs, fStar, q);
					hs.length = 0;
				}
			} else {
				gcds.push(IntPolynomial.gcd(fStar, h, q));
			}

			for (var j = 0; j < gcds.length; j += 1) {
				var g = gcds[j];
				var d = i - (gcds.length - 1) + j;
				if (g.getDegree() !== 0) {
					S.push({
						factor: g,
						degree: d
					});
					fStar = fStar.divideAndRemainderModP(g, q).quotient;
				}
			}

		}
		if (fStar.getDegree() > 0) {
			S.push({
				factor: fStar,
				degree: fStar.getDegree()
			});
		}
		if (S.length === 0) {
			S.push({
				factor: f,
				degree: 1
			});
		}
		return S;
	}

	function randomBigInt0(size, random) {
		random = random == undefined ? Math.random : random;

		console.assert(Math.floor(size) === size);
		if (size <= 52) {
			return Math.floor(random() * Math.pow(2, size));
		}
		var q = Math.ceil(size / (2 * 52)) * 52;
		return (BigInt(randomBigInt0(size - q, random)) << BigInt(q)) + BigInt(randomBigInt0(q, random));
	}

	function randomBigInt(max, random) {
		random = random == undefined ? Math.random : random;

		if (Number(max) <= Math.pow(2, 52)) {
			return Math.floor(random() * Number(max));
		}
		var size = Expression.Integer.fromBigInt(max).bitLength();
		return (BigInt(randomBigInt0(size, random)) * BigInt(max)) >> BigInt(size);
	}

	function CantorZassenhausAlgorithm(f, p, factorsDegree) {
		f = f.mod(p);
		f = toMonic(f, p);

		var q = p;
		if (f.getDegree() === factorsDegree) {
			return [f];
		}
		var random = Math.seedrandom != null ? new Math.seedrandom('hello.') : Math.random;

		while (true) {
			var h = f.constructor.from(new Array(f.getDegree()).fill(q).map(function (q) {
				return toInt(randomBigInt(fromInt(q).toBigInt(), random), q);
			}));
			var ONE = f.constructor.from([toInt(1, p)]);
			var qInDminusOneOverTwo = (fromInt(q)._pow(factorsDegree).subtract(Expression.ONE)).truncatingDivide(Expression.TWO);

			var g = IntPolynomial.modPow(h, qInDminusOneOverTwo, f, q).subtract(ONE).divideAndRemainderModP(f, q).remainder;
			var gcd = IntPolynomial.gcd(g, f, q);
			if (gcd.getDegree() !== 0 && gcd.getDegree() !== f.getDegree()) {
				var f1 = gcd;
				var f2 = f.divideAndRemainderModP(gcd, q).quotient;
				return CantorZassenhausAlgorithm(f1, p, factorsDegree).concat(CantorZassenhausAlgorithm(f2, p, factorsDegree));
			}
		}
	}

	function factorizeOverTheFiniteField(f, p) {
		if (!isFactorizationOverZpSquareFree(f, p)) {
			throw new RangeError("implemented only for square-free polynomials");
		}
		var factorization = [];
		var distinctDegreeFactors = distinctDegreeFactorization(f, p);
		for (var iteratorddf = distinctDegreeFactors[globalThis.Symbol.iterator](), ddf = iteratorddf.next().value; ddf != null; ddf = iteratorddf.next().value) {
			var equalDegreeFactors = CantorZassenhausAlgorithm(ddf.factor, p, ddf.degree);
			factorization = factorization.concat(equalDegreeFactors);
		}
		return factorization;
	}

	function toMonic(f, p) {
		if (f.getDegree() < 0) {
			return f;
		}
		var scale = toInt(fromInt(f.getLeadingCoefficient()).modInverse(fromInt(p)).toBigInt(), p);
		return f.scale(scale).mod(p);
	}

	function isFactorizationOverZpSquareFree(u, prime) {
		var f = u;
		return IntPolynomial.gcd(f, f.derive().mod(prime), prime).getDegree() === 0;
	}

	function AsmModule(stdlib, imports, heap) {
		"use asm";

		var combination = new stdlib.Int16Array(heap);
		var heap32 = new stdlib.Int32Array(heap);
		var heap8 = new stdlib.Int8Array(heap);

		function nextFilteredOutCombination(n, k, B1, B2, oracleBits, oracleDepth, oracleParam) {
			n = n | 0;
			k = k | 0;
			B1 = B1 | 0;
			B2 = B2 | 0;
			oracleBits = oracleBits | 0;
			oracleDepth = oracleDepth | 0;
			oracleParam = oracleParam | 0;
			var twoB1 = 0;
			var twoB2 = 0;
			var depth = 0;
			var j = 0;
			var oracleIndex = 0;
			var x1 = 0;
			var x2 = 0;
			var trace1base = 0;
			var trace2base = 0;
			var trace1 = 0;
			var trace2 = 0;
			var c0 = 0;
			var c1 = 0;

			var lastTraces1 = 0;
			var factorsTraces1 = 0;
			var lastTraces2 = 0;
			var factorsTraces2 = 0;
			var oracleTable = 0;
			var counters = 0;

			lastTraces1 = (1 * n) | 0;
			factorsTraces1 = (2 * n) | 0;
			lastTraces2 = (3 * n) | 0;
			factorsTraces2 = (4 * n) | 0;
			counters = (5 * n) | 0;
			oracleTable = ((5 * n + 2) | 0) << 2;

			heap32[lastTraces1 << 2 >> 2] = B1;
			heap32[lastTraces2 << 2 >> 2] = B2;
			twoB1 = (B1 >>> 0) >= (((-1) - B1) >>> 0) ? (-1) : (B1 + B1) | 0;
			twoB2 = (B2 >>> 0) >= (((-1) - B2) >>> 0) ? (-1) : (B2 + B2) | 0;

			while ((combination[0 << 1 >> 1] | 0) != ((n - k) | 0)) {
				depth = (k - 1) | 0;
				while ((combination[(depth) << 1 >> 1] | 0) == ((n - k + depth) | 0)) {
					depth = (depth - 1) | 0;
				}
				j = combination[(depth) << 1 >> 1] | 0;
				trace1base = heap32[(lastTraces1 + depth) << 2 >> 2] | 0;
				trace2base = heap32[(lastTraces2 + depth) << 2 >> 2] | 0;
				while ((depth | 0) < ((k - 1 - oracleDepth) | 0)) {
					j = (j + 1) | 0;
					trace1base = (trace1base + (heap32[(factorsTraces1 + j) << 2 >> 2] | 0)) | 0;
					trace2base = (trace2base + (heap32[(factorsTraces2 + j) << 2 >> 2] | 0)) | 0;
					combination[(depth) << 1 >> 1] = j;
					depth = (depth + 1) | 0;
					heap32[(lastTraces1 + depth) << 2 >> 2] = trace1base;
					heap32[(lastTraces2 + depth) << 2 >> 2] = trace2base;
				}
				if ((depth | 0) < ((k - 1) | 0)) {
					do {
						do {
							j = (j + 1) | 0;
							x1 = (trace1base + (heap32[(factorsTraces1 + j) << 2 >> 2] | 0)) | 0;
							oracleIndex = ((k - depth - 2) << oracleBits) | (x1 >>> (32 - oracleBits));
							if (((heap8[(oracleTable + oracleIndex) | 0] | 0) > ((j + 1) | 0))) {
								x2 = (trace2base + (heap32[(factorsTraces2 + j) << 2 >> 2] | 0)) | 0;
								oracleIndex = ((k - depth - 2) << oracleBits) | (x2 >>> (32 - oracleBits));
								if ((heap8[(oracleTable + ((oracleParam + 1) << oracleBits) + oracleIndex) | 0] | 0) > ((j + 1) | 0)) {
									break;
								}
							}
						} while ((j | 0) < ((n - (k - depth)) | 0));
						trace1base = x1;
						trace2base = x2;
						combination[(depth) << 1 >> 1] = j;
						depth = (depth + 1) | 0;
						heap32[(lastTraces1 + depth) << 2 >> 2] = trace1base;
						heap32[(lastTraces2 + depth) << 2 >> 2] = trace2base;
					} while ((depth | 0) < ((k - 1) | 0));
				}

				c0 = (c0 + (n - 1 - j)) | 0;
				while ((j | 0) < ((n - 1) | 0)) {
					j = (j + 1) | 0;

					trace1 = (trace1base + (heap32[(factorsTraces1 + j) << 2 >> 2] | 0)) | 0;
					if ((trace1 >>> 0) > (twoB1 >>> 0)) {
						continue;
					}
					c1 = (c1 + 1) | 0;

					trace2 = (trace2base + (heap32[(factorsTraces2 + j) << 2 >> 2] | 0)) | 0;
					if ((trace2 >>> 0) > (twoB2 >>> 0)) {
						continue;
					}

					combination[(k - 1) << 1 >> 1] = j;
					heap32[(counters + 0) << 2 >> 2] = c0;
					heap32[(counters + 1) << 2 >> 2] = c1;
					return 1;
				}
				combination[(k - 1) << 1 >> 1] = (n - 1) | 0;
				if ((c0 >>> 0) > (8388608 >>> 4)) {
					heap32[(counters + 0) << 2 >> 2] = c0;
					heap32[(counters + 1) << 2 >> 2] = c1;
					return 1;
				}
			}
			heap32[(counters + 0) << 2 >> 2] = c0;
			heap32[(counters + 1) << 2 >> 2] = c1;
			return 0;
		}

		function buildOracleTable(n, B1, B2, oracleBits, k, oracleParam) {
			n = n | 0;
			B1 = B1 | 0;
			B2 = B2 | 0;
			oracleBits = oracleBits | 0;
			k = k | 0;
			oracleParam = oracleParam | 0;
			var E = 0;
			var depth = 0;
			var lastTraces1 = 0;
			var factorsTraces1 = 0;
			var lastTraces2 = 0;
			var factorsTraces2 = 0;
			var oracleTable = 0;
			var j = 0;
			var trace1base = 0;
			var trace2base = 0;
			var i = 0;
			var s = 0;
			var trace1 = 0;
			var trace2 = 0;
			var x = 0;
			var oracleIndex = 0;
			var twoB1 = 0;
			var twoB2 = 0;
			var twoB1plusE = 0;
			var twoB2plusE = 0;

			E = (1 << (32 - oracleBits));
			lastTraces1 = (1 * n) | 0;
			factorsTraces1 = (2 * n) | 0;
			lastTraces2 = (3 * n) | 0;
			factorsTraces2 = (4 * n) | 0;
			oracleTable = ((5 * n + 2) | 0) << 2;

			for (i = 0; (i | 0) < (k | 0); i = (i + 1) | 0) {
				combination[(i) << 1 >> 1] = (n - k + i) | 0;
			}
			combination[0 << 1 >> 1] = n - oracleParam - 1;
			heap32[lastTraces1 << 2 >> 2] = (B1 + E) | 0;
			heap32[lastTraces2 << 2 >> 2] = (B2 + E) | 0;

			twoB1 = (B1 >>> 0) >= (((-1) - B1) >>> 0) ? (-1) : (B1 + B1) | 0;
			twoB2 = (B2 >>> 0) >= (((-1) - B2) >>> 0) ? (-1) : (B2 + B2) | 0;
			twoB1plusE = (twoB1 >>> 0) >= (((-1) - E) >>> 0) ? (-1) : (twoB1 + E) | 0;
			twoB2plusE = (twoB2 >>> 0) >= (((-1) - E) >>> 0) ? (-1) : (twoB2 + E) | 0;

			while ((combination[0 << 1 >> 1] | 0) != ((n - k) | 0)) {
				depth = (k - 1) | 0;
				while ((combination[(depth) << 1 >> 1] | 0) == ((n - k + depth) | 0)) {
					depth = (depth - 1) | 0;
				}
				j = combination[depth << 1 >> 1] | 0;
				trace1base = (heap32[(lastTraces1 + depth) << 2 >> 2] | 0);
				trace2base = (heap32[(lastTraces2 + depth) << 2 >> 2] | 0);
				while ((depth | 0) < ((k - 1) | 0)) {
					j = (j + 1) | 0;
					trace1base = (trace1base + (heap32[(factorsTraces1 + j) << 2 >> 2] | 0)) | 0;
					trace2base = (trace2base + (heap32[(factorsTraces2 + j) << 2 >> 2] | 0)) | 0;
					combination[(depth) << 1 >> 1] = j;
					depth = (depth + 1) | 0;
					heap32[(lastTraces1 + depth) << 2 >> 2] = trace1base;
					heap32[(lastTraces2 + depth) << 2 >> 2] = trace2base;
				}
				while ((j | 0) < ((n - 1) | 0)) {
					j = (j + 1) | 0;
					combination[(k - 1) << 1 >> 1] = j;
					trace1 = (trace1base + (heap32[(factorsTraces1 + j) << 2 >> 2] | 0)) | 0;
					for (s = 0; (s | 0) < (1 << oracleBits); s = (s + 1) | 0) {
						x = (trace1 + (s << (32 - oracleBits))) | 0;
						if ((x >>> 0) <= (twoB1plusE >>> 0)) {
							oracleIndex = ((k - 1) << oracleBits) | s;

							heap8[(oracleTable + oracleIndex) | 0] = ((combination[0 << 1 >> 1] | 0) + 1) | 0;
						} else {
							s = (s + ((-1 - x) >>> (32 - oracleBits))) | 0;
						}
					}
					trace2 = (trace2base + (heap32[(factorsTraces2 + j) << 2 >> 2] | 0)) | 0;
					for (s = 0; (s | 0) < (1 << oracleBits); s = (s + 1) | 0) {
						x = (trace2 + (s << (32 - oracleBits))) | 0;
						if ((x >>> 0) <= (twoB2plusE >>> 0)) {
							oracleIndex = ((k - 1) << oracleBits) | s;

							heap8[(oracleTable + ((oracleParam + 1) << oracleBits) + oracleIndex) | 0] = ((combination[0 << 1 >> 1] | 0) + 1) | 0;
						} else {
							s = (s + ((-1 - x) >>> (32 - oracleBits))) | 0;
						}
					}
				}
			}
			return 0;
		}

		return {
			nextFilteredOutCombination: nextFilteredOutCombination,
			buildOracleTable: buildOracleTable
		};
	}

	function choosePrime(u, prime, tryMultiplePrimes) {
		var nextGoodPrime = function (integer) {
			var p = integer;
			var pp = p;
			do {
				do {
					p = Expression.Integer.fromBigInt(p).add(Expression.TWO).toBigInt();
				} while (!isPrime(p));
				if (typeof p !== 'number') {
					pp = Expression.Integer.fromBigInt(p);
				} else {
					pp = p;
				}
			} while (u.getLeadingCoefficient().remainder(Expression.Integer.fromBigInt(p)).equals(Expression.ZERO) || !isFactorizationOverZpSquareFree(toIntPolynomial(u, pp), pp));
			return pp;
		};
		prime = nextGoodPrime(prime);
		if (!tryMultiplePrimes) {
			return {
				prime: prime,
				possibleDegreesFilter: undefined
			};
		}

		var hasBigInt = globalThis.BigInt != undefined && typeof BigInt(0) === 'bigint';
		var possibleDegreesFilter = undefined;
		var bestFactorsNumber = 1 / 0;
		var best = prime;
		for (var tries = 0; tries < (bestFactorsNumber > 30 || bestFactorsNumber > 15 && u.getDegree() < 900 ? 7 : 3) && bestFactorsNumber > 1; tries += 1) {
			var factorsNumber = 0;
			var ddfs = distinctDegreeFactorization(toIntPolynomial(u, prime), prime);

			var possibleDegrees = hasBigInt ? BigInt(1) : 1;
			for (var iteratorentry = ddfs[globalThis.Symbol.iterator](), entry = iteratorentry.next().value; entry != null; entry = iteratorentry.next().value) {
				console.assert((entry.factor.getDegree() % entry.degree) === 0);
				var count = (entry.factor.getDegree() / entry.degree);
				factorsNumber += count;
				if (hasBigInt) {
					for (var i = 0; i < count; i += 1) {
						possibleDegrees = possibleDegrees | (possibleDegrees << BigInt(entry.degree));
					}
				}
			}
			if (hasBigInt) {
				if (possibleDegreesFilter == undefined) {
					possibleDegreesFilter = possibleDegrees;
				} else {
					possibleDegreesFilter = possibleDegreesFilter & possibleDegrees;
				}
				if (possibleDegreesFilter === ((BigInt(1) << BigInt(u.getDegree())) | BigInt(1))) {
					return null;
				}
			}

			if (bestFactorsNumber > factorsNumber) {
				best = prime;
				bestFactorsNumber = factorsNumber;

			}
			prime = nextGoodPrime(prime);
		}
		return {
			prime: best,
			possibleDegreesFilter: possibleDegreesFilter
		};
	}

	function factorizeOverTheIntegers(u, useHenselLifting, checkSpecialCases) {
		useHenselLifting = useHenselLifting == undefined ? true : useHenselLifting;
		checkSpecialCases = checkSpecialCases == undefined ? true : checkSpecialCases;

		if (!useHenselLifting) {
			throw new RangeError('deprecated');
		}
		var polynomial = u;
		var factorsIterator1 = null;
		var factorsIterator2 = null;
		var results1 = null;
		var results2 = null;
		var checkBothVariants = true;
		var prime = 0;
		var factors = null;
		var e = null;
		var q = null;
		var c = 0;
		var c0 = 0;
		var c1 = 0;
		var c2 = 0;
		var c3 = 0;
		var c4 = 0;
		var c5 = 0;
		var c6 = 0;
		var countOfFactors = 1;
		var possibleDegreesFilter = undefined;
		var iterator = {
			next: function () {
				if (u.getDegree() === 0) {
					return {
						value: null,
						done: true
					};
				}
				while (u.getDegree() > 1 && u.getCoefficient(0).equals(Expression.ZERO)) {
					var factor = Polynomial.of(Expression.ZERO, Expression.ONE);
					u = u.divideAndRemainder(factor, "throw").quotient;
					return {
						value: factor,
						done: false
					};
				}
				if (u.getDegree() === 1) {

					var factor = u;
					u = u.divideAndRemainder(factor, "throw").quotient;
					return {
						value: factor,
						done: false
					};
				}
				if (u.getCoefficient(0).abs().bitLength() - u.getLeadingCoefficient().abs().bitLength() < -42) {
					if (factorsIterator1 == null) {
						factorsIterator1 = factorizeOverTheIntegers(u._exponentiateRoots(-1), useHenselLifting);
					}
					var factor = factorsIterator1.next().value;
					if (factor != null) {
						var f = factor._exponentiateRoots(-1);
						return {
							value: f,
							done: false
						};
					}
					return {
						value: null,
						done: true
					};
				}
				if (checkSpecialCases && u.isEven() && polynomial.getDegree() >= 4) {
					if (factorsIterator2 == null) {
						factorsIterator2 = factorizeOverTheIntegers(u._exponentiateRoots(2), useHenselLifting);
					}
					var factor = factorsIterator2.next().value;
					if (factor != null) {
						var f = factor._exponentiateRoots(1 / 2);
						u = u.divideAndRemainder(f, "throw").quotient;
						return {
							value: f,
							done: false
						};
					}

				}

				function MignotteFactorBound(p) {

					return p.getDegree() + p._log2hypot();
				}

				function MignotteSingleFactorBound(p) {
					return MignotteFactorBound(p) * 0.5;
				}

				var getBound = function (p) {
					if (checkBothVariants) {
						return MignotteSingleFactorBound(p);
					}
					return MignotteFactorBound(p);
				};

				var useRationalReconstruction = false;
				var rationalReconstructionParam = Expression.TWO.leftShift(Math.ceil(getBound(u)));

				if (factors == null) {
					var B = useRationalReconstruction ? 1 + rationalReconstructionParam.bitLength() * 2 : 1 + getBound(u.scale(u.getLeadingCoefficient().abs()));
					if (!useHenselLifting) {
						var tmp = choosePrime(u, Expression.TWO._pow(Math.ceil(B)).add(Expression.ONE).toBigInt(), false);
						prime = tmp.prime;
						possibleDegreesFilter = tmp.possibleDegreesFilter;
					} else {
						var tmp = choosePrime(u, 1, true);
						if (tmp == null) {
							if (u.getDegree() >= 16) {
								console.log('irreducible', u.toString());
							}
							return {
								value: null,
								done: true
							};
						}
						prime = tmp.prime;
						possibleDegreesFilter = tmp.possibleDegreesFilter;
					}
					factors = factorizeOverTheFiniteField(toIntPolynomial(u, prime), prime).map(function (factor) {
						return useHenselLifting ? fromIntPolynomial(factor) : factor;
					});

					if (useHenselLifting) {

						e = Math.ceil(B / Math.log2(prime));

						factors = HenselLiftingNonMonic(u, factors, prime, e);

						factors.sort(function (f1, f2) {
							return (f1.getDegree() - f2.getDegree()) || f1.getCoefficient(f1.getDegree() - 1).compareTo(f2.getCoefficient(f2.getDegree() - 1));
						});
						q = Expression.Integer.fromNumber(prime)._pow(e);
					} else {
						q = prime;
					}
				}

				var useKnapsack = ((u.getLeadingCoefficient().equals(Expression.ONE) && factors.length >= 9) || (typeof ArrayBuffer == 'undefined')) && useHenselLifting;
				if (useKnapsack) {

					if (results2 == null) {
						results2 = knapsackFactorization(u, factors, prime, e, u.getLeadingCoefficient());
						results2.sort(function (a, b) {
							return b.getDegree() - a.getDegree();
						});
						if (results2.length === 1) {
							if (!u.equals(results2[0])) {
								throw new RangeError();
							}
							return {
								value: null,
								done: true
							};
						}
					}
					if (results2.length > 0) {
						return {
							value: results2.pop(),
							done: false
						};
					}
					return {
						value: null,
						done: true
					};
				}

				if (checkSpecialCases && polynomial.isEven() && polynomial.getDegree() >= 4) {

					if (results1 == null) {
						for (var i = 0; i < factors.length; i += 1) {
							if (factors[i] != null) {
								var f1 = factors[i].mod(q);
								var f2 = factors[i]._scaleRoots(Expression.ONE.negate()).mod(q);
								var found = false;
								for (var j = i + 1; j < factors.length && !found; j += 1) {
									if (factors[j] != null && factors[j].mod(q).equals(f2)) {
										factors[j] = null;
										found = true;
									}
								}
								if (!found) {
									return {
										value: null,
										done: true
									};
								}
							}
						}
						factors = factors.filter(function (f) {
							return f != null;
						});
						for (var i = 0; i < Math.pow(2, factors.length - 1) && results1 == null; i += 1) {
							var combination = factors.map(function (f, index) {
								return Math.floor(i / Math.pow(2, index)) % 2 === 0 ? f : f._scaleRoots(Expression.ONE.negate());
							});
							var ok = true;
							if (true) {
								var lc = u.getLeadingCoefficient();

								var t2 = Expression.ZERO;
								var t1 = Expression.ZERO;
								var t0 = lc;
								for (var iteratorf = combination[globalThis.Symbol.iterator](), f = iteratorf.next().value; f != null; f = iteratorf.next().value) {
									var f2 = f.getCoefficient(2);
									var f1 = f.getCoefficient(1);
									var f0 = f.getCoefficient(0);
									t2 = t2.multiply(f0).add(t1.multiply(f1)).add(t0.multiply(f2)).modulo(q);
									t1 = t1.multiply(f0).add(t0.multiply(f1)).modulo(q);
									t0 = t0.multiply(f0).modulo(q);
								}
								var tail = Polynomial.of(t0, t1, t2).roundMod(q);
								tail = tail.multiply(tail._scaleRoots(Expression.ONE.negate()));
								ok = tail.getCoefficient(2).abs().equals(u.getCoefficient(2).multiply(u.getLeadingCoefficient()).abs());
							}
							if (ok) {
								var candidate = productModQ(combination, q).scale(u.getLeadingCoefficient()).roundMod(q).primitivePart();
								var candidate2 = candidate._scaleRoots(Expression.ONE.negate());
								if (candidate.multiply(candidate2).equals(u)) {
									results1 = [];
									results1.push(candidate);
									results1.push(candidate2);
								}
							}
						}
					}
					if (results1 != null) {
						while (results1.length > 0) {
							return {
								value: results1.pop(),
								done: false
							};
						}
					}
					return {
						value: null,
						done: true
					};
				}

				var lc = u.getLeadingCoefficient();
				var n = factors.length;

				var oracleBits = Math.max(Math.ceil(n / 3) - 1, 1);
				console.log('factors', n);
				var oracleParam = Math.ceil(n / 2) + 2;

				var minSize = n * 5 * 4 + 2 * 4 + (oracleParam + 1) * Math.pow(2, oracleBits) * 2;

				var heap = new ArrayBuffer(Math.max(Math.pow(2, 16), 1 << (32 - Math.clz32(minSize))));
				var exports = AsmModule(globalThis, null, heap);

				var nextFilteredOutCombination = exports.nextFilteredOutCombination;
				var buildOracleTable = exports.buildOracleTable;

				var nonzero = factors.filter(function (f) {
					return !f.getCoefficient(f.getDegree() - 1).equals(Expression.ZERO);
				}).length === 0 ? 1 : 0;
				var traceIndex1 = (u.getLeadingCoefficient().equals(Expression.ONE) ? 2 + nonzero : 1);
				var traceIndex2 = (u.getLeadingCoefficient().equals(Expression.ONE) ? 3 + nonzero : 1);
				var combination = new Int16Array(heap, 0, factors.length);
				var factorsTraces1 = new Int32Array(heap, n * 2 * 4, factors.length);
				var factorsTraces2 = new Int32Array(heap, n * 4 * 4, factors.length);
				var counters = new Int32Array(heap, n * 5 * 4, 2);
				var oracleTable = new Int8Array(heap, n * 5 * 4 + 2 * 4, (oracleParam + 1) * Math.pow(2, oracleBits) * 2);

				var scale = function (x) {
					if (x.compareTo(Expression.ZERO) < 0 || x.compareTo(q) >= 0) {
						throw new RangeError();
					}
					return x.leftShift(32).truncatingDivide(q).toNumber() | 0;
				};

				for (var i = 0; i < factors.length; i += 1) {
					console.assert(factors[i].getCoefficient(factors[i].getDegree() - 1).negate().equals(factors[i].trace(1)));
					console.assert(factors[i].getCoefficient(factors[i].getDegree() - 2).negate().equals(factors[i].trace(1)._pow(2).subtract(factors[i].trace(2)).divide(Expression.TWO).negate()));
					factorsTraces1[i] = scale(lc._pow(traceIndex1).multiply(factors[i].trace(traceIndex1)).modulo(q));
					factorsTraces2[i] = scale(lc._pow(traceIndex2).multiply(factors[i].trace(traceIndex2)).modulo(q));
				}

				var rho = u.getAllRootsBound();
				var scale2 = function (x, a) {
					if (x.compareTo(q) >= 0) {
						return -1;
					}
					var y = scale(x);
					if ((y >>> 0) >= (((Math.pow(2, 32) - 1) - a) >>> 0)) {
						return -1;
					}
					return (y + a) | 0;
				};
				var coefficientBound = function (i) {
					if (u.getDegree() < i) {
						return Expression.ZERO;
					}

					return rho._pow(i).multiply(Expression.TWO._pow(Math.ceil(i * Math.log2(u.getDegree()) - i + 1)));
				};

				var B1 = scale2(traceBound(rho, u.getDegree(), traceIndex1).multiply(lc.abs()._pow(traceIndex1)), factors.length);
				var B2 = scale2(traceBound(rho, u.getDegree(), traceIndex2).multiply(lc.abs()._pow(traceIndex2)), factors.length);

				var binomial = function (n, k) {
					return k === 0 ? 1 : n * binomial(n - 1, k - 1) / k;
				};
				var combinationIndex = function (combination, k, n) {

					var result = binomial(n, k) - 1;
					for (var i = 0; i < k; i += 1) {
						result -= binomial(n - 1 - combination[i], k - i);
					}
					return result;
				};

				var makeDm2Test = function () {
					var b1b2Products = new Array(n).fill(null).map(function (x) {
						return new Array(n).fill(0);
					});
					if (nonzero !== 1) {
						for (var i = 0; i < factors.length; i += 1) {
							var lcb1 = lc.multiply(factors[i].getCoefficient(factors[i].getDegree() - 1)).modulo(q);
							for (var j = 0; j < i; j += 1) {
								var b2 = factors[j].getCoefficient(factors[j].getDegree() - 1);
								b1b2Products[i][j] = scale(lcb1.multiply(b2).modulo(q));
							}
						}
					}
					var factorsD2coefficients = new Array(factors.length).fill(-1);
					var lastD2Coefficients = new Array(factors.length).fill(-1);
					var lastCombination = new Array(factors.length).fill(-1);
					for (var i = 0; i < factors.length; i += 1) {
						factorsD2coefficients[i] = scale(lc.multiply(factors[i].getCoefficient(factors[i].getDegree() - 2 - nonzero)).modulo(q));
					}
					var B2 = scale2(coefficientBound(2 + nonzero).multiply(lc.abs()), Math.ceil(factors.length * (factors.length + 1) / 2));
					var twoB2 = (B2 >>> 0) >= (((-1) - B2) >>> 0) ? (-1) : (B2 + B2) | 0;
					return function (combination, k) {
						var i = 0;
						while (lastCombination[i] === combination[i]) {
							i += 1;
						}

						var d2 = i === 0 ? B2 : lastD2Coefficients[i - 1];
						while (i < k) {
							var factorIndex = combination[i];
							d2 = (d2 + factorsD2coefficients[factorIndex]) | 0;
							if (nonzero !== 1) {
								if (i > 0) {
									var s = 0;
									var j = i;
									do {
										j -= 1;
										var otherIndex = combination[j];

										s = (s + b1b2Products[factorIndex][otherIndex]) | 0;
									} while (j !== 0);
									d2 = (d2 + s) | 0;
								}
							}
							lastD2Coefficients[i] = d2;
							lastCombination[i] = combination[i];
							i += 1;
						}

						return (d2 >>> 0) <= (twoB2 >>> 0);
					};
				};

				var evaluationTest = function (point) {

					var lastCombination = new Array(factors.length).fill(-1);
					var lastProducts = new Array(factors.length).fill(null);
					var x = factors.map(function (f) {
						return point === 0 ? f.getCoefficient(0) : f.calcAt(Expression.Integer.fromNumber(point)).modulo(q);
					});
					var y = (point === 0 ? u.getCoefficient(0) : u.calcAt(Expression.Integer.fromNumber(point))).multiply(useRationalReconstruction ? Expression.ONE : lc);
					var qOver2 = q.truncatingDivide(Expression.TWO);
					return function (combination, k) {
						var i = 0;
						while (lastCombination[i] === combination[i]) {
							i += 1;
						}
						var value = i === 0 ? (useRationalReconstruction ? Expression.ONE : lc.abs()) : lastProducts[i - 1];
						while (i < k) {
							value = value.multiply(x[combination[i]]).remainder(q);
							lastProducts[i] = value;
							lastCombination[i] = combination[i];
							i += 1;
						}
						if (useRationalReconstruction) {
							var rat = recoverRational(value, q, rationalReconstructionParam, rationalReconstructionParam);
							return rat != null && lc.remainder(rat.getDenominator()).equals(Expression.ZERO) && y.remainder(rat.getNumerator()).equals(Expression.ZERO);
						}
						value = value.compareTo(qOver2) > 0 ? value.subtract(q) : value;
						if (value.equals(Expression.ZERO)) {
							return false;
						}
						return y.remainder(value).equals(Expression.ZERO);
					};
				};

				var dm2Test = makeDm2Test();
				var evaluationTestAt0 = evaluationTest(0);
				var evaluationTestAt1 = evaluationTest(1);
				var evaluationTestAtm1 = evaluationTest(-1);

				var divisionTest = function (combination, k) {
					if (true) {
						var fs = new Array(k);
						for (var i = 0; i < k; i += 1) {
							fs[i] = factors[combination[i]];
						}
						var v = productModQ(fs, q);
						console.assert(v.getLeadingCoefficient().equals(Expression.ONE));
						if (useRationalReconstruction) {
							v = v.map(function (c) {
								return recoverRational(c, q, rationalReconstructionParam, rationalReconstructionParam) || Expression.ZERO;
							});
							v = v.primitivePart();
						} else {
							v = v.scale(lc);
							v = v.roundMod(q);
						}

						console.assert(v.getDegree() < u.getDegree());

						var tmp = u.scale(useRationalReconstruction ? Expression.ONE : lc).divideAndRemainder(v, "undefined");
						if (tmp != undefined && tmp.remainder.getDegree() < 0) {
							c6 += 1;
							v = v.primitivePart();
							factors = factors.filter(function (factor) {
								return fs.indexOf(factor) === -1;
							});
							u = tmp.quotient.primitivePart();
							if (c > 32) {
								console.debug('filters-efficiency', c, c0, c1, c2, c3, c4, c5, c6);
							}

							return v;
						}

					}
					return null;
				};

				var oracleTableLast = 0;
				for (var i = 0; i < oracleTable.length; i += 1) {
					oracleTable[i] = n - oracleParam;
				}

				var start = Date.now();

				for (; countOfFactors <= (checkBothVariants ? factors.length - 1 : Math.floor(factors.length / 2)); countOfFactors += 1) {

					var oracleDepth = Math.ceil(countOfFactors / 2) + 1;
					for (var k = oracleTableLast + 1; k <= oracleDepth && k <= oracleParam; k += 1) {
						buildOracleTable(n, B1, B2, oracleBits, k, oracleParam);
						oracleTableLast = k;
					}

					var k = countOfFactors;

					for (var i = 0; i < k; i += 1) {
						combination[i] = n - k + i;
					}
					combination[0] = -1;

					var minDegree = factors.slice(0, k).reduce(function (a, b) {
						return a + b.getDegree();
					}, 0);
					var maxDegree = factors.slice(-k).reduce(function (a, b) {
						return a + b.getDegree();
					}, 0);
					if (possibleDegreesFilter != undefined) {
						if ((BigInt.asUintN(maxDegree + 1, possibleDegreesFilter) >> BigInt(minDegree)) === BigInt(0)) {
							continue;
						}
					}

					if (countOfFactors > 7) {
						console.log('countOfFactors', countOfFactors, Date.now() - start, c, c0, c1, c2);
						start = Date.now();
					}

					var lastCombinationIndex = -0;

					var lastC2 = 0;
					var ok = 1;
					while (ok === 1) {
						ok = nextFilteredOutCombination(n, k, B1, B2, oracleBits, Math.min(oracleDepth, oracleParam), oracleParam);

						var ci = combinationIndex(combination, k, n);
						c += ci - lastCombinationIndex;
						lastCombinationIndex = ci;
						c0 += (counters[0] >>> 0);
						c1 += (counters[1] >>> 0);

						c2 += 1;
						if (factors.length > 30 && c2 > lastC2 + 10) {
							lastC2 = c2;
							console.debug('filters-efficiency', c, c0, c1, c2, c3, c4, c5, c6);
						}

						if (!dm2Test(combination, k)) {
							continue;
						}

						if (!evaluationTestAt0(combination, k)) {
							continue;
						}
						c3 += 1;
						if (!evaluationTestAt1(combination, k)) {
							continue;
						}
						c4 += 1;
						if (!evaluationTestAtm1(combination, k)) {
							continue;
						}
						c5 += 1;
						var v = divisionTest(combination, k);
						if (v != null) {
							return {
								value: v,
								done: false
							};
						}
					}

				}
				if (c > 32) {
					console.debug('filters-efficiency', c, c0, c1, c2, c3, c4, c5, c6);
				}
				if (polynomial.getDegree() > u.getDegree()) {
					var f = u.primitivePart();
					u = Polynomial.of(u.getContent());
					return {
						value: f,
						done: false
					};
				}
				return {
					value: null,
					done: true
				};
			}
		};
		iterator[globalThis.Symbol.iterator] = function () {
			return this;
		};
		return iterator;
	}

	function HenselLift(C, A, B, U, V, q, p) {

		var f = C.subtract(A.multiply(B)).unscale(q).mod(p);

		var tmp = V.multiply(f).mod(p).divideAndRemainderModP(A.mod(p), p);
		var t = tmp.quotient;
		var A0 = tmp.remainder;
		var B0 = U.multiply(f).add(B.mod(p).multiply(t)).mod(p);
		var A1 = A.add(A0.scale(q));
		var B1 = B.add(B0.scale(q));

		return [A1, B1];
	}

	function QuadraticHenselLift(A1, B1, U, V, p) {

		var ONE = A1.constructor.from([toInt(1, p)]);
		var g = ONE.subtract(U.multiply(A1)).subtract(V.multiply(B1)).unscale(p).mod(p);
		var tmp = V.multiply(g).mod(p).divideAndRemainderModP(A1.mod(p), p);
		var t = tmp.quotient;
		var U0 = U.multiply(g).add(B1.mod(p).multiply(t)).mod(p);
		var V0 = tmp.remainder;
		var U1 = U.add(U0.scale(p));
		var V1 = V.add(V0.scale(p));

		return [U1, V1];
	}

	function HenselLiftingOfTwoFactors(C, A, B, p, k) {
		var useQuadraticHenselLift = !(p instanceof Expression.Polynomial);
		var tmp1 = ExtendedEuclideanAlgorithm(A, B, p);
		console.assert(tmp1.gcd.getDegree() === 0);
		var U = tmp1.U;
		var V = tmp1.V;
		if (useQuadraticHenselLift) {
			var se = Math.floor((53 - Math.log2(Math.min(A.getDegree(), B.getDegree()) + 1)) / (2 * Math.log2(p.toNumber())));
			var C1 = C.mod(p._pow(se * 2));

			var originalP = p;
			var e = 1;

			var sp = p.toNumber();
			var isInt = false;
			if (e < k / 4) {
				A = toIntPolynomial(A, sp);
				B = toIntPolynomial(B, sp);
				U = toIntPolynomial(U, sp);
				V = toIntPolynomial(V, sp);
				C1 = toIntPolynomial(C1, p._pow(se * 2).toNumber());
				isInt = true;
			}

			while (e < k / 4) {
				var $tmpA_B = HenselLift(e <= se ? C1 : C, A, B, U, V, isInt ? p.toNumber() : p, isInt ? p.toNumber() : p);
				A = $tmpA_B[0];
				B = $tmpA_B[1];
				if (isInt && (e + e >= se || e + e >= k / 4)) {
					A = fromIntPolynomial(A);
					B = fromIntPolynomial(B);
					U = fromIntPolynomial(U);
					V = fromIntPolynomial(V);
					C1 = fromIntPolynomial(C1);
					isInt = false;
				}
				var $tmpU_V = QuadraticHenselLift(A, B, U, V, isInt ? p.toNumber() : p);
				U = $tmpU_V[0];
				V = $tmpU_V[1];
				p = p.multiply(p);
				e *= 2;
				if (true) {
					var c = 1;
					while (e * c < k) {
						c *= 2;
					}
					if ((e - 1) * c >= k) {
						e -= 1;
						p = p.divide(originalP);
					}
				}
			}

			var e0 = e;
			var q = p;
			while (e < k) {
				var $tmpA_B = HenselLift(C, A, B, U, V, q, p);
				A = $tmpA_B[0];
				B = $tmpA_B[1];
				q = q.multiply(p);
				e += e0;
			}
			if (e !== k) {
				var pInK = originalP._pow(k);
				A = A.mod(pInK);
				B = B.mod(pInK);
			}
			return [A, B];
		}

		var q = p;
		for (var i = 1; i < k; i += 1) {
			var $tmpA_B = HenselLift(C, A, B, U, V, q, p);
			A = $tmpA_B[0];
			B = $tmpA_B[1];

			q = q.multiply(p);
		}
		return [A, B];
	}

	function productModQ(factors, q) {
		console.assert(factors.length > 0);
		return factors.length > 1 ? productModQ(factors.slice(0, Math.ceil(factors.length / 2)), q).multiply(productModQ(factors.slice(Math.ceil(factors.length / 2)), q)).mod(q) : factors[0];
	}

	function HenselLifting(C, factors, p, e) {

		if (factors.length === 1) {
			return [C];
		}

		var s = Math.floor(factors.length / 2);
		var A = factors.slice(0, s);
		var B = factors.slice(s);
		var $tmpA1_B1 = HenselLiftingOfTwoFactors(C, productModQ(A, p), productModQ(B, p), p, e);
		var A1 = $tmpA1_B1[0];
		var B1 = $tmpA1_B1[1];
		return HenselLifting(A1, A, p, e).concat(HenselLifting(B1, B, p, e));
	}

	factorizeOverTheIntegers._gcdOfPolynomialsOverFiniteField0 = function (a, b, p) {
		return fromIntPolynomial(IntPolynomial.gcd(toIntPolynomial(a, p), toIntPolynomial(b, p), p));
	};

	factorizeOverTheIntegers._extgcdOfPolynomialsOverFiniteField0 = function (a, b, p) {
		console.assert(typeof p === 'number');

		var result = IntPolynomial.gcdext(toIntPolynomial(a, p), toIntPolynomial(b, p), p);
		return {
			U: fromIntPolynomial(result.U),
			V: fromIntPolynomial(result.V),
			gcd: fromIntPolynomial(result.gcd)
		};
	};

	function factorizeMultivariateIntegerPolynomial(p) {

		function factorizeInternal(p) {
			var factors = [];
			p = p.primitivePart();
			var f = p.getDegree() > 1 ? (!p.hasIntegerCoefficients() ? p.factorize() : factorizeOverTheIntegers(p).next().value) : null;
			if (f != null) {
				factors = factors.concat(factorizeInternal(f));
				factors = factors.concat(factorizeInternal(p.divideAndRemainder(f, "throw").quotient));
			} else {
				factors.push(p);
			}
			return factors;
		}

		var degreeByY = 0;
		for (var i = 0; i <= p.getDegree(); i += 1) {
			if (!(p.getCoefficient(i).equals(Expression.ZERO))) {
				degreeByY = Math.max(degreeByY, p.getCoefficient(i).polynomial.getDegree());
			}
		}

		for (var y = 0; ; y += 1) {
			var p_r = p.map(function (c) {
				return c.polynomial.calcAt(Expression.Integer.fromNumber(y));
			});
			if (p_r.getDegree() === p.getDegree() && p_r.isSquareFreePolynomial()) {
				var factors = Array.from(factorizeInternal(p_r)).map(function (f) {
					return f.map(function (c) {
						return new Expression.Polynomial(Polynomial.of(c));
					});
				});
				if (factors.length < 2) {
					return null;
				}
				var s = new Expression.Polynomial(Polynomial.of(p_r.getContent()));
				factors[factors.length - 1] = factors[factors.length - 1].scale(s);
				var r = new Expression.Polynomial(Polynomial.of(Expression.Integer.fromNumber(0 - y), Expression.ONE));
				var q = r._pow(degreeByY + 1);
				factors = HenselLifting(p, factors, r, degreeByY + 1);
				console.assert(p.subtract(productModQ(factors, q)).mod(q).toString() === '0');
				for (var number = 1; number <= factors.length - 1; number += 1) {
					for (var iteratorc = combinations(factors.length, number)[globalThis.Symbol.iterator](), c = iteratorc.next().value; c != null; c = iteratorc.next().value) {
						var candidate = productModQ(c.map(function (i) {
							return factors[i];
						}), q);
						candidate = candidate.scale(p.getLeadingCoefficient()).mod(q);
						if (candidate._hasIntegerLikeCoefficients()) {
							candidate = candidate.primitivePart();
							if (p.scale(p.getLeadingCoefficient()._pow(p.getDegree() - candidate.getDegree() + 1)).isDivisibleBy(candidate)) {
								return candidate;
							}
						}
					}
				}
			}
		}
	}

	factorizeOverTheIntegers._factorizeMultivariateIntegerPolynomial = factorizeMultivariateIntegerPolynomial;
	globalThis.factorizeOverTheIntegers = factorizeOverTheIntegers;
	self.factorizeOverTheIntegers = factorizeOverTheIntegers;

	factorizeOverTheIntegers.testables = {
		distinctDegreeFactorization: distinctDegreeFactorization,
		CantorZassenhausAlgorithm: CantorZassenhausAlgorithm,
		isFactorizationOverZpSquareFree: isFactorizationOverZpSquareFree,
		factorizeOverTheFiniteField: factorizeOverTheFiniteField,

		randomBigInt: randomBigInt,

		ExtendedEuclideanAlgorithm: ExtendedEuclideanAlgorithm,
		HenselLift: HenselLift,
		QuadraticHenselLift: QuadraticHenselLift,
		HenselLiftingOfTwoFactors: HenselLiftingOfTwoFactors,
		HenselLifting: HenselLifting,
		HenselLiftingNonMonic: HenselLiftingNonMonic,
		choosePrime: choosePrime,
		toIntPolynomial: toIntPolynomial,
		fromIntPolynomial: fromIntPolynomial,
		productModQ: productModQ
	};

	function recoverRational(n, m, N, D) {

		if (n.compareTo(Expression.ZERO) < 0 || n.compareTo(m) >= 0) {
			throw new RangeError();
		}
		var v1 = m;
		var v2 = Expression.ZERO;
		var w1 = n;
		var w2 = Expression.ONE;
		if (true) {
			if (w1.compareTo(N) > 0 && v1.subtract(w1).compareTo(N) > 0) {
				var tmp = halfgcd(BigInt(v1.toBigInt()), BigInt(w1.toBigInt()));
				var $v1 = Expression.Integer.fromBigInt(tmp[4]);
				var $w1 = Expression.Integer.fromBigInt(tmp[5]);
				console.assert($v1.compareTo($w1) > 0);
				if ($v1.compareTo(N) > 0) {
					v1 = $v1;
					w1 = $w1;
					v2 = Expression.Integer.fromBigInt(tmp[1]);
					w2 = Expression.Integer.fromBigInt(tmp[3]);
				} else {
					console.warn('too small?', n, m, N, D);
				}
			}
		}
		var s = 0;
		while (w1.compareTo(N) > 0) {
			s += 1;
			var q = v1.truncatingDivide(w1);
			var z1 = v1.subtract(q.multiply(w1));
			var z2 = v2.subtract(q.multiply(w2));
			v1 = w1;
			v2 = w2;
			w1 = z1;
			w2 = z2;
		}
		if (s > 3) {
			console.warn('too many iterations', s);
		}
		if (w2.sign() < 0) {
			w1 = w1.negate();
			w2 = w2.negate();
		}
		if (w2.compareTo(D) < 0 && w1.gcd(w2).equals(Expression.ONE)) {

			return w2.equals(Expression.ONE) ? w1 : new Expression.Division(w1, w2);
		}
		return null;
	}

	globalThis.recoverRational = recoverRational;

	function traceBound(rho, degree, i) {

		return rho._pow(i).multiply(Expression.Integer.fromNumber(degree));
	}

	function absMax(matrix) {
		var max = Expression.ZERO;
		for (var i = 0; i < matrix.rows(); i += 1) {
			for (var j = 0; j < matrix.cols(); j += 1) {
				var e = matrix.e(i, j).abs();
				max = e.compareTo(max) > 0 ? e : max;
			}
		}
		return max;
	}

	function HenselLiftingNonMonic(u, factors, prime, e) {
		factors = factors.slice(0);
		var p = Expression.Integer.fromNumber(prime);
		var lc = u.getLeadingCoefficient();
		if (!lc.equals(Expression.ONE)) {
			factors[factors.length - 1] = factors[factors.length - 1].scale(lc.modulo(p)).mod(p);
		}
		factors = HenselLifting(u, factors, p, e);
		if (!lc.equals(Expression.ONE)) {
			var q = p._pow(e);
			factors = factors.map(function (factor) {
				return factor.scale(factor.getLeadingCoefficient().modulo(q).modInverse(q)).mod(q);
			});
		}
		return factors;
	}

	var log2 = function (a) {
		var e = 52 - a.bitLength();
		return Math.log2(a.leftShift(e).toNumber()) - e;
	};

	function knapsackFactorization(u, factors, p, a, lc) {

		var traces = 1;

		var C = Math.round(Math.sqrt(traces * factors.length) / 2);

		var Blat = factors.length * Math.pow(C, 2) + traces * Math.pow((factors.length * 1 / 2), 2);

		var trace = 1;
		var M_L = Matrix.I(factors.length);
		console.debug('M_L.rows()', M_L.rows());
		var rho = u.getAllRootsBound();
		do {
			var Btrace = traceBound(rho, u.getDegree(), trace + traces - 1).multiply(lc.abs()._pow(trace + traces - 1));
			var bmin = Math.ceil((1 + log2(Btrace)) / Math.log2(p));

			if (a <= bmin) {
				console.warn('a <= bmin', {
					a: a,
					bmin: bmin,
					trace: trace
				});

				a *= 2;

				console.time('extra lifting');
				factors = HenselLiftingNonMonic(u, factors, p, a);
				console.timeEnd('extra lifting');

				trace = 1;
				continue;
			}

			var TRACES = Matrix.Zero(factors.length, traces).map(function (e, i, j) {
				return factors[i].trace(trace + j).multiply(lc._pow(trace + j));
			});
			var b = a;
			var pInA = Expression.Integer.fromNumber(p)._pow(a);
			console.debug('trace', trace);

			var extVariant = false;
			var Mfull = null;
			var oldVariant = false;
			var firstIteration = true;
			var M_L0 = M_L;

			var isFullRank = function (M_L1) {
				var orthogonalLatticeBasis = ModifiedGramSchmidt(M_L1.rowVectors().map(function (v) {
					return v.elements.map(function (e) {
						return -0.0 + e.toNumber();
					});
				}));
				var GSLengths2 = orthogonalLatticeBasis.map(function (v) {
					return Math.pow(Math.hypot.apply(null, v), 2);
				});
				return GSLengths2.reduce(function (min, length) {
					return Math.min(min, length);
				}, 1 / 0) > 0.5;
			};

			do {

				var M_L_TRACES = extVariant && Mfull != null ? Mfull.slice(0, Mfull.rows(), factors.length, Mfull.cols()) : M_L.multiply(TRACES).map(function (e) {
					return e.roundMod(pInA);
				});
				var max = absMax(M_L_TRACES);

				b = Math.max(Math.min(b - 1, Math.ceil((max.bitLength() + 1 - 53 + 4) / Math.log2(p))), bmin);

				var pInB = Expression.Integer.fromNumber(p)._pow(b);
				if (max.add(max).compareTo(pInB) < 0) {
					b = Math.floor((1 + max.bitLength()) / Math.log2(p));

					continue;
				}

				var M = extVariant && !firstIteration ? null : M_L.scale(Expression.Integer.fromNumber(C)).augment(M_L_TRACES.map(function (e) {
					return (extVariant ? e : e.roundDivision(pInB));
				}));
				if (firstIteration) {
					M = Matrix.Zero(traces, factors.length).augment(Matrix.I(traces).scale(extVariant ? pInA : pInA.roundDivision(pInB))).transpose().augment(M.transpose()).transpose();
					if (extVariant) {
						Mfull = M;
					}
					if (!oldVariant) {
						firstIteration = false;
					}
				}
				if (extVariant) {
					M = Mfull.map(function (e, i, j) {
						return j >= factors.length ? e.roundDivision(pInB) : e;
					});
				}

				console.time('LLL');
				if (extVariant) {
					var tmp = LLLAdapter(Matrix.I(M.rows()).augment(M));
					var U1 = tmp.slice(0, M.rows(), 0, M.rows());
					M = tmp.slice(0, M.rows(), M.rows(), M.rows() + M.cols());
					Mfull = U1.multiply(Mfull);
				} else {

					M = LLLAdapter(M, undefined, undefined, globalThis.BigInt != undefined && typeof BigInt(0) === 'bigint' ? l3fp : LLL);
				}
				console.timeEnd('LLL');

				var r = M.rows();
				var orthogonalBasis = ModifiedGramSchmidt(M.rowVectors().map(function (v) {
					return v.elements.map(function (e) {
						return -0.0 + e.toNumber();
					});
				}));
				var GSLengths = orthogonalBasis.map(function (v) {
					return Math.pow(Math.hypot.apply(null, v), 2);
				});
				if (absMax(M).toNumber() > Math.pow(2, 512)) {

					if (GSLengths.filter(function (x) {
						return Number.isNaN(x);
					}).length !== 0) {
						console.time('gs-extra');
						GSLengths = GramSchmidtOrthogonalization(M.rowVectors()).map(function (v) {
							var d = v.dot(v);
							return Math.pow(2, log2(d.getNumerator()) - log2(d.getDenominator()));
						});
						console.timeEnd('gs-extra');
					}
				}
				while (GSLengths[r - 1] > Blat) {
					r -= 1;
				}
				var M_L1 = M.slice(0, r, 0, factors.length).map(function (e) {
					return e.divide(Expression.Integer.fromNumber(C));
				});

				if (extVariant) {
					Mfull = Mfull.slice(0, r, 0, Mfull.cols());
				}

				if (oldVariant && !extVariant) {
					if (true) {
						if (!isFullRank(M_L1)) {
							console.warn('rank?');
							if (!oldVariant && !extVariant) {
								M_L = M_L1;
							}
							if (b === bmin) {

							}

							continue;
						}
					}
				}

				M_L = M_L1;
				if (extVariant) {
					M_L0 = Mfull.slice(0, Mfull.rows(), 0, factors.length).map(function (e) {
						return e.divide(Expression.Integer.fromNumber(C));
					});
				}
				if (oldVariant) {
					M_L0 = M_L1;
				}
				console.debug('M_L.rows()', M_L.rows());
			} while (b > bmin);
			if (oldVariant && !extVariant) {
				M_L = M_L0;
			} else {
				if (!isFullRank(M_L)) {
					console.warn('rank?');
					M_L = M_L0;
				}
			}

			var range = function (n) {
				return Array.from({length: n}, function (_, i) {
					return i;
				}).map(function (i) {
					return i;
				});
			};
			var solve = function (matrix) {

				var colGroups = Object.values(Object.groupBy(range(matrix.cols()), function (col) {
					return matrix.col(col).elements.join(' ');
				}));
				if (colGroups.length > matrix.rows()) {
					return null;
				}
				return colGroups;
			};

			var sols = solve(M_L);

			if (sols != null) {
				sols.sort(function (a, b) {
					return a.length - b.length;
				});
				var u1 = u;
				var result = [];
				for (var i = 0; i < sols.length && i - result.length <= 1; i += 1) {
					var candidate = productModQ(sols[i].map(function (i) {
						return factors[i];
					}), pInA).scale(lc).roundMod(pInA);
					if (candidate != null) {

						if (u1.getCoefficient(0).remainder(candidate.getCoefficient(0)).equals(Expression.ZERO)) {
							if (!lc.equals(Expression.ONE) || u1.divideAndRemainderModP(candidate, Expression.Integer.fromNumber(2)).remainder.getDegree() < 1) {
								var tmp = u1.scale(lc).divideAndRemainder(candidate, "undefined");
								if (tmp != undefined && tmp.remainder.getDegree() < 0) {
									var content = candidate.getContent();
									result.push(candidate.scale(content.inverse()));
									u1 = tmp.quotient.scale(lc.divide(content).inverse());
								}
							}
						}
					}
				}

				if (result.length === M_L.rows() - 1) {
					if (u1.getDegree() > 0) {
						result.push(u1);
						u1 = Polynomial.of(Expression.ONE);
					}
				}
				if (result.length === M_L.rows()) {
					if (u1.getDegree() > 0) {
						throw new TypeError("unexpected");
					}
					if (u1.toString() !== '1') {
						result[0] = result[0].scale(u1.getCoefficient(0));
					}
					return result;
				}
			}
			trace += traces;

		} while (trace <= 1 + u.getDegree());
		console.error('cannot factor!');
		throw new RangeError();
	}

	globalThis.knapsackFactorization = knapsackFactorization;

	function ModifiedGramSchmidt(vectors) {
		function dot(a, b) {
			var n = Math.min(a.length, b.length);
			var s = -0.0;
			for (var i = 0; i < n; i += 1) {
				s += a[i] * b[i];
			}
			return s;
		}

		function reduce(a, b, alpha) {
			var n = Math.min(a.length, b.length);
			var c = new Array(n);
			for (var i = 0; i < n; i += 1) {
				c[i] = a[i] - alpha * b[i];
			}
			return c;
		}

		var b = vectors.slice(0);
		var n = b.length;
		for (var i = 0; i < n; i += 1) {
			var s = dot(b[i], b[i]);
			for (var k = i + 1; k < n; k += 1) {
				b[k] = reduce(b[k], b[i], dot(b[k], b[i]) / s);
			}
		}
		return b;
	}

	globalThis.ModifiedGramSchmidt = ModifiedGramSchmidt;

	globalThis.LLLAdapter = function (matrix, δ, η, f) {
		δ = δ == undefined ? undefined : δ;
		η = η == undefined ? undefined : η;
		f = f == undefined ? LLL : f;

		var input = matrix.rowVectors().map(function (v) {
			return v.elements.map(function (e) {
				return e.toBigInt();
			});
		});
		return Matrix.fromVectors(f(input, δ, η).map(function (array) {
			return new Matrix.Vector(array.map(function (e) {
				return Expression.Integer.fromBigInt(e);
			}));
		})).transpose();
	};

	if (Object.values == undefined) {
		Object.values = function (object) {
			var values = [];
			for (var name in object) {
				if (Object.prototype.hasOwnProperty.call(object, name)) {
					values.push(object[name]);
				}
			}
			return values;
		};
	}

	if (Object.groupBy == undefined) {
		Object.groupBy = function (array, callback) {
			var groups = {};
			for (var iteratoritem = array[globalThis.Symbol.iterator](), item = iteratoritem.next().value; item != null; item = iteratoritem.next().value) {
				var key = callback(item);
				var group = groups[key];
				if (group == null) {
					group = [];
					groups[key] = group;
				}
				group.push(item);
			}
			return groups;
		};
	}
}

function SeedRandom() {
	(function (global, pool, math) {

		var width = 256,
			chunks = 6,
			digits = 52,
			rngname = 'random',
			startdenom = math.pow(width, chunks),
			significance = math.pow(2, digits),
			overflow = significance * 2,
			mask = width - 1,
			nodecrypto;

		function seedrandom(seed, options, callback) {
			var key = [];
			options = (options == true) ? {entropy: true} : (options || {});

			var shortseed = mixkey(flatten(options.entropy ? [seed, tostring(pool)] : (seed == null) ? autoseed() : seed, 3), key);

			var arc4 = new ARC4(key);

			var prng = function () {
				var n = arc4.g(chunks),
					d = startdenom,
					x = 0;
				while (n < significance) {
					n = (n + x) * width;
					d *= width;
					x = arc4.g(1);
				}
				while (n >= overflow) {
					n /= 2;
					d /= 2;
					x >>>= 1;
				}
				return (n + x) / d;
			};

			prng.int32 = function () {
				return arc4.g(4) | 0;
			}
			prng.quick = function () {
				return arc4.g(4) / 0x100000000;
			}
			prng.double = prng;

			mixkey(tostring(arc4.S), pool);

			return (options.pass || callback || function (prng, seed, is_math_call, state) {
				if (state) {

					if (state.S) {
						copy(state, arc4);
					}

					prng.state = function () {
						return copy(arc4, {});
					}
				}

				if (is_math_call) {
					math[rngname] = prng;
					return seed;
				} else return prng;
			})(prng, shortseed, 'global' in options ? options.global : (this == math), options.state);
		}

		function ARC4(key) {
			var t,
				keylen = key.length,
				me = this,
				i = 0,
				j = me.i = me.j = 0,
				s = me.S = [];

			if (!keylen) {
				key = [keylen++];
			}

			while (i < width) {
				s[i] = i++;
			}
			for (i = 0; i < width; i++) {
				s[i] = s[j = mask & (j + key[i % keylen] + (t = s[i]))];
				s[j] = t;
			}

			(me.g = function (count) {

				var t,
					r = 0,
					i = me.i,
					j = me.j,
					s = me.S;
				while (count--) {
					t = s[i = mask & (i + 1)];
					r = r * width + s[mask & ((s[i] = s[j = mask & (j + t)]) + (s[j] = t))];
				}
				me.i = i;
				me.j = j;
				return r;

			})(width);
		}

		function copy(f, t) {
			t.i = f.i;
			t.j = f.j;
			t.S = f.S.slice();
			return t;
		};

		function flatten(obj, depth) {
			var result = [],
				typ = (typeof obj),
				prop;
			if (depth && typ == 'object') {
				for (prop in obj) {
					try {
						result.push(flatten(obj[prop], depth - 1));
					} catch (e) {
					}
				}
			}
			return (result.length ? result : typ == 'string' ? obj : obj + '\0');
		}

		function mixkey(seed, key) {
			var stringseed = seed + '',
				smear,
				j = 0;
			while (j < stringseed.length) {
				key[mask & j] = mask & ((smear ^= key[mask & j] * 19) + stringseed.charCodeAt(j++));
			}
			return tostring(key);
		}

		function autoseed() {
			try {
				var out;
				if (nodecrypto && (out = nodecrypto.randomBytes)) {

					out = out(width);
				} else {
					out = new Uint8Array(width);
					(global.crypto || global.msCrypto).getRandomValues(out);
				}
				return tostring(out);
			} catch (e) {
				var browser = global.navigator,
					plugins = browser && browser.plugins;
				return [+new Date, global, plugins, global.screen, tostring(pool)];
			}
		}

		function tostring(a) {
			return String.fromCharCode.apply(0, a);
		}

		mixkey(math.random(), pool);

		if ((typeof module) == 'object' && module.exports) {
			module.exports = seedrandom;

			try {
				nodecrypto = require('crypto');
			} catch (ex) {
			}
		} else if ((typeof define) == 'function' && define.amd) {
			define(function () {
				return seedrandom;
			});
		} else {

			math['seed' + rngname] = seedrandom;
		}

	})((typeof self !== 'undefined') ? self : this, [], Math);
}

function RealAlgebraicNumbers() {
	function SimpleFloat(significand, exponent) {
		this.significand = significand;
		this.exponent = exponent;
	}

	SimpleFloat.create = function (e) {
		var n = e.getNumerator();
		var d = e.getDenominator();
		if (!(n instanceof Expression.Integer) || !(d instanceof Expression.Integer)) {
			throw new TypeError();
		}
		var exp = 0;
		if (d !== Expression.ONE) {
			exp = d.bitLength() - 1;
			if (!Expression.TWO._pow(exp).equals(d)) {
				throw new TypeError();
			}
		}
		return new SimpleFloat(n, 0 - exp);
	};
	SimpleFloat.prototype.toExpression = function () {
		return this.significand.multiply(this.exponent >= 0 ? Expression.TWO._pow(this.exponent) : Expression.TWO._pow(-this.exponent).inverse());
	};
	SimpleFloat.prototype.multiply = function (other) {
		return new SimpleFloat(this.significand.multiply(other.significand), this.exponent + other.exponent);
	};
	SimpleFloat.prototype.add = function (other) {
		var min = Math.min(this.exponent, other.exponent);
		return new SimpleFloat(this.significand.leftShift(this.exponent - min).add(other.significand.leftShift(other.exponent - min)), min);
	};
	SimpleFloat.prototype.negate = function () {
		return new SimpleFloat(this.significand.negate(), this.exponent);
	};
	SimpleFloat.prototype.sign = function () {
		return this.significand.sign();
	};
	SimpleFloat.prototype.toString = function () {

		return this.significand.toString() + '*2**' + this.exponent;
	};
	SimpleFloat.prototype.round = function (mode, fractionDigits) {
		if (this.exponent !== 0 - fractionDigits) {
			if (mode === 'floor') {
				var a = new SimpleFloat(this.significand.leftShift(this.exponent + fractionDigits), 0 - fractionDigits);
				if (a.add(this.negate()).sign() > 0) {
					throw new Error();
				}
				return a;
			}
			if (mode === 'ceil') {
				var a = new SimpleFloat(this.significand.negate().leftShift(this.exponent + fractionDigits).negate(), 0 - fractionDigits);
				if (a.add(this.negate()).sign() < 0) {
					throw new Error();
				}
				return a;
			}
			throw new RangeError();
		}
		return this;
	};
	var isRational = function (e) {
		return e.getNumerator() instanceof Expression.Integer && e.getDenominator() instanceof Expression.Integer;
	};
	var isPowerOf2 = function (i) {
		return Expression.TWO._pow(i.bitLength() - 1).equals(i);
	};

	function SimpleInterval(a, b) {
		if (!(a instanceof SimpleFloat) || !(b instanceof SimpleFloat) || a.add(b.negate()).sign() > 0) {
			throw new TypeError();
		}
		this.a = a;
		this.b = b;
	}

	SimpleInterval.from = function (interval) {
		return new SimpleInterval(SimpleFloat.create(interval.a), SimpleFloat.create(interval.b));
	};
	SimpleInterval.prototype.toExpressionsInterval = function () {
		return {
			a: this.a.toExpression(),
			b: this.b.toExpression()
		};
	};
	SimpleInterval.prototype.negate = function () {
		return new SimpleInterval(this.b.negate(), this.a.negate());
	};
	SimpleInterval.prototype.add = function (other) {
		return new SimpleInterval(this.a.add(other.a), this.b.add(other.b));
	};
	SimpleInterval.prototype.multiply = function (other) {
		var sign = function (e) {
			return e.sign();
		};
		var f = function (a, b, c, d) {
			return new SimpleInterval(a.multiply(b), c.multiply(d));
		};
		var x1 = this.a;
		var x2 = this.b;
		var y1 = other.a;
		var y2 = other.b;
		var sx1 = sign(x1);
		var sx2 = sign(x2);
		var sy1 = sign(y1);
		var sy2 = sign(y2);
		if (sx1 >= 0) {
			if (sy1 >= 0) {
				return f(x1, y1, x2, y2);
			}
			if (sy2 <= 0) {
				return f(x2, y1, x1, y2);
			}

			return f(x2, y1, x2, y2);
		}
		if (sx2 <= 0) {
			if (sy2 <= 0) {
				return f(x2, y2, x1, y1);
			}
			if (sy1 >= 0) {
				return f(x1, y2, x2, y1);
			}

			return f(x1, y2, x1, y1);
		}
		if (sy1 >= 0) {

			return f(x1, y2, x2, y2);
		}
		if (sy2 <= 0) {

			return f(x2, y1, x1, y1);
		}

		var a = x1.multiply(y1);
		var b = x2.multiply(y1);
		var c = x1.multiply(y2);
		var d = x2.multiply(y2);
		var min = function (a, b) {
			return a.subtract(b).sign() < 0 ? a : b;
		};
		var max = function (a, b) {
			return a.subtract(b).sign() < 0 ? b : a;
		};
		var from = min(min(a, b), min(c, d));
		var to = max(max(a, b), max(c, d));
		return new SimpleInterval(from, to);
	};
	SimpleInterval.prototype.scale = function (s) {
		return this.multiply(SimpleInterval.from({
			a: s,
			b: s
		}));
	};

	SimpleInterval.prototype.inverse = function (precision) {
		var sign = function (e) {
			return e.sign();
		};
		if (sign(this.a) < 0 && sign(this.b) > 0) {
			throw new TypeError();
		}
		if (precision == undefined) {
			debugger;
			throw new TypeError();
		}
		var that = this.toExpressionsInterval();
		var s = Expression.TWO._pow(precision + Math.max(that.b.getNumerator().abs().bitLength(), that.a.getNumerator().abs().bitLength()));
		var div = function (a, b, roundingMode) {
			if (roundingMode === 'floor') {
				if (b.sign() < 0) {
					a = a.negate();
					b = b.negate();
				}
				return a.sign() >= 0 ? a.truncatingDivide(b) : a.add(Expression.ONE).truncatingDivide(b).subtract(Expression.ONE);
			}
			if (roundingMode === 'ceil') {
				return div(a.negate(), b, 'floor').negate();
			}
			throw new TypeError();
		};
		var f = function (s, x, roundingMode) {
			return div(s, x.getNumerator(), roundingMode).divide(s).multiply(x.getDenominator());
		};
		return SimpleInterval.from({
			a: f(s, that.b, 'floor'),
			b: f(s, that.a, 'ceil')
		});
	};
	SimpleInterval.prototype._pow = function (n) {
		if (n % 2 === 0) {
			if (n === 0) {
				return SimpleInterval.from({
					a: Expression.ONE,
					b: Expression.ONE
				});
			}
			return this.multiply(this)._pow(n / 2);
		}
		return new SimpleInterval(this.a._pow(n), this.b._pow(n));
	};
	SimpleInterval.prototype.toString = function () {
		return '[' + this.a.toString() + ';' + this.b.toString() + ']';
	};
	SimpleInterval.prototype.round = function (precision) {
		return new SimpleInterval(this.a.round('floor', precision), this.b.round('ceil', precision));
	};
	var intersection = function (a, b) {
		var cmp = function (x1, x2) {
			return x1.subtract(x2).getNumerator().sign();
		};
		var max = function (x1, x2) {
			return cmp(x1, x2) < 0 ? x2 : x1;
		};
		var min = function (x1, x2) {
			return cmp(x1, x2) < 0 ? x1 : x2;
		};

		if (cmp(b.a, a.b) > 0 || cmp(a.a, b.b) > 0) {
			return null;
		}
		return {
			a: max(a.a, b.a),
			b: min(a.b, b.b)
		};
	};

	var toSimpleInterval = function (e, precision) {

		if (e instanceof Expression.Integer) {
			return SimpleInterval.from({
				a: e,
				b: e
			});
		} else if (e instanceof Expression.BinaryOperation) {
			var a = toSimpleInterval(e.a, precision);
			var b = toSimpleInterval(e.b, precision);
			var s = e.getS();
			if (s === "+") {
				return a.add(b);
			} else if (s === "-") {
				return a.add(b.negate());
			} else if (s === "*") {
				return a.multiply(b);
			} else if (s === "/") {

				return a.multiply(b.inverse(precision));
			} else if (s === "^") {
				if (e.b instanceof Expression.Integer) {
					var n = e.b.toBigInt();
					return a._pow(n);
				}
			} else {
				debugger;
			}
		} else if (e instanceof Expression.NthRoot) {
			var n = e.n;
			console.assert(n >= 2 && n % 1 === 0);
			if (e.a instanceof Expression.Integer && e.a.sign() > 0) {
				var a = e.a;
				var scale = Expression.TWO._pow(precision);
				var numerator = a.multiply(scale._pow(n))._integerNthRoot(n);

				return SimpleInterval.from({
					a: numerator.divide(scale),
					b: numerator.add(Expression.ONE).divide(scale)
				});
			}
			var a = toSimpleInterval(e.a, precision);
			if (n % 2 === 0) {

				var i = 2;
				while (a.a.sign() < 0 && a.b.sign() > 0) {
					a = toSimpleInterval(e.a, precision * i);
					i *= 2;
				}
			}
			var f = function (x, n, rounding) {
				var scale = Expression.TWO._pow(precision);
				var e = rounding === 'floor' ? x.getNumerator().sign() >= 0 ? Expression.ZERO : Expression.ONE.negate() : x.getNumerator().sign() < 0 ? Expression.ZERO : Expression.ONE;
				return x.getNumerator().multiply(x.getDenominator()._pow(n - 1)).multiply(scale._pow(n))._integerNthRoot(n).add(e).divide(scale.multiply(x.getDenominator()));
			};
			a = a.toExpressionsInterval();
			return SimpleInterval.from({
				a: f(a.a, n, 'floor'),
				b: f(a.b, n, 'ceil')
			});
		} else {
		}
		if (e instanceof PolynomialRoot) {
			return SimpleInterval.from(e.toDecimal(precision));
		}

		if (e instanceof Expression.PolynomialRootSymbol) {
			return SimpleInterval.from(e.toDecimal(precision));
		}
		if (e instanceof Expression.ExpressionPolynomialRoot) {
			return SimpleInterval.from(e.root.toDecimal(precision));
		}
		debugger;
		throw new TypeError("?");
	};

	function Helper(polynomial) {
		this.squareFreeFactors = polynomial.getSquareFreeFactorization().map(function (e) {
			return e.factor;
		});
	}

	Helper.prototype.calcAt = function (point) {
		var result = Expression.ONE;
		for (var iteratorfactor = this.squareFreeFactors[globalThis.Symbol.iterator](), factor = iteratorfactor.next().value; factor != null; factor = iteratorfactor.next().value) {
			result = result.multiply(factor.calcAt(point));
		}
		return result;
	};
	Helper.prototype.numberOfRoots = function (interval) {
		var result = 0;
		var newFactors = [];
		for (var iteratorfactor = this.squareFreeFactors[globalThis.Symbol.iterator](), factor = iteratorfactor.next().value; factor != null; factor = iteratorfactor.next().value) {
			var n = factor.numberOfRoots(interval.toExpressionsInterval());
			result += n;
			if (n > 0) {
				newFactors.push(factor);
			}
		}
		this.squareFreeFactors = newFactors;
		return result;
	};
	Helper.get = function (that, interval) {

		return that.squareFreeFactors.length === 1 ? that.squareFreeFactors[0] : null;
	};
	var calculateNewInterval = function (newPolynomial, zeroFunction, options) {
		if (!newPolynomial.hasIntegerCoefficients()) {
			throw new RangeError("just a check");
		}
		newPolynomial = new Helper(newPolynomial);
		var precision = 8;
		var guess = zeroFunction(precision);
		guess = guess.round(precision);
		while (guess.a.sign() !== guess.b.sign() && !newPolynomial.calcAt(Expression.ZERO).equals(Expression.ZERO) || newPolynomial.numberOfRoots(guess) > 1) {
			precision *= 2;
			guess = zeroFunction(precision);
			guess = guess.round(precision);
			if (precision > 1024) throw new Error();
		}

		var newInterval = guess;
		newPolynomial = Helper.get(newPolynomial, guess);
		return new PolynomialRoot(newPolynomial, newInterval.toExpressionsInterval(), options);
	};

	function PolynomialRoot(polynomial, interval, options) {
		options = options == undefined ? {} : options;

		if (!polynomial.hasIntegerCoefficients()) {
			throw new TypeError();
		}
		if (polynomial.getLeadingCoefficient().sign() < 0) {
			return new PolynomialRoot(polynomial.negate(), interval);
		}
		var content = polynomial.getContent();
		if (!content.equals(Expression.ONE)) {
			return new PolynomialRoot(polynomial.scale(content.inverse()), interval);
		}
		if (!options.skipFactorization) {

			var getFactor = function () {
				var factors = polynomial._factorizeOverTheIntegers();
				for (var f = factors.next().value; f != null; f = factors.next().value) {
					if (f.numberOfRoots(interval) !== 0) {
						return f;
					}
				}
				return null;
			};
			var factor = polynomial.isSquareFreePolynomial() ? getFactor() : polynomial.factorize();

			if (factor != null && !factor.equals(polynomial)) {
				if (factor.numberOfRoots(interval) !== 0) {
					return new PolynomialRoot(factor, interval);
				} else {
					var otherFactor = polynomial.divideAndRemainder(factor, "throw").quotient;
					return new PolynomialRoot(otherFactor, interval);
				}
			}
		}
		if (interval instanceof SimpleInterval) {
			throw new TypeError();
		}
		if (interval.a.subtract(interval.b).getNumerator().sign() > 0) {
			throw new TypeError();
		}

		if (!options.skipFactorization) {

			if (polynomial.numberOfRoots(interval) !== 1) {
				throw new TypeError();
			}
		}
		if (!polynomial.getContent().equals(Expression.ONE)) {
			throw new TypeError();
		}

		this.polynomial = polynomial;

		this.interval = interval;
	}

	PolynomialRoot.prototype.toDecimal = function (precision) {
		if (precision <= 0) {
			return this.interval;
		}

		return this.polynomial.getZero(this.interval, precision);
	};
	PolynomialRoot.prototype.toString = function () {

		return "[root of " + this.polynomial + " near " + this.interval.a.add(this.interval.b).divide(Expression.TWO).toString() + "]";
	};

	PolynomialRoot.prototype.scale = function (k) {

		var newPolynomial = this.polynomial._scaleRoots(k).primitivePart();
		if (!isRational(k)) {

			var root = this;
			newPolynomial = toPolynomialWithIntegerCoefficients(newPolynomial);
			return calculateNewInterval(newPolynomial, function (precision) {
				return toSimpleInterval(root, precision).multiply(toSimpleInterval(k, precision));
			});
		}

		if (!isPowerOf2(k.getDenominator())) {

			var root = this;
			return calculateNewInterval(newPolynomial, function (precision) {
				return toSimpleInterval(root, precision).multiply(toSimpleInterval(k, precision));
			});
		}
		var newInterval = SimpleInterval.from(this.interval).scale(k).toExpressionsInterval();
		return new PolynomialRoot(newPolynomial, newInterval, {
			skipFactorization: true
		});
	};

	PolynomialRoot.prototype.translate = function (k) {

		var newPolynomial = this.polynomial._translateRoots(k).primitivePart();

		var root = this;
		var newInterval = null;
		if (!isRational(k)) {

			newPolynomial = toPolynomialWithIntegerCoefficients(newPolynomial);
			return calculateNewInterval(newPolynomial, function (precision) {
				return toSimpleInterval(root, precision).add(toSimpleInterval(k, precision));
			});
		}

		return calculateNewInterval(newPolynomial, function (precision) {
			return toSimpleInterval(root, precision).add(toSimpleInterval(k, precision));
		}, {
			skipFactorization: true
		});
	};
	PolynomialRoot.prototype.multiply = function (other) {
		var that = this;

		if (true) {
			var g = Math.gcd(that.polynomial.getGCDOfTermDegrees(), other.polynomial.getGCDOfTermDegrees());
			if (g > 1) {
				var tmp = that._pow(g).multiply(other._pow(g))._nthRoot(g);

				if (g % 2 === 0 && that.sign() * other.sign() < 0) {
					tmp = tmp.negate();
				}
				return tmp;
			}
		}

		var $z = new Expression.Polynomial(Polynomial.of(Expression.ONE).shift(1));
		var toPInZ = function (c) {
			return new Expression.Polynomial(Polynomial.of(c));
		};
		var second = other.polynomial._exponentiateRoots(-1).map(toPInZ)._scaleRoots($z);
		var newPolynomial = Polynomial.resultant(that.polynomial.map(toPInZ), second).polynomial.primitivePart();
		return calculateNewInterval(newPolynomial, function (precision) {
			return toSimpleInterval(that, precision).multiply(toSimpleInterval(other, precision));
		});
	};
	PolynomialRoot.prototype.add = function (other) {
		var that = this;
		if (that.polynomial.isEven() && that.polynomial.equals(other.polynomial) && that.equals(other.negate())) {
			return new PolynomialRoot(Polynomial.of(Expression.ONE).shift(1), {
				a: Expression.ONE.negate(),
				b: Expression.ONE
			});
		}

		var $z = new Expression.Polynomial(Polynomial.of(Expression.ONE).shift(1));
		var toPInZ = function (c) {
			return new Expression.Polynomial(Polynomial.of(c));
		};
		var second = other.polynomial._scaleRoots(Expression.ONE.negate()).map(toPInZ)._translateRoots($z);
		var newPolynomial = Polynomial.resultant(that.polynomial.map(toPInZ), second).polynomial.primitivePart();
		return calculateNewInterval(newPolynomial, function (precision) {
			return toSimpleInterval(that, precision).add(toSimpleInterval(other, precision));
		});
	};

	PolynomialRoot.prototype.negate = function () {
		return new PolynomialRoot(this.polynomial._scaleRoots(Expression.ONE.negate()), {
			b: this.interval.a.negate(),
			a: this.interval.b.negate()
		});
	};

	PolynomialRoot.prototype.inverse = function () {

		var newPolynomial = this.polynomial._exponentiateRoots(-1);
		console.assert(this.interval.a.getNumerator().sign() === this.interval.b.getNumerator().sign());
		var that = this;
		return calculateNewInterval(newPolynomial, function (precision) {
			return toSimpleInterval(that, precision).inverse(precision);
		});
	};
	PolynomialRoot.prototype.sign = function () {
		if (this.polynomial.getCoefficient(0).equals(Expression.ZERO)) {
			if (this.interval.a.getNumerator().sign() <= 0 && this.interval.b.getNumerator().sign() >= 0) {
				return 0;
			}
		}
		if (this.interval.a.getNumerator().sign() >= 0) {
			return +1;
		}
		if (this.interval.b.getNumerator().sign() <= 0) {
			return -1;
		}
		throw new TypeError("should not happen");
	};
	PolynomialRoot.prototype._pow = function (n) {
		var pow = function (x, count, accumulator) {
			if (!(count >= 0)) {
				throw new RangeError();
			}
			if (count > Number.MAX_SAFE_INTEGER) {
				throw new RangeError("NotSupportedError");
			}
			return count < 1 ? accumulator : 2 * Math.floor(count / 2) !== count ? pow(x, count - 1, accumulator.multiply(x)) : pow(x._pow(2), Math.floor(count / 2), accumulator);
		};
		if (n === 0) {
			return new PolynomialRoot(Polynomial.of(Expression.ONE.negate(), Expression.ONE), SimpleInterval.from({
				a: Expression.ZERO,
				b: Expression.TWO
			}));
		}

		var g = Math.gcd(n, this.polynomial.getGCDOfTermDegrees());
		if (g === 1) {

			return pow(this, n - 1, this);
		}
		if (g < n) {
			return this._pow(g)._pow(n / g);
		}

		var newInterval = undefined;
		if (n % 2 === 0 && this.interval.b.getNumerator().sign() <= 0) {
			newInterval = {
				a: this.interval.b._pow(n),
				b: this.interval.a._pow(n)
			};
		} else {
			newInterval = {
				a: this.interval.a._pow(n),
				b: this.interval.b._pow(n)
			};
		}

		return new PolynomialRoot(this.polynomial._exponentiateRoots(n), newInterval);
	};
	var $α = function () {
		return new Expression.Symbol('α');

	};

	PolynomialRoot.prototype._nthRoot = function (n) {
		var newPolynomial = this.polynomial._exponentiateRoots(1 / n);
		var root = this;
		return calculateNewInterval(newPolynomial, function (precision) {

			return toSimpleInterval(Expression.NthRoot.makeRoot(new Expression.ExpressionPolynomialRoot(new LazyPolynomialRoot(Polynomial.of(Expression.ZERO, Expression.ONE), Polynomial.of(Expression.ONE), root)), n), precision);
		});
	};
	PolynomialRoot.prototype.equals = function (other) {
		if (this === other) {
			return true;
		}
		if (this.polynomial.getDegree() !== other.polynomial.getDegree()) {
			return false;
		}
		if (this.polynomial.equals(other.polynomial) && this.interval.a.equals(other.interval.a) && this.interval.b.equals(other.interval.b)) {
			return true;
		}
		var i = intersection(this.interval, other.interval);
		if (i == null) {
			return false;
		}
		if (this.polynomial.equals(other.polynomial)) {
			var c = this.polynomial.numberOfRoots(i);
			if (c === 1) {
				return true;
			} else if (c === 0) {
				return false;
			}
			throw new TypeError();
		}
		if (Polynomial.polynomialGCD(this.polynomial, other.polynomial).getDegree() === 0) {
			return false;
		}

		var interval = this.add(other.negate()).interval;
		return interval.a.getNumerator().sign() <= 0 && interval.b.getNumerator().sign() >= 0;
	};
	PolynomialRoot._calculateNewInterval = calculateNewInterval;
	LazyPolynomialRoot._calculateNewInterval = calculateNewInterval;

	PolynomialRoot._toSimpleInterval = toSimpleInterval;
	LazyPolynomialRoot._toSimpleInterval = toSimpleInterval;

	var _isSimpleForUpgrade = function (e, root) {
		if (e instanceof Expression.Multiplication) {
			return true;
		}

		if (e instanceof Expression.Addition) {
			if (e.a instanceof Expression.Addition) {
				console.log('not simple', e + '');
				return false;
			}
			return _isSimpleForUpgrade(e.a, root) && _isSimpleForUpgrade(e.b, root);
		}

		return e.equals(root) || e instanceof Expression.Integer || e instanceof Expression.Complex || e instanceof Expression.NthRoot || e instanceof Expression.Exponentiation && _isSimpleForUpgrade(e.a, root) && e.b instanceof Expression.Integer || e instanceof Expression.Multiplication && _isSimpleForUpgrade(e.a, root) && _isSimpleForUpgrade(e.b, root) || e instanceof Expression.Division && _isSimpleForUpgrade(e.getNumerator(), root) && e.b instanceof Expression.Integer;
	};
	PolynomialRoot._isSimpleForUpgrade = _isSimpleForUpgrade;
	LazyPolynomialRoot._isSimpleForUpgrade = _isSimpleForUpgrade;

	function LazyPolynomialRoot(p1, p2, root) {

		if (!(p1 instanceof Polynomial)) {
			throw new TypeError();
		}
		if (!(p2 instanceof Polynomial) || !(p2.getDegree() === 0)) {
			throw new TypeError();
		}
		if (!p1._testCoefficients(function (c) {
			return !(c instanceof Expression.Division);
		})) {
			throw new TypeError();
		}
		console.assert(root instanceof PolynomialRoot);

		this._p1 = p1;
		this._p2 = p2;
		this._root = root;

	}

	LazyPolynomialRoot.prototype.toDecimal = function (precision) {
		var calcAt = function (polynomial, x, precision) {
			var result = toSimpleInterval(Expression.ZERO, precision);
			for (var i = polynomial.getDegree(); i >= 0; i--) {
				result = result.multiply(x);
				var tmp = toSimpleInterval(polynomial.getCoefficient(i), Math.max(1, precision));

				result = result.add(tmp);
			}
			return result;
		};
		var alphaValue = toSimpleInterval(this._root, precision);
		var p1 = this._p1;
		var p2 = this._p2;
		var a = calcAt(p1, alphaValue, precision);

		var b = calcAt(p2, alphaValue, precision);

		var result = a.multiply(b.inverse(precision));

		return result.toExpressionsInterval();
	};
	LazyPolynomialRoot.prototype.toString = function () {
		return "[" + this.getAlphaExpression() + ", where " + $α() + " = " + this._root + "]";
	};

	function makeExpressionWithPolynomialRoot(p1, p2, root) {
		var v = root;
		if (true) {
			if (p2.getDegree() !== 0 || !(p2.getCoefficient(0) instanceof Expression.Integer)) {
				var p2Inv = p2.modularInverse(root.polynomial).primitivePart();
				var newDenominator = p2.multiply(p2Inv).divideAndRemainder(root.polynomial).remainder;
				if (p2.getDegree() > 0) {
					var c = newDenominator.getContent().getDenominator();
					return makeExpressionWithPolynomialRoot(p1.multiply(p2Inv).scale(c), newDenominator.scale(c), root);
				}
			}
		}
		var reduce = function (p1, p2) {
			if (!(p2.getLeadingCoefficient() instanceof Expression.Integer)) {
				var c = Expression.getConjugate(p2.getLeadingCoefficient());
				return reduce(p1.scale(c), p2.scale(c));
			}

			var p2c = p2.getContent();
			if (!p2c.equals(Expression.ONE)) {
				var g = p1.getContent().gcd(p2c);
				if (!g.equals(Expression.ONE)) {
					p1 = p1.scale(g.inverse());
					p2 = p2.scale(g.inverse());
				}
			}
			return [p1, p2];
		};

		if (p1.equals(Polynomial.ZERO)) {
			return [Polynomial.ZERO, Polynomial.of(Expression.ONE)];
		}
		if (p1.getDegree() === 0 && p2.getDegree() === 0) {
			return reduce(p1, p2);
		}

		var c = function (p) {
			return p.divideAndRemainder(v.polynomial).remainder;
		};

		p1 = c(p1);
		p2 = c(p2);

		var s = p1.map(function (c) {
			return c.getDenominator().inverse();
		}).getContent().getDenominator();
		p1 = p1.scale(s);
		p2 = p2.scale(s);
		if (!p1.hasIntegerCoefficients()) {

			var ok = true;
			if (root instanceof PolynomialRoot) {
				var interval = new LazyPolynomialRoot(p1, Polynomial.of(Expression.ONE), root).toDecimal(53);
				ok = interval.b.sign() >= 0 && interval.a.sign() <= 0;
			}
			if (ok) {

				if (p1.hasRoot(v)) {

					return [Polynomial.ZERO, Polynomial.of(Expression.ONE)];
				}
			}
		}
		return reduce(p1, p2);
	}

	PolynomialRoot._makeExpressionWithPolynomialRoot = makeExpressionWithPolynomialRoot;
	LazyPolynomialRoot._makeExpressionWithPolynomialRoot = makeExpressionWithPolynomialRoot;

	function simplifyExpressionWithPolynomialRoot(p1, p2, root) {
		var tmp = makeExpressionWithPolynomialRoot(p1, p2, root);
		return new LazyPolynomialRoot(tmp[0], tmp[1], root);
	}

	PolynomialRoot.create = function (polynomial, interval, options) {
		return new PolynomialRoot(polynomial, interval, options);
	};
	LazyPolynomialRoot.create = function (polynomial, interval, options) {
		return fromRoot(new PolynomialRoot(polynomial, interval, options));
	};

	function fromRoot(root) {
		return new LazyPolynomialRoot(Polynomial.of(Expression.ZERO, Expression.ONE), Polynomial.of(Expression.ONE), root);
	}

	LazyPolynomialRoot.prototype.scale = function (k) {
		console.assert(Expression.isRealAlgebraicNumber(k));
		var result1 = this._p1.scale(k.getNumerator());
		var result2 = this._p2.scale(k.getDenominator());
		return k instanceof Expression.Integer ? new LazyPolynomialRoot(result1, result2, this._root) : simplifyExpressionWithPolynomialRoot(result1, result2, this._root);
	};
	LazyPolynomialRoot.prototype.translate = function (k) {
		console.assert(Expression.isRealAlgebraicNumber(k));
		return simplifyExpressionWithPolynomialRoot(this._p1.scale(k.getDenominator()).add(this._p2.scale(k.getNumerator())), this._p2.scale(k.getDenominator()), this._root);
	};
	var toPolynomialWithIntegerCoefficients = function (polynomial) {
		if (!polynomial.hasIntegerCoefficients()) {
			var variable = new Expression.Symbol('$$');
			var e = polynomial.calcAt(variable);
			var c = Expression.getConjugateExpression(e);
			if (c != null && !c.equals(e)) {

				return Polynomial.toPolynomial(c, variable);
			}
		}
		return polynomial;
	};

	function upgrade(root, p1, p2) {
		if (p1.getDegree() === 1 && p1.getCoefficient(0).equals(Expression.ZERO) && p1.getCoefficient(1).equals(Expression.ONE)) {

			if (p2.getDegree() === 0) {
				if (p2.getCoefficient(0).equals(Expression.ONE)) {
					return root;
				}
				return root.scale(p2.getCoefficient(0).inverse());
			}
		}

		if (p1.equals(Polynomial.ZERO)) {
			return PolynomialRoot.create(Polynomial.of(Expression.ZERO, Expression.ONE), {
				a: Expression.ZERO,
				b: Expression.ZERO
			});
		}
		if (p1.getDegree() === 0 && p2.getDegree() === 0 && p2.getCoefficient(0).equals(Expression.ONE)) {
			var x = p1.getCoefficient(0);
			return PolynomialRoot.create(Polynomial.of(x.negate(), Expression.ONE), {
				a: x,
				b: x
			});
		}

		if (p2.getDegree() === 0 && p2.getCoefficient(0).equals(Expression.ONE) && p1.getDegree() === p1.getGCDOfTermDegrees() && p1.getLeadingCoefficient().equals(Expression.ONE) && p1.getCoefficient(0).equals(Expression.ZERO) && p1.getDegree() === root.polynomial.getGCDOfTermDegrees()) {

			return root._pow(p1.getDegree());
		}
		if (p2.getDegree() === 0 && p2.getCoefficient(0).equals(Expression.ONE) && p1.getDegree() === 1 && p1.getCoefficient(1).equals(Expression.ONE)) {
			return root.translate(p1.getCoefficient(0));
		}
		if (p2.getDegree() === 0 && p1.getDegree() === 1 && p1.getCoefficient(0).equals(Expression.ZERO)) {
			return root.scale(p1.getCoefficient(1).divide(p2.getCoefficient(0)));
		}
		var scale = Expression.ONE;
		if (p2.getDegree() === 0 && p2.hasIntegerCoefficients()) {
			scale = p2.getLeadingCoefficient();
			p2 = Polynomial.of(Expression.ONE);
		}
		var polynomial = p1.subtract(Polynomial.of(new Expression.Symbol('β')).multiply(p2));
		polynomial = toPolynomialWithIntegerCoefficients(polynomial);
		var toPInBeta = function (c) {
			return new Expression.Polynomial(Polynomial.of(c));
		};
		polynomial = polynomial.map(function (c) {
			return new Expression.Polynomial(Polynomial.toPolynomial(c, new Expression.Symbol('β')));
		});
		var newPolynomial = Polynomial.resultant(polynomial, root.polynomial.map(toPInBeta)).polynomial.primitivePart();
		if (scale !== Expression.ONE) {

			newPolynomial = newPolynomial._scaleRoots(scale.inverse()).primitivePart();
		}
		return PolynomialRoot._calculateNewInterval(newPolynomial, function (precision) {
			return toSimpleInterval(new Expression.ExpressionPolynomialRoot(new LazyPolynomialRoot(p1, p2.scale(scale), root)), precision);
		});
	}

	LazyPolynomialRoot.prototype.multiply = function (other) {
		if (this._root.equals(other._root)) {
			return simplifyExpressionWithPolynomialRoot(this._p1.multiply(other._p1), this._p2.multiply(other._p2), this._root);
		}
		var root = upgrade(this._root, this._p1, this._p2).multiply(upgrade(other._root, other._p1, other._p2));
		return fromRoot(root);
	};
	LazyPolynomialRoot.prototype.add = function (other) {
		if (this._root.equals(other._root)) {
			var g = other._p2.getContent().gcd(this._p2.getContent());
			return simplifyExpressionWithPolynomialRoot(this._p1.multiply(other._p2.scale(g.inverse())).add(other._p1.multiply(this._p2.scale(g.inverse()))), this._p2.scale(g.inverse()).multiply(other._p2.scale(g.inverse())).scale(g), this._root);
		}
		var root = upgrade(this._root, this._p1, this._p2).add(upgrade(other._root, other._p1, other._p2));
		return fromRoot(root);
	};
	LazyPolynomialRoot.prototype.negate = function () {
		return new LazyPolynomialRoot(this._p1.negate(), this._p2, this._root);
	};
	LazyPolynomialRoot.prototype.inverse = function () {
		return simplifyExpressionWithPolynomialRoot(this._p2, this._p1, this._root);
	};
	LazyPolynomialRoot.prototype.sign = function () {
		if (this._p1.equals(Polynomial.ZERO)) {
			return 0;
		}

		var precision = 1;
		while (true) {
			var interval = this.toDecimal(precision);
			if (interval.a.getNumerator().sign() >= 0) {
				return +1;
			}
			if (interval.b.getNumerator().sign() <= 0) {
				return -1;
			}
			precision *= 2;
			if (precision > 8) {
				console.debug('hm...');
			}
		}
	};
	LazyPolynomialRoot.prototype._pow = function (n) {

		return simplifyExpressionWithPolynomialRoot(this._p1._pow(n), this._p2._pow(n), this._root);
	};
	LazyPolynomialRoot.prototype._nthRoot = function (n) {

		if (this._p2.getDegree() === 0 && this._p2.getCoefficient(0).equals(Expression.ONE) && this._p1.getDegree() === 1 && this._p1.getCoefficient(0).equals(Expression.ZERO) && this._p1.getCoefficient(1).equals(Expression.ONE)) {

			var newRoot = this._root._nthRoot(n);
			return new LazyPolynomialRoot(Polynomial.of(Expression.ZERO, Expression.ONE), Polynomial.of(Expression.ONE), newRoot);
		}
		var getPerfectPower = function (p, n) {
			var root = p.getSquareFreePolynomial();
			return root._pow(n).equals(p) ? root : null;
		};
		var root = getPerfectPower(this._p1, n);
		var c = this._p2.getCoefficient(0);
		if (root != null && this._p2.getDegree() === 0 && c instanceof Expression.Integer && c.sign() > 0) {
			return simplifyExpressionWithPolynomialRoot(root, Polynomial.of(c._nthRoot(n)), this._root);
		}
		return this.upgrade()._nthRoot(n);
	};
	LazyPolynomialRoot.prototype.equals = function (other) {
		if (this._root.equals(other._root)) {

			return this._p1.equals(other._p1) && this._p2.equals(other._p2) || this.add(other.negate()).sign() === 0;
		}

		if (toDecimalStringInternal(new Expression.ExpressionPolynomialRoot(this), {
			significantDigits: 3
		}) !== toDecimalStringInternal(new Expression.ExpressionPolynomialRoot(other), {
			significantDigits: 3
		})) {
			return false;
		}

		var result = upgrade(this._root, this._p1, this._p2).equals(upgrade(other._root, other._p1, other._p2));
		return result;
	};
	PolynomialRoot.prototype.upgrade = function () {
		return this;
	};
	LazyPolynomialRoot.prototype.upgrade = function () {
		return fromRoot(upgrade(this._root, this._p1, this._p2));
	};
	PolynomialRoot.prototype._calc = function (polynomial) {
		return upgrade(this, polynomial.calcAt($α()));
	};
	LazyPolynomialRoot.prototype._calc = function (polynomial) {

		var e = polynomial.calcAt(this.getAlphaExpression());
		return simplifyExpressionWithPolynomialRoot(Polynomial.toPolynomial(e.getNumerator(), $α()), Polynomial.toPolynomial(e.getDenominator(), $α()), this._root);
	};
	PolynomialRoot.prototype.getAlpha = function (polynomial) {

		return {
			polynomial: this.polynomial,
			interval: this.interval
		};
	};
	LazyPolynomialRoot.prototype.getAlpha = function (polynomial) {
		return this._root.getAlpha();
	};

	PolynomialRoot.prototype.getAlphaExpression = function (polynomial) {
		return $α();
	};
	LazyPolynomialRoot.prototype.getAlphaExpression = function (polynomial) {
		return this._p1.calcAt($α()).divide(this._p2.calcAt($α()));
	};
	PolynomialRoot.prototype.getAlphaPolynomial = function (polynomial) {
		return Polynomial.of(Expression.ZERO, Expression.ONE);
	};
	LazyPolynomialRoot.prototype.getAlphaPolynomial = function (polynomial) {
		return [this._p1, this._p2];
	};

	globalThis.testables = globalThis.testables || {};
	globalThis.testables.LazyPolynomialRoot = LazyPolynomialRoot;
	globalThis.testables.PolynomialRoot = PolynomialRoot;
	globalThis.testables.toSimpleInterval = toSimpleInterval;
	globalThis.testables.SimpleInterval = SimpleInterval;
	if (true) {

		console.assert(Object.keys(PolynomialRoot).join(' ') === Object.keys(LazyPolynomialRoot).join(' '));
		console.assert(Object.keys(PolynomialRoot.prototype).join(' ') === Object.keys(LazyPolynomialRoot.prototype).join(' '));
		console.assert(PolynomialRoot.prototype.__proto__ === LazyPolynomialRoot.prototype.__proto__);
	}

	self.LazyPolynomialRoot = LazyPolynomialRoot;
}

function SomePolynomialRoot() {
	var usePolynomial = true;

	function SomePolynomialRoot(e, polynomial, rootSymbol) {
		if (usePolynomial && !(e instanceof Polynomial)) {
			throw new TypeError();
		}
		this.e = e;
		this.polynomial = polynomial;
		this.rootSymbol = rootSymbol;
	}

	SomePolynomialRoot.prototype = Object.create(Expression.Symbol.prototype);

	function alpha() {
		return new Expression.Symbol('alpha');
	}

	function isSameRoot(a, b) {
		return a.polynomial.equals(b.polynomial) && a.rootSymbol === b.rootSymbol;
	}

	SomePolynomialRoot.create = function (polynomial) {
		if (usePolynomial) {
			return new SomePolynomialRoot(Polynomial.of(Expression.ZERO, Expression.ONE), polynomial);
		}
		var x = alpha();
		return new SomePolynomialRoot(x, polynomial, x);
	};

	SomePolynomialRoot.prototype.isExact = function () {
		return false;
	};

	var cInvCache = {
		key: null,
		value: null
	};
	var cached = function (key, f) {
		if (cInvCache.key == null || !cInvCache.key[0].equals(key[0]) || !cInvCache.key[1].equals(key[1])) {
			console.log('update cache');
			cInvCache.key = key;
			cInvCache.value = f();
		}
		return cInvCache.value;
	};

	function simplifyExpressionWithPolynomialRoot(e, polynomial) {

		if (e instanceof Expression.Integer) {
			return e;
		}

		var n = usePolynomial && e instanceof Array ? e[0] : (usePolynomial && e instanceof Polynomial ? e : Polynomial.toPolynomial(e.getNumerator(), alpha()));
		var d = usePolynomial && e instanceof Array ? e[1] : (usePolynomial && e instanceof Polynomial ? Polynomial.of(Expression.ONE) : Polynomial.toPolynomial(e.getDenominator(), alpha()));
		var changed = false;

		if (d.getDegree() >= polynomial.getDegree() * 2) {
			n = n.divideAndRemainder(polynomial).remainder;
			changed = true;
		}
		if (d.getDegree() >= polynomial.getDegree() * 2) {
			d = d.divideAndRemainder(polynomial).remainder;
			changed = true;
		}

		if (n.getDegree() < 0) {
			return Expression.ZERO;
		}

		if (!n.hasIntegerCoefficients() || !polynomial.hasIntegerCoefficients() || n.getCoefficient(0).isDivisibleBy(polynomial.getCoefficient(0))) {
			console.count('yes');

			if ((usePolynomial ? n.primitivePart() : n).isDivisibleBy(polynomial)) {
				console.count('yes!!!');
				return Expression.ZERO;
			}
		}

		if (d.getDegree() > 0) {
			var dd = (usePolynomial ? d.primitivePart() : d);
			console.log('modularInverse', dd.toString());

			var scale = cached([dd, polynomial], function () {
				return dd.modularInverse(polynomial).primitivePart();
			});
			d = d.multiply(scale).divideAndRemainder(polynomial).remainder;
			n = n.multiply(scale).divideAndRemainder(polynomial).remainder;
			changed = true;
		}

		if (!changed) {
			return new SomePolynomialRoot(e, polynomial);
		}

		var e1 = n.calcAt(alpha()).divide(d.calcAt(alpha()));
		if (e1 instanceof Expression.Integer) {
			return e1;
		}
		if (usePolynomial) {
			if (d.getDegree() !== 0) {
				throw new Error();
			}
			return new SomePolynomialRoot(n.map(function (c) {
				return c.divide(d.getCoefficient(0));
			}), polynomial);
		}
		return new SomePolynomialRoot(e1, polynomial);
	}

	SomePolynomialRoot.prototype.negate = function () {
		return new SomePolynomialRoot(this.e.negate(), this.polynomial);
	};
	SomePolynomialRoot.prototype.equals = function (other) {
		if (other === Expression.ZERO) {
			return false;
		}
		return this.subtract(other).equals(Expression.ZERO);
	};
	SomePolynomialRoot.prototype.simplifyExpression = function () {
		return this;
	};

	SomePolynomialRoot.prototype.toString = function (options) {

		var x = this.rootSymbol || alpha();
		return "[" + this.e.calcAt(x) + ", where " + x + " is a root of " + this.polynomial + "]";
	};

	SomePolynomialRoot.prototype.toMathML = function (options) {
		throw new TypeError();
	};

	SomePolynomialRoot.prototype.multiply = function (other) {
		if (other instanceof SomePolynomialRoot) {
			if (!isSameRoot(this, other)) {
				throw new TypeError();
			}
			if (usePolynomial) {

				var ecinv = other.e.getContent().getDenominator();
				return simplifyExpressionWithPolynomialRoot(this.e.multiply(other.e.scale(ecinv)).scale(ecinv.inverse()), this.polynomial);
			}
			return simplifyExpressionWithPolynomialRoot(this.e.multiply(other.e), this.polynomial);
		}
		return simplifyExpressionWithPolynomialRoot(usePolynomial ? this.e.scale(other) : this.e.multiply(other), this.polynomial);
	};
	SomePolynomialRoot.prototype.add = function (other) {
		if (other instanceof SomePolynomialRoot) {
			if (!isSameRoot(this, other)) {
				throw new TypeError();
			}
			return simplifyExpressionWithPolynomialRoot(this.e.add(other.e), this.polynomial);
		}
		return simplifyExpressionWithPolynomialRoot(usePolynomial ? this.e.add(Polynomial.of(other)) : this.e.add(other), this.polynomial);
	};
	SomePolynomialRoot.prototype.inverse = function () {
		return simplifyExpressionWithPolynomialRoot(usePolynomial ? [Polynomial.of(Expression.ONE), this.e] : this.e.inverse(), this.polynomial);
	};

	SomePolynomialRoot.prototype.divide = function (other) {
		if (other instanceof SomePolynomialRoot) {
			if (isSameRoot(this, other)) {
				if (usePolynomial) {
					var tmp = this.e.divideAndRemainder(other.e);
					if (tmp.remainder.getDegree() < 0) {
						return simplifyExpressionWithPolynomialRoot(tmp.quotient, this.polynomial);
					}
					return simplifyExpressionWithPolynomialRoot([this.e, other.e], this.polynomial);
				}
				return simplifyExpressionWithPolynomialRoot(this.e.divide(other.e), this.polynomial);
			}
		}
		return this.multiply(other.inverse());
	};

	SomePolynomialRoot.prototype.divideExpression = function (other) {
		if (usePolynomial) {
			if (other.equals(Expression.ZERO)) {
				return Expression.ZERO;
			}
			return simplifyExpressionWithPolynomialRoot([Polynomial.of(other), this.e], this.polynomial);
		}
		return simplifyExpressionWithPolynomialRoot(other.divide(this.e), this.polynomial);
	};
	SomePolynomialRoot.prototype.multiplyExpression = function (other) {
		return simplifyExpressionWithPolynomialRoot(usePolynomial ? this.e.map(function (c) {
			return other.multiply(c);
		}) : other.multiply(this.e), this.polynomial);
	};
	SomePolynomialRoot.prototype.addExpression = function (other) {
		return simplifyExpressionWithPolynomialRoot(usePolynomial ? Polynomial.of(other).add(this.e) : other.add(this.e), this.polynomial);
	};

	SomePolynomialRoot.prototype.getPrecedence = function () {
		throw new TypeError();
	};
	SomePolynomialRoot.prototype.isRightToLeftAssociative = function () {
		throw new TypeError();
	};
	SomePolynomialRoot.prototype.isUnaryPlusMinus = function () {
		throw new TypeError();
	};
	SomePolynomialRoot.prototype.isNegative = function () {
		throw new TypeError();
	};

	SomePolynomialRoot.prototype._nthRoot = function (n) {
		throw new TypeError();
	};
	SomePolynomialRoot.prototype.pow = function (count) {
		throw new TypeError();
	};
	SomePolynomialRoot.prototype._pow = function (count) {
		throw new TypeError();
	};

	SomePolynomialRoot.prototype.calcAt = function (x, xPows) {
		var k = Math.ceil(Math.sqrt(this.polynomial.getDegree() + 1));
		var computePows = function (n) {
			var start = Date.now();
			while (xPows.length <= n) {
				xPows.push(xPows[xPows.length - 1].multiply(x));
			}
			var end = Date.now();
			if (end - start > 10) {
				console.log('xPows', end - start);
			}
		};
		var c = function (p) {

			computePows(p.getDegree());
			var s = Expression.ZERO;
			for (var i = 0; i <= p.getDegree(); i += 1) {
				s = s.add(p.getCoefficient(i).multiply(xPows[i]));
			}
			return s;
		};
		var e = this.e;
		var e1 = null;
		if (usePolynomial && e instanceof Polynomial) {

			var ecinv = e.getContent().getDenominator();

			var scaled = e.map(function (c) {
				return ecinv.divide(c.getDenominator()).multiply(c.getNumerator());
			});
			e1 = c(scaled).multiply(ecinv.inverse());
		} else {
			e1 = c(Polynomial.toPolynomial(e.getNumerator(), alpha())).divide(c(Polynomial.toPolynomial(e.getDenominator(), alpha())));
		}
		return e1;
	};

	self.SomePolynomialRoot = SomePolynomialRoot;
}

function PolynomialRootMath() {
	Expression.PolynomialRootSymbol = function () {
		throw new TypeError();
	};

	function ExpressionWithPolynomialRoot() {
		throw new TypeError();
	}

	Expression.ExpressionWithPolynomialRoot = ExpressionWithPolynomialRoot;

	function ExpressionPolynomialRoot(root) {
		var alpha = root.getAlpha();
		var $tmpp1_p2 = root.getAlphaPolynomial();
		var p1 = $tmpp1_p2[0];
		var p2 = $tmpp1_p2[1];
		var polynomial = alpha.polynomial;
		var interval = alpha.interval;
		if (p1.getDegree() <= 0 && p2.getDegree() <= 0) {
			return p1.getCoefficient(0).divide(p2.getCoefficient(0));
		}
		if (polynomial.getDegree() === 1 || polynomial.getDegree() === 2 || (polynomial.getDegree() === 4 && false) || polynomial.getDegree() === polynomial.getGCDOfTermDegrees()) {

			if (polynomial._log2hypot() < 256) {
				var roots = polynomial.getDegree() === polynomial.getGCDOfTermDegrees() && polynomial.getDegree() % 2 === 1 ? [polynomial.getCoefficient(0).negate().divide(polynomial.getLeadingCoefficient())._nthRoot(polynomial.getDegree())] : polynomial.getroots();
				for (var iteratorrr = roots[globalThis.Symbol.iterator](), rr = iteratorrr.next().value; rr != null; rr = iteratorrr.next().value) {
					if (!Expression.has(rr, ExpressionPolynomialRoot)) {
						if (Expression._isPositive(rr.subtract(interval.a)) && Expression._isPositive(rr.subtract(interval.b).negate()) || rr.equals(interval.b) || rr.equals(interval.a)) {
							if (p1.getDegree() === 1 && p1.getCoefficient(0).equals(Expression.ZERO) && p1.getCoefficient(1).equals(Expression.ONE) && p2.getDegree() === 0 && p2.getCoefficient(0).equals(Expression.ONE)) {
								return rr;
							} else {
								var n = p1.calcAt(rr);
								var d = p2.calcAt(rr);
								return n.divide(d);
							}
						}
					}
				}
			}
		}
		if (polynomial.getDegree() < 3) {

		}
		if (polynomial.getDegree() / polynomial.getGCDOfTermDegrees() > 64 * 2 * 32) {
			throw new Error();
		}
		Expression.Symbol.call(this, null);
		this.root = root;
		Object.freeze(this);
	}

	ExpressionPolynomialRoot.prototype = Object.create(Expression.Symbol.prototype);

	ExpressionPolynomialRoot.create = function (polynomial, interval, options) {
		return new ExpressionPolynomialRoot(LazyPolynomialRoot.create(polynomial, interval, options));
	};

	ExpressionPolynomialRoot.prototype.multiplyInteger = function (x) {
		return x.multiplyPolynomialRoot(this);
	};
	ExpressionPolynomialRoot.prototype.multiply = function (e) {
		return e.multiplyPolynomialRoot(this);
	};
	ExpressionPolynomialRoot.prototype.multiplyExpression = function (e) {
		if (e.equals(Expression.ONE)) {
			return this;
		}

		if (Expression.isConstant(e) && !Expression.has(e, Expression.Complex)) {
			return this.multiply(e);
		}
		return Expression.Symbol.prototype.multiplyExpression.call(this, e);
	};
	ExpressionPolynomialRoot.prototype.multiplyAddition = function (e) {
		if (Expression.isConstant(e) && !Expression.has(e, Expression.Complex)) {
			return this.multiplyExpression(e);
		}
		return Expression.Symbol.prototype.multiplyAddition.call(this, e);
	};
	ExpressionPolynomialRoot.prototype.multiplyComplex = function (x) {
		return this.multiply(x);
	};
	Expression.prototype.multiplyPolynomialRoot = function (root) {
		if (Expression.isRealAlgebraicNumber(this) && !Expression.has(this, Expression.ExpressionWithPolynomialRoot)) {
			var k = this;
			if (k.equals(Expression.ZERO)) {
				return k;
			}
			if (k.equals(Expression.ONE)) {
				return root;
			}
			return new ExpressionPolynomialRoot(root.root.scale(k));
		}
		if (this instanceof Expression.Complex && !this.imaginary.equals(Expression.ONE)) {
			return this.imaginary.multiply(root).multiply(Expression.I).add(this.real.multiply(root));
		}

		return this.multiplyExpression(root);
	};
	ExpressionPolynomialRoot.prototype._pow = function (n) {
		if (n === 1) {
			return this;
		}
		return new ExpressionPolynomialRoot(this.root._pow(n));
	};
	ExpressionPolynomialRoot.prototype.pow = function (e) {
		if (e instanceof Expression.Integer) {
			return this._pow(e.toNumber());
		}

		if (e instanceof Expression.Division && e.getDenominator() instanceof Expression.Integer) {

			return this._nthRoot(e.getDenominator().toNumber()).pow(e.getNumerator());
		}
		return Expression.Symbol.prototype.pow.call(this, e);
	};
	ExpressionPolynomialRoot.prototype.multiplyPolynomialRoot = function (x) {
		var y = this;
		return new ExpressionPolynomialRoot(x.root.multiply(y.root));
	};
	ExpressionPolynomialRoot.prototype.add = function (e) {
		return e.addPolynomialRoot(this);
	};
	ExpressionPolynomialRoot.prototype.addPolynomialRoot = function (x) {
		var y = this;
		return new ExpressionPolynomialRoot(x.root.add(y.root));
	};
	Expression.prototype.addPolynomialRoot = function (root) {
		if (Expression.isRealAlgebraicNumber(this) && !Expression.has(this, Expression.ExpressionWithPolynomialRoot)) {
			var k = this;
			if (k.equals(Expression.ZERO)) {
				return root;
			}
			return new ExpressionPolynomialRoot(root.root.translate(k));
		}

		return this.addExpression(root);
	};
	ExpressionPolynomialRoot.prototype.addExpression = function (e) {
		return this.add(e);
	};
	ExpressionPolynomialRoot.prototype.divide = function (e) {

		if (e instanceof Expression.Exponentiation) {
			return e.divideExpression(this);
		}
		if (e instanceof Expression.Multiplication && e.a instanceof Expression.Integer && e.b instanceof Expression.Exponentiation) {
			return this.multiply(e.a.inverse()).divide(e.b);
		}

		var eInv = e.inverse();

		if (e.equals(Expression.E)) {
			console.warn('inverse is a division:' + eInv);
			return e.divideExpression(this);
		}

		return this.multiply(eInv);
	};
	ExpressionPolynomialRoot.prototype.divideExpression = function (x) {
		if (x.equals(Expression.ZERO)) {
			return x;
		}

		return x.multiply(this.inverse());
	};
	ExpressionPolynomialRoot.prototype.inverse = function () {
		return new ExpressionPolynomialRoot(this.root.inverse());
	};
	ExpressionPolynomialRoot.prototype.sign = function () {
		return this.root.sign();
	};
	var toRadicalExpression = function (root) {
		root = root.upgrade();
		var polynomialRoot = root.getAlpha();

		if (polynomialRoot.polynomial.getDegree() === 1) {

			return polynomialRoot.polynomial.getroots()[0];
		}

		var g = polynomialRoot.polynomial.getGCDOfTermDegrees();
		if (g > 1) {
			var v = toRadicalExpression(root._pow(g));
			if (v != null) {
				if (v.equals(Expression.ONE)) {
					return v;
				}
				var vg = Expression.NthRoot.makeRoot(v, g);
				return g % 2 === 1 || root.sign() > 0 ? vg : new Expression.Negation(vg);
			}
		}

		var h = polynomialRoot.polynomial._getShiftToDepressed();
		if (!h.equals(Expression.ZERO)) {
			var tmp = toRadicalExpression(root.translate(h));
			if (tmp != null) {
				return new Expression.Addition(tmp, h.negate());
			}
		}
		return null;
	};

	function EmptyMap() {
	}

	EmptyMap.prototype.has = function () {
		return false;
	};
	EmptyMap.prototype.set = function () {
	};
	EmptyMap.prototype.get = function () {
		return null;
	};

	function weakMap() {
		return typeof WeakMap !== 'undefined' ? new WeakMap() : new EmptyMap();
	}

	var cache2rounding = weakMap();
	var DEFAULT_ROUNDING = {fractionDigits: 3};

	ExpressionPolynomialRoot.prototype._toDecimalString = function (options) {
		options = options || {};
		var rounding = options.rounding || DEFAULT_ROUNDING;
		var cache2 = cache2rounding.get(rounding);
		if (cache2 == null) {
			cache2 = weakMap();
			cache2rounding.set(rounding, cache2);
		}
		var s = cache2.get(this);
		if (s != null) {
			return s;
		}
		s = toDecimalStringInternal(this, rounding);
		cache2.set(this, s);
		return s;
	};

	ExpressionPolynomialRoot.prototype.toString = function (options) {
		options = options || null;

		if (options == null || options.rounding == null) {
			var re = this._toRadicalExpression();
			if (re != null) {
				return re.toString(options);
			}
		}
		return this._toDecimalString(options);
	};
	ExpressionPolynomialRoot.prototype.equals = function (other) {
		if (other instanceof ExpressionPolynomialRoot) {
			return this.root.equals(other.root);
		}

		if (other instanceof Expression.Integer) {
			if (other.equals(Expression.ZERO)) {
				return false;
			}
		}
		if (!Expression.isRealAlgebraicNumber(other)) {
			return false;
		}

		return this.subtract(other).equals(Expression.ZERO);
	};
	ExpressionPolynomialRoot.prototype.compare4MultiplicationComplex = function (x) {
		return -1;

	};
	ExpressionPolynomialRoot.prototype.compare4MultiplicationNthRoot = function (x) {
		return 0;
	};
	ExpressionPolynomialRoot.prototype.compare4Multiplication = function (y) {
		if (y instanceof Expression.Complex) {
			return +1;

		}
		if (y instanceof Expression.Integer) {
			return +1;
		}
		if (y instanceof ExpressionPolynomialRoot) {
			return 0;
		}
		if (y instanceof Expression.NthRoot) {
			return 0;
		}
		if (y instanceof Expression.Symbol) {
			return -1;
		}
		return Expression.Symbol.prototype.compare4Multiplication.call(this, y);
	};
	ExpressionPolynomialRoot.prototype.compare4MultiplicationSymbol = function (x) {
		return +1;
	};
	ExpressionPolynomialRoot.prototype.compare4Addition = function (y) {
		if (y instanceof ExpressionPolynomialRoot) {
			return 0;
		}
		if (y instanceof Expression.Symbol) {
			return +1;
		}
		if (y instanceof Expression.NthRoot) {
			return 0;
		}
		if (Expression.isRealAlgebraicNumber(y)) {
			return 0;
		}
		return Expression.Symbol.prototype.compare4Addition.call(this, y);
	};
	ExpressionPolynomialRoot.prototype.compare4AdditionSymbol = function (x) {
		return -1;
	};
	ExpressionPolynomialRoot.prototype.compare4AdditionNthRoot = function (x) {
		return 0;
	};

	ExpressionPolynomialRoot.prototype._nthRoot = function (n) {
		if (this.root.sign() < 0 && n % 2 === 0) {
			if (n !== 2) {
				throw new RangeError("NotSupportedError");
			}

			return Expression.I.multiply(this.negate()._nthRoot(n));
		}
		return new ExpressionPolynomialRoot(this.root._nthRoot(n));
	};

	ExpressionPolynomialRoot.prototype.upgrade = function () {
		return new ExpressionPolynomialRoot(this.root.upgrade());
	};

	ExpressionPolynomialRoot.prototype.isNegative = function () {
		return this.root.sign() < 0;
	};

	Expression.prototype.upgrade = function () {
		return this;
	};

	ExpressionPolynomialRoot.prototype.isExact = function () {

		if (true) {
			var re = this._toRadicalExpression();
			if (re != null) {
				return true;
			}
		}
		return false;
	};

	ExpressionPolynomialRoot.prototype.negate = function () {
		return new ExpressionPolynomialRoot(this.root.negate());
	};

	ExpressionPolynomialRoot.prototype.simplifyExpression = function () {
		return this;
	};

	ExpressionPolynomialRoot.prototype.toMathML = function (options) {
		options = options || null;
		if (options == null || options.rounding == null) {
			var re = this._toRadicalExpression();
			if (re != null) {
				return re.toMathML(options);
			}
		}
		return Expression._decimalToMathML(this._toDecimalString(options).replaceAll('*10^', 'e'));

	};

	var cache = weakMap();
	ExpressionPolynomialRoot.prototype._toRadicalExpression = function () {
		if (cache.has(this)) {
			return cache.get(this);
		}
		var p = this.root.getAlpha().polynomial;
		if (p.getDegree() / p.getGCDOfTermDegrees() < 3 && this.root.getAlphaPolynomial()[0].getGCDOfTermDegrees() % p.getGCDOfTermDegrees() === 0 || p.getDegree() / p.getGCDOfTermDegrees() < 10 && LazyPolynomialRoot._isSimpleForUpgrade(this.root.getAlphaExpression(), new Expression.Symbol('α'))) {
			var re = toRadicalExpression(this.root);
			if (re != null) {
				cache.set(this, re);
				return re;
			}
		}
		cache.set(this, null);
	};

	ExpressionPolynomialRoot.prototype.getPrecedence = function (options) {
		if (options != null && options.rounding != null) {
			return 1000;
		}

		if (true) {
			var re = this._toRadicalExpression();
			if (re != null) {
				return re.getPrecedence();
			}
		}
		return 1000;
	};
	ExpressionPolynomialRoot.prototype.isRightToLeftAssociative = function () {
		return true;
	};
	ExpressionPolynomialRoot.prototype.isUnaryPlusMinus = function () {
		return true;
	};

	ExpressionPolynomialRoot.prototype._calc = function (polynomial) {
		return new ExpressionPolynomialRoot(this.root._calc(polynomial));
	};

	Expression.ExpressionPolynomialRoot = ExpressionPolynomialRoot;

	Expression.toPolynomialRoot = function (e) {
		var x = e instanceof Expression.NthRoot ? e.a : e;
		var n = e instanceof Expression.NthRoot ? e.n : 1;
		var symbol = new Expression.Symbol('x');
		if (!(x.getDenominator() instanceof Expression.Integer)) {
			throw new TypeError();
		}
		var p = Polynomial.toPolynomial(Expression.getConjugateExpression(symbol._pow(n).subtract(x).getNumerator()), symbol);

		if (p.getDegree() <= 8 && (true || isSmall(p))) {
			var factor = p.factorize();
			if (factor != null && factor.getDegree() < p.getDegree() && factor.getDegree() === 4) {
				var roots = Polynomial.polynomialGCD(factor, Polynomial.toPolynomial(symbol._pow(n).subtract(x), symbol)).getroots();
				for (var iteratorroot = roots[globalThis.Symbol.iterator](), root = iteratorroot.next().value; root != null; root = iteratorroot.next().value) {
					if (root._pow(n).equals(x)) {

						return Expression._isPositive(root) || n % 2 !== 0 ? root : root.negate();
					}
				}
			}
		}
		while (p.getDegree() > 0) {

			var factor = p.factorize() || p;
			var isComplex = n === 2 && Expression.has(e.radicand, Expression.Complex);
			var zeros = factor.getZeros(isComplex);
			if (n % 2 === 0 && zeros.length === 2) {

				if (Expression._isPositive(zeros[1]) && Expression._isPositive(x)) {
					return zeros[1];
				}
			}

			for (var iteratorzero = zeros[globalThis.Symbol.iterator](), zero = iteratorzero.next().value; zero != null; zero = iteratorzero.next().value) {
				if (zero.root != null && Expression._isPositive(zero) || isComplex && Expression._isPositive(Expression.getComplexNumberParts(zero).real)) {
					if (zero._pow(n).equals(x)) {
						return zero;
					}
				}
			}

			p = p.divideAndRemainder(factor, "throw").quotient;
		}
		console.error(e.toString());
		return undefined;
	};

	Polynomial.prototype.signVariations = function () {
		var result = 0;
		var sign = 0;
		for (var i = this.a.size - 1; i >= 0; i -= 1) {
			var s = this.a.coefficient(i).sign();
			if (s !== 0) {
				if (sign === 0) {
					sign = s;
				} else {
					if (sign !== s) {
						sign = s;
						result += 1;
					}
				}
			}
		}
		return result;
	};

	Polynomial.prototype._getNonNegativeRealRootIntervals = function () {

		var B = this.getPositiveRealRootsBound();
		if (B.equals(Expression.ZERO)) {
			return [];
		}

		var p = this._scaleRoots(B.inverse());
		var maxPositiveRealRoots = (this.getCoefficient(0).equals(Expression.ZERO) ? 1 : 0) + this.signVariations();
		var L = function (a, b, q) {
			var zero = q.getCoefficient(0).equals(Expression.ZERO);
			var newQ = zero ? q.divideAndRemainder(Polynomial.of(Expression.ZERO, Expression.ONE), "throw").quotient : q;
			var qq = newQ._exponentiateRoots(-1)._translateRoots(Expression.ONE.negate());

			var v = qq.signVariations();
			if (v === 1 && zero) {
				v = 0 / 0;
			}
			if (v === 0 && zero) {
				return [{
					a: a,
					b: a
				}];
			}
			if (v === 1 && qq.getCoefficient(0).equals(Expression.ZERO)) {
				v = 0 / 0;
			}
			if (v === 1) {
				return [{
					a: a,
					b: b
				}];
			} else if (v !== 0) {
				var firstQ = q._scaleRoots(Expression.TWO);
				var middle = a.add(b).divide(Expression.TWO);
				var first = L(a, middle, firstQ);
				if (first.length >= maxPositiveRealRoots) {
					return first;
				}
				var secondQ = firstQ._translateRoots(Expression.ONE.negate());
				var second = L(middle, b, secondQ);
				return first.concat(second);
			}
			return [];
		};
		return L(Expression.ZERO, Expression.ONE, p).map(function (entry) {
			return ({
				a: entry.a.multiply(B),
				b: entry.b.multiply(B)
			});
		});
	};

	Polynomial.prototype.getRootIntervals = function () {
		return this._scaleRoots(Expression.ONE.negate())._getNonNegativeRealRootIntervals().map(function (entry) {
			return ({
				a: entry.b.negate(),
				b: entry.a.negate()
			});
		}).reverse().concat(this._getNonNegativeRealRootIntervals());
	};

	Polynomial.prototype.getPositiveRealRootsBound = function () {

		var M = null;

		var n = this.getDegree();
		var an = this.getLeadingCoefficient();
		for (var i = 0; i <= this.getDegree() - 1; i += 1) {
			var v = this.getCoefficient(i).negate().truncatingDivide(an);
			if (v.sign() >= 0) {
				var c = Expression.TWO.multiply(v._integerNthRoot(n - i).add(Expression.ONE));
				if (M == null || M.compareTo(c) < 0) {
					M = c;
				}
			}
		}
		if (M == null) {
			return Expression.ZERO;
		}

		M = Expression.TWO._pow(M.getNumerator().bitLength() - M.getDenominator().bitLength() + 1);

		return M;
	};

	Polynomial.prototype.getAllRootsBound = function () {
		console.assert(this.hasIntegerCoefficients());

		var cf = this.map(function (c) {
			return c.abs().negate();
		}).add(Polynomial.of(this.getLeadingCoefficient().abs().multiply(Expression.TWO)).shift(this.getDegree()));
		return cf.getPositiveRealRootsBound();
	};

	Polynomial.prototype.getZero = function (interval, precision) {
		var floorDiv = function (a, b) {
			if (b.compareTo(Expression.ZERO) < 0) {
				a = a.negate();
				b = b.negate();
			}
			return a.compareTo(Expression.ZERO) >= 0 ? a.truncatingDivide(b) : a.add(Expression.ONE).truncatingDivide(b).subtract(Expression.ONE);
		};
		var roundFloor = function (point, e) {
			var n = point.getNumerator().multiply(e);
			var d = point.getDenominator();
			return floorDiv(n, d);
		};
		var sign = function (v) {
			return Math.sign(v.getNumerator().compareTo(Expression.ZERO));
		};

		var BASE = Expression.TWO;
		var e = Expression.pow(BASE, precision);
		if (!(e instanceof Expression.Integer)) {
			throw new RangeError("epsilon^-1 is not an integer");
		}
		var a = interval.a;
		var b = interval.b;

		if (e.multiply(a.getDenominator().multiply(b.getNumerator()).subtract(b.getDenominator().multiply(a.getNumerator()))).compareTo(b.getDenominator().multiply(a.getDenominator())) > 0) {

			var tmp = true && precision >= 16 / Math.log10(BASE.toNumber()) ? this.getZero(interval, Math.floor(precision / 4)) : interval;
			a = tmp.a;
			b = tmp.b;

			var n = this.getDegree();
			var p = this._scaleRoots(e);
			p = p.primitivePart();
			var sa = roundFloor(a, e).add(Expression.ONE);
			var sb = roundFloor(b, e);
			console.assert(sa.multiply(a.getDenominator()).subtract(a.getNumerator().multiply(e)).compareTo(Expression.ZERO) >= 0);
			console.assert(sb.multiply(b.getDenominator()).subtract(b.getNumerator().multiply(e)).compareTo(Expression.ZERO) <= 0);

			var pa = p.calcAt(sa);
			var pb = p.calcAt(sb);
			var spb = sign(pb);
			var spa = sign(pa);
			if (spa === 0) {
				return {
					a: sa.divide(e),
					b: sa.divide(e)
				};
			}
			if (spb === 0) {
				return {
					a: sb.divide(e),
					b: sb.divide(e)
				};
			}
			if (spa === spb) {
				if (spa !== (sign(this.calcAt(a)) || sign(this.calcAt(b).negate()) || spa)) {
					return {
						a: a,
						b: sa.divide(e)
					};
				}
				if (spb !== sign(this.calcAt(b))) {
					return {
						a: sb.divide(e),
						b: b
					};
				}
				throw new RangeError();
			}
			a = sa;
			b = sb;

			var cc = 0;
			var d = p.derive();
			var width = b.subtract(a);
			while (width.compareTo(Expression.ONE) > 0) {
				var middle = a.add(width.truncatingDivide(Expression.TWO));

				if (cc % 3 !== 2 && width.compareTo(a.abs()) < 0) {

					var x = cc % 3 === 1 ? a : b;
					var px = x === a ? pa : (x === b ? pb : undefined);
					var c = d.calcAt(x);
					if (!c.equals(Expression.ZERO)) {
						x = x.subtract(px.truncatingDivide(c));
						if (x.compareTo(a) <= 0) {
							x = a.add(Expression.ONE);
						}
						if (x.compareTo(b) >= 0) {
							x = b.subtract(Expression.ONE);
						}

						middle = x;
					}
				}
				cc += 1;

				var v = p.calcAt(middle);
				var sv = sign(v);
				if (sv === spb) {
					b = middle;
					pb = v;
				} else if (sv === spa) {
					a = middle;
					pa = v;
				} else {
					a = middle;
					b = middle;
					pa = v;
					pb = v;
				}
				width = b.subtract(a);
			}

			a = a.divide(e);
			b = b.divide(e);
		}
		return {
			a: a,
			b: b
		};
	};

	Polynomial.prototype.hasRoot = function (polynomialRoot) {
		var f = this;
		if (f.equals(Polynomial.ZERO)) {
			return true;
		}

		if (!f.hasIntegerCoefficients() && f.hasComplexCoefficients()) {
			return f.map(function (c) {
				return c instanceof Expression.Integer ? c : c.real;
			}).hasRoot(polynomialRoot) && f.map(function (c) {
				return c instanceof Expression.Integer ? Expression.ZERO : c.imaginary;
			}).hasRoot(polynomialRoot);
		}

		if (!f.hasIntegerCoefficients() && !f.hasComplexCoefficients() && !f._testCoefficients(function (c) {
			return !Expression.has(c, Expression.Complex);
		}) && f._testCoefficients(function (c) {
			return Expression.isConstant(c);
		})) {
			return f.map(function (c) {
				return Expression.getComplexNumberParts(c).real;
			}).hasRoot(polynomialRoot) && f.map(function (c) {
				return Expression.getComplexNumberParts(c).imaginary;
			}).hasRoot(polynomialRoot);
		}

		var p = polynomialRoot.polynomial;
		var g = null;

		if (!f.hasIntegerCoefficients()) {
			var variable = new Expression.Symbol('~');
			var ff = f.calcAt(variable);
			var tmp = Expression.getMultivariatePolynomial(ff);
			if (tmp != null && !tmp.v.equals(variable) && tmp.v instanceof Expression.Symbol) {
				g = Polynomial.polynomialGCD(Polynomial.toPolynomial(tmp.p.getContent(), variable), p);
			}
		}
		if (g == null) {
			g = Polynomial.polynomialGCD(f, p);
		}

		if (g.getDegree() < 1) {
			return false;
		}
		var i = polynomialRoot.interval;

		if (!g.hasIntegerCoefficients()) {

			var variable = new Expression.Symbol('$$');
			var e = g.calcAt(variable);
			var c = Expression.getComplexNumberParts(e);
			if (c != null && !c.imaginary.equals(Expression.ZERO)) {
				g = Polynomial.toPolynomial(c.real.subtract(c.imaginary.multiply(Expression.I)).multiply(e), variable).getSquareFreePolynomial();
			}

		}

		var n = g._translateRoots(i.a.negate()).signVariations() - g._translateRoots(i.b.negate()).signVariations();
		return n % 2 === 1;

	};

	Polynomial.prototype.numberOfRoots = function (interval) {
		interval = interval == undefined ? null : interval;

		if (!this.hasIntegerCoefficients()) {

			throw new RangeError();
		}
		if (interval == null) {
			interval = {
				a: this._scaleRoots(Expression.ONE.negate()).getPositiveRealRootsBound().negate(),
				b: this.getPositiveRealRootsBound()
			};
		}
		var p = this;
		if (!interval.a.equals(Expression.ZERO)) {
			p = p._scaleRoots(interval.a.inverse())
				._translateRoots(Expression.ONE.negate());
			interval = {
				a: Expression.ZERO,
				b: interval.b.divide(interval.a).subtract(Expression.ONE)
			};
			if (interval.b.getNumerator().sign() < 0) {
				interval = {
					a: interval.a,
					b: interval.b.negate()
				};
				p = p._scaleRoots(Expression.ONE.negate());
			}
		}
		console.assert(interval.a.equals(Expression.ZERO));
		var zeros = 0;
		while (p.getCoefficient(zeros).equals(Expression.ZERO)) {
			zeros += 1;
		}
		if (zeros > 1) {
			throw new RangeError();
		}
		if (zeros > 0) {
			p = p.divideAndRemainder(Polynomial.of(Expression.ONE).shift(zeros), "throw").quotient;
		}
		return (zeros > 0 ? 1 : 0) + p._exponentiateRoots(-1)
			._scaleRoots(interval.b)
			._translateRoots(Expression.ONE.negate())
			._getNonNegativeRealRootIntervals().length;
	};

	Polynomial.prototype.getZeros = function (complex) {
		complex = complex == undefined ? false : complex;

		if (this.getCoefficient(0).equals(Expression.ZERO)) {
			if (this.getLeadingCoefficient().equals(Expression.ZERO)) {
				throw new TypeError();
			}
			var i = 0;
			while (this.getCoefficient(i).equals(Expression.ZERO)) {
				i += 1;
			}
			var tmp = this.divideAndRemainder(Polynomial.of(Expression.ONE).shift(i)).quotient.getZeros(complex);
			return tmp.concat(new Array(i).fill(Expression.ZERO));
		}

		var content = this.getContent();
		var f = this.scale(content.getDenominator()).divideAndRemainder(Polynomial.of(content.getNumerator()), "throw").quotient;

		var tmp = f.squareFreeFactors();
		var a0 = tmp.a0;
		var a1 = tmp.a1;

		if (a0.getDegree() !== 0) {
			var tmp1 = a1.getZeros(complex);
			var tmp2 = a0.getZeros(complex);
			var result = [];
			var previous = undefined;
			for (var i = 0; i < tmp2.length; i += 1) {
				var zero = tmp2[i];
				if (zero !== previous) {
					result.push(zero);
					previous = zero;
				}
				result.push(zero);
			}
			return tmp1.concat(result);
		}

		var p = f;
		if (p.getDegree() === 0) {
			return [];
		}

		p = p.scale(p.getContent().inverse());

		var useGaussingIntegerPolynomials = true;
		if (!f.hasIntegerCoefficients() && (!useGaussingIntegerPolynomials || !f.hasComplexCoefficients())) {

			var toPolynomialWithIntegerCoefficients = function (polynomial) {
				if (!polynomial.hasIntegerCoefficients()) {
					var variable = new Expression.Symbol('$$');
					var e = polynomial.calcAt(variable);
					var c = Expression.getConjugateExpression(e);
					if (c != null && !c.equals(e)) {

						return Polynomial.toPolynomial(c, variable);
					}

					var subs = [];
					var root = null;
					for (var i = 0; i < polynomial.getDegree(); i += 1) {
						var c = polynomial.getCoefficient(i);
						if (c instanceof Expression.ExpressionPolynomialRoot) {
							var v = new Expression.Symbol("$a" + i);
							polynomial = polynomial.map(function (cc) {
								return cc === c ? v : cc;
							});
							var alpha = c.root.upgrade().getAlpha();
							subs.push({
								v: v,
								alpha: alpha
							});
						}
					}
					for (var i = 0; i < subs.length; i++) {
						var v = subs[i].v;
						var alpha = subs[i].alpha;

						var p_1 = Polynomial.toPolynomial(polynomial.calcAt(new Expression.Symbol('$$')), v);
						var p_2 = alpha.polynomial;
						var res = Polynomial.toPolynomial(Polynomial.resultant(p_1, p_2), new Expression.Symbol("$$")).primitivePart();

						polynomial = res;
					}
				}
				return polynomial;
			};

			var f1 = toPolynomialWithIntegerCoefficients(f).getSquareFreePolynomial();
			if (!f1.equals(f)) {
				var result = [];
				var tmp = f1.getZeros(complex);
				console.time('checking roots');

				for (var i = 0; i < tmp.length; i += 1) {
					var zero = tmp[i];
					if (zero instanceof ExpressionPolynomialRoot && zero.root.getAlphaExpression().equals(new Expression.Symbol('α')) ? f.hasRoot(zero.root.getAlpha()) : zero instanceof ExpressionWithPolynomialRoot && zero.e === zero.root ? f.hasRoot(zero.root) : (zero instanceof ExpressionWithPolynomialRoot ? zero._calc(f) : f.calcAt(zero)).equals(Expression.ZERO)) {
						result.push(zero);
					} else {

						console.debug(zero.root);
					}
				}
				console.timeEnd('checking roots');
				return result;
			}

			var u = Polynomial.of(Expression.ONE).shift(f.getDegree()).subtract(Polynomial.of(f.getLeadingCoefficient())).getroots();
			if (u.length !== 0) {
				u = u[0];
				var v = f.getCoefficient(f.getDegree() - 1).divide(u._pow(f.getDegree() - 1)).subtract(Expression.ZERO).divide(Expression.Integer.fromNumber(f.getDegree()));
				var x = new Expression.Symbol('$$');
				var pt = Polynomial.toPolynomial(p.calcAt(x.subtract(v).divide(u)).getNumerator(), x);
				if (pt.hasIntegerCoefficients()) {
					return pt.getZeros(complex).map(function (zero) {
						return zero.subtract(v).divide(u);
					});
				}
			}

			console.debug('not all roots were found!!!');
			return [];
		}

		if (p.getDegree() === 3) {

		}

		var result = [];

		if (p.hasIntegerCoefficients()) {

			var intervals = p.getRootIntervals();

			var enableNewClass = true;
			for (var i = 0; i < intervals.length; i += 1) {
				var zero = p.getZero(intervals[i], 0);
				if (zero.a.equals(zero.b)) {
					result.push(zero.a);
				} else {

					if (!enableNewClass) {
						var root = new Expression.PolynomialRootSymbol(p, zero);
						result.push(new ExpressionWithPolynomialRoot(root, root));
					} else {

						var root = ExpressionPolynomialRoot.create(p, zero, {skipFactorization: true});

						result.push(root);
					}
				}
			}

		}

		if (result.length !== p.getDegree() && true && complex) {

			if (p.getDegree() >= 4) {
				var factor = p.factorize();
				if (factor != null) {

					return factor.getZeros(complex).concat(p.divideAndRemainder(factor, "throw").quotient.getZeros(complex));
				}
			}

			if (p.isEven()) {

				var zeros = p._exponentiateRoots(2).getZeros(complex);
				for (var iteratorzero = zeros[globalThis.Symbol.iterator](), zero = iteratorzero.next().value; zero != null; zero = iteratorzero.next().value) {

					var squareRoot = function (z) {
						var tmp = Expression.getComplexNumberParts(z);
						var a = tmp.real;
						var b = tmp.imaginary;
						var aapbb = a._pow(2).add(b._pow(2)).squareRoot();
						var γ = a.add(aapbb).divide(Expression.TWO).squareRoot();
						var sign = (b.compareTo(Expression.ZERO) > 0 ? Expression.ONE : Expression.ONE.negate());
						var tmp = a.negate().add(aapbb).divide(Expression.TWO);

						var δ = sign.multiply(tmp.squareRoot());
						return γ.add(δ.multiply(Expression.I));
					};

					if (!Expression._isPositive(zero)) {
						var z = squareRoot(zero.e != null ? zero.upgrade() : zero);
						result.push(z);
						result.push(z.negate());
					}
				}
				return result;
			}

			var e = p.calcAt(new Expression.Symbol("a").add(new Expression.Symbol("b").multiply(Expression.I)));
			var ce = Expression.getComplexNumberParts(e);

			var cpa = ce.real.divide(Expression.getConstant(ce.real));
			var cpb = ce.imaginary.divide(!p.hasIntegerCoefficients() ? Expression.ONE : new Expression.Symbol('b')).divide(Expression.getConstant(ce.imaginary));

			var getZeros1 = function (p) {
				var tmp = p.squareFreeFactors();
				if (tmp.a0.getDegree() !== 0) {
					return getZeros1(tmp.a0).concat(getZeros1(tmp.a1));
				}
				var factor = p.factorize();
				if (factor != null) {

					var tmp = getZeros1(factor);
					var t = p.divideAndRemainder(factor, "throw").quotient;
					if (0 === t._getNonNegativeRealRootIntervals().length) {
						if (0 === t._scaleRoots(Expression.ONE.negate())._getNonNegativeRealRootIntervals().length) {
							return tmp
						}
					}
					return tmp.concat(getZeros1(t));
				}
				return p.getZeros(false);
			};

			if (result.length < p.getDegree()) {

				var resultant = function (v1, v2) {
					var A = Polynomial.toPolynomial(cpa, new Expression.Symbol(v1));
					var B = Polynomial.toPolynomial(cpb, new Expression.Symbol(v1));
					return Polynomial.toPolynomial(Polynomial.resultant(A, B), new Expression.Symbol(v2)).primitivePart();
				};
				var bCandidates = getZeros1(resultant('a', 'b'));
				if (p.hasIntegerCoefficients()) {
					bCandidates = bCandidates.filter(function (c) {
						return Expression._isPositive(c);
					});
				}
				bCandidates = bCandidates.map(function (c) {
					return c instanceof ExpressionWithPolynomialRoot && c.root.polynomial.getDegree() / c.root.polynomial.getGCDOfTermDegrees() <= 2 ? c.upgrade() : c;
				});

				if (true) {
					var A = Polynomial.toPolynomial(cpa, new Expression.Symbol('a')).map(function (c) {
						return Polynomial.toPolynomial(c, new Expression.Symbol('b'));
					});
					var B = Polynomial.toPolynomial(cpb, new Expression.Symbol('a')).map(function (c) {
						return Polynomial.toPolynomial(c, new Expression.Symbol('b'));
					});

					var gp = undefined;
					var previousPolynomial = Polynomial.ZERO;
					for (var iteratorb = bCandidates[globalThis.Symbol.iterator](), b = iteratorb.next().value; b != null; b = iteratorb.next().value) {
						var g = null;

						if ((!(b instanceof ExpressionWithPolynomialRoot) || !b.e.equals(b.root)) && (!(b instanceof ExpressionPolynomialRoot) || !b.root.getAlphaExpression().equals(new Expression.Symbol('α')))) {
							var A1 = A.map(function (c) {
								return c.calcAt(b);
							});
							var B1 = B.map(function (c) {
								return c.calcAt(b);
							});
							g = Polynomial.polynomialGCD(A1, B1);
						} else {
							var bRootPolynomial = (b instanceof ExpressionPolynomialRoot ? b.root.upgrade().getAlpha() : b.root).polynomial;
							if (!previousPolynomial.equals(bRootPolynomial)) {
								gp = polynomialGCDModuloPolynomial(A, B, bRootPolynomial);
								gp = gp.map(function (c) {
									return c.polynomial;
								});
								previousPolynomial = bRootPolynomial;
							}

							g = gp.map(function (c) {
								return b._calc(c);
							});

						}

						if (g.getDegree() >= 2 && !(b instanceof Expression.Integer)) {
							var polynomial0 = this;

							console.log('good test: ' + polynomial0.toString(), 'g!!!', g.toString());

						}
						var getroots0 = function (np) {
							var p = np.getCoefficient(1).divide(np.getCoefficient(2));
							var q = np.getCoefficient(0).divide(np.getCoefficient(2));
							var pOver2Negate = p.divide(Expression.TWO).negate();
							var sD = pOver2Negate._pow(2).subtract(q).squareRoot();
							var x1 = pOver2Negate.subtract(sD);
							var x2 = pOver2Negate.add(sD);
							return [x1, x2];
						};
						if (g.getDegree() <= 2) {

							var roots = g.getDegree() === 2 ? getroots0(g) : g.getroots();
							for (var iteratora = roots[globalThis.Symbol.iterator](), a = iteratora.next().value; a != null; a = iteratora.next().value) {
								if (!Expression.has(a, Expression.Complex)) {
									var candidate = a.add(b.multiply(Expression.I));
									result.push(candidate);
									if (p.hasIntegerCoefficients()) {
										result.push(candidate.complexConjugate());
									}
								}
							}
						} else {

							if (g.hasIntegerCoefficients() || !(b instanceof ExpressionPolynomialRoot)) {
								var roots = g.getZeros();
								for (var iteratora = roots[globalThis.Symbol.iterator](), a = iteratora.next().value; a != null; a = iteratora.next().value) {
									var candidate = a.add(b.multiply(Expression.I));
									result.push(candidate);
									if (p.hasIntegerCoefficients()) {
										result.push(candidate.complexConjugate());
									}
								}
							} else {
								var bRootPolynomial = (b instanceof ExpressionPolynomialRoot ? b.root.upgrade().getAlpha() : b.root).polynomial;

								var p1 = Polynomial.toPolynomial(gp.map(function (c) {
									return c.calcAt(new Expression.Symbol('b'));
								}).calcAt(new Expression.Symbol('a')), new Expression.Symbol('b'));
								var aCandidates = getZeros1(Polynomial.toPolynomial(Polynomial.resultant(p1, bRootPolynomial), new Expression.Symbol('a')).primitivePart());

								for (var iteratora = aCandidates[globalThis.Symbol.iterator](), a = iteratora.next().value; a != null; a = iteratora.next().value) {
									console.time('ccc');
									var $tmpa1_b1 = a instanceof ExpressionPolynomialRoot ? convert(a, b) : [a, b];
									var a1 = $tmpa1_b1[0];
									var b1 = $tmpa1_b1[1];
									console.timeEnd('ccc');

									var candidate = a1.add(b1.multiply(Expression.I));
									if (gp.map(function (c) {
										return c.calcAt(b1);
									}).calcAt(a1).equals(Expression.ZERO)) {
										result.push(candidate);

										if (p.hasIntegerCoefficients()) {
											result.push(candidate.complexConjugate());
										}
									}
								}
							}
						}
					}
				}

				if (result.length > p.getDegree()) {
					throw new TypeError(p.toString());
				}

				if (result.length < p.getDegree()) {

					result = result.filter(function (root) {
						return Expression.isReal(root);
					});
					var aCandidates = getZeros1(resultant('b', 'a'));

					for (var iteratora = aCandidates[globalThis.Symbol.iterator](), a = iteratora.next().value; a != null; a = iteratora.next().value) {
						for (var iteratorb = bCandidates[globalThis.Symbol.iterator](), b = iteratorb.next().value; b != null; b = iteratorb.next().value) {
							var candidate = a.add(b.multiply(Expression.I));
							if (p.calcAt(candidate).equals(Expression.ZERO)) {
								result.push(candidate);
								if (p.hasIntegerCoefficients()) {
									result.push(candidate.complexConjugate());
								}
							}
						}
					}

				}
			}
		}

		return result;
	};

	function pseudoRemainderSequence(A, B, type, produceSturmSequence) {
		type = type == undefined ? "primitive" : type;
		produceSturmSequence = produceSturmSequence == undefined ? false : produceSturmSequence;

		var g = Math.gcd(A.getGCDOfTermDegrees(), B.getGCDOfTermDegrees());
		if (g > 1) {
			console.error('g > 1');
		}
		var first = true;
		var phi = Expression.ONE;
		var iterator = {
			next: function () {
				console.assert(A.getDegree() >= B.getDegree());
				if (!B.equals(Polynomial.ZERO)) {
					var d = A.getDegree() - B.getDegree();
					var scale = B.getLeadingCoefficient()._pow(d + 1);
					var tmp = A.scale(produceSturmSequence ? scale.abs() : scale).divideAndRemainder(B, B._hasIntegerLikeCoefficients() ? "throw" : undefined);
					var q = tmp.quotient;
					var r = tmp.remainder;
					var α = Expression.ONE;
					if (type === "trivial") {

						α = Expression.ONE;
					} else if (type === "primitive") {

						α = r.getContent();
					} else if (type === "subresultant") {

						α = first ? Expression.ONE : A.getLeadingCoefficient().multiply(phi._pow(d));
						first = false;
						phi = d === 0 ? phi : B.getLeadingCoefficient()._pow(d).divide(phi._pow(d).divide(phi));
					} else {
						throw new RangeError(type);
					}

					var R = r.map(function (c) {
						return c.divide(produceSturmSequence ? α.abs().negate() : α);
					});
					var value = {
						R: R,
						q: q,
						α: α
					};
					A = B;
					B = R;
					return {
						value: value,
						done: false
					};
				}
				return {
					value: undefined,
					done: true
				};
			}
		};
		iterator[globalThis.Symbol.iterator] = function () {
			return this;
		};
		return iterator;
	}

	Polynomial._pseudoRemainderSequence = pseudoRemainderSequence;

	Polynomial._resultantUsingSubresultantPseudoRemainderSequence = function (A, B) {
		function toMultivariatePolynomial(p1, p2) {
			if (p1.getLeadingCoefficient() instanceof Expression.Polynomial || p2.getLeadingCoefficient() instanceof Expression.Polynomial) {
				return {
					variables: [],
					A: p1,
					B: p2
				};
			}
			var set = {};
			var variables = [];
			var v = function (e) {
				for (var iterators = e.summands()[globalThis.Symbol.iterator](), s = iterators.next().value; s != null; s = iterators.next().value) {
					for (var iteratorf = s.factors()[globalThis.Symbol.iterator](), f = iteratorf.next().value; f != null; f = iteratorf.next().value) {
						if (f instanceof Expression.Exponentiation) {
							f = f.a;
						}
						if (f instanceof Expression.Symbol && Object.getPrototypeOf(f) === Expression.Symbol.prototype) {
							if (set[f.symbol] == undefined) {
								variables.push(f);
								set[f.symbol] = true;
							}
						}
					}
				}
			};
			for (var i = 0; i < p1.a.size; i += 1) {
				v(p1.a.coefficient(i));
			}
			for (var i = 0; i < p2.a.size; i += 1) {
				v(p2.a.coefficient(i));
			}

			var f = function (p, index) {
				if (index === variables.length) {
					console.assert(p.hasIntegerCoefficients());
					return p;
				}
				var v = variables[index];
				return p.map(function (c) {
					return new Expression.Polynomial(f(Polynomial.toPolynomial(c, v), index + 1));
				});
			};
			return {
				variables: variables,
				A: f(p1, 0),
				B: f(p2, 0)
			};
		}

		function toExpression(variables, p) {
			if (p.equals(Expression.ZERO)) {
				return p;
			}
			if (variables.length === 0) {
				return p;
			}
			return p.polynomial.map(function (c) {
				return toExpression(variables.slice(1), c);
			}).calcAt(variables[0]);
		}

		if (A.getDegree() === Polynomial.ZERO.getDegree() || B.getDegree() === Polynomial.ZERO.getDegree()) {
			return Expression.ZERO;
		}
		var g = Math.gcd(A.getGCDOfTermDegrees(), B.getGCDOfTermDegrees());
		if (g > 1) {

			var tmp = Polynomial._resultantUsingSubresultantPseudoRemainderSequence(A._exponentiateRoots(g), B._exponentiateRoots(g));

			return tmp._pow(g);
		}
		var tmp1 = toMultivariatePolynomial(A, B);
		A = tmp1.A;
		B = tmp1.B;
		var AA = A;
		var BB = B;
		var start = Date.now();
		var resultantSign = 1;
		if (A.getDegree() < B.getDegree()) {
			var tmp = A;
			A = B;
			B = tmp;
			resultantSign *= Math.pow(Math.pow(-1, A.getDegree()), B.getDegree());
		}
		var resultant2 = [];
		var isPseudoRemainderSequence = true;

		for (var iteratortmp = Polynomial._pseudoRemainderSequence(A, B, "subresultant")[globalThis.Symbol.iterator](), tmp = iteratortmp.next().value; tmp != null; tmp = iteratortmp.next().value) {
			var R = tmp.R;
			var α = tmp.α;

			if (B.getDegree() > 0) {
				if (R.getDegree() < 0) {
					while (resultant2.length > 0) {
						resultant2.pop();
					}
					resultant2.push({
						base: Expression.ZERO,
						exponent: 1
					});
				} else {
					if (!α.equals(Expression.ONE)) {
						if (resultant2.length > 0) {
							var previous = resultant2.pop();
							resultant2.push({
								base: previous.base,
								exponent: previous.exponent + 2 * B.getDegree()
							});
							resultant2.push({
								base: α.divide(previous.base._pow(2)),
								exponent: B.getDegree()
							});
						} else {
							resultant2.push({
								base: α,
								exponent: B.getDegree()
							});
						}
					}
					resultant2.push({
						base: B.getLeadingCoefficient(),
						exponent: (A.getDegree() - R.getDegree()) - (isPseudoRemainderSequence ? B.getDegree() * (A.getDegree() - B.getDegree() + 1) : 0)
					});
					resultantSign *= Math.pow(Math.pow(-1, A.getDegree()), B.getDegree());
				}
			} else {
				console.assert(B.getDegree() === 0 && R.getDegree() < 0);
				resultant2.push({
					base: B.getLeadingCoefficient(),
					exponent: A.getDegree()
				});
			}
			A = B;
			B = R;
		}
		var resultant = resultantSign === -1 ? Expression.ONE.negate() : Expression.ONE;
		for (var iteratorx = resultant2[globalThis.Symbol.iterator](), x = iteratorx.next().value; x != null; x = iteratorx.next().value) {
			if (x.exponent < 0) {
				resultant = resultant.divide(x.base._pow(-x.exponent));
			} else if (x.exponent > 0) {
				resultant = resultant.multiply(x.base._pow(x.exponent));
			}
		}
		var end = Date.now();
		if (end - start > 250) {
			console.log(end - start, AA.toString(), BB.toString());
		}
		resultant = toExpression(tmp1.variables, resultant);
		return resultant;
	};

	var basisPolynomialCache = {};
	var basisPolynomialCacheBigInt = {};

	var BigIntField = {
		ONE: globalThis.BigInt != undefined && typeof BigInt(0) === 'bigint' ? BigInt(1) : undefined,
		sub: function (a, b) {
			return a - b;
		},
		mul: function (a, b) {
			return a * b;
		},
		div: function (a, b) {
			return a / b;
		},
		scale: function (a, s) {
			return a * BigInt(s);
		}
	};

	Polynomial._resultantByModularAlgorithm = function (A, B, internalResultant) {
		internalResultant = internalResultant == undefined ? null : internalResultant;

		if (A.getDegree() === Polynomial.ZERO.getDegree() || B.getDegree() === Polynomial.ZERO.getDegree()) {
			return Expression.ZERO;
		}
		var g = Math.gcd(A.getGCDOfTermDegrees(), B.getGCDOfTermDegrees());
		if (g > 1) {

			var tmp = Polynomial._resultantByModularAlgorithm(A._exponentiateRoots(g), B._exponentiateRoots(g), internalResultant);

			return tmp._pow(g);
		}

		console.assert(A._hasIntegerLikeCoefficients() && B._hasIntegerLikeCoefficients());

		var v2 = Polynomial._getY(A, B) || Polynomial._getY(B, A);
		var flag0 = false;
		if (v2 == null) {
			if (A.getLeadingCoefficient() instanceof Expression.Polynomial) {
				flag0 = true;
			}
		}
		if (v2 == null && !flag0) {
			internalResultant = internalResultant || Polynomial._resultantOfIntegerPolynomialsUsingModularAlgorithm || Polynomial._resultantUsingSubresultantPseudoRemainderSequence;

			return internalResultant(A, B);
		}

		var toPolynomialByAnotherVar = function (p) {

			var topLevelVar = new Expression.Polynomial(Polynomial.of(new Expression.Polynomial(Polynomial.of(Expression.ZERO, Expression.ONE))));
			return p.map(function (c) {
				return new Expression.Polynomial(c.polynomial.map(function (c) {
					return new Expression.Polynomial(Polynomial.of(c));
				}));
			})
				.calcAt(topLevelVar).polynomial;
		};

		function f(p) {
			if (!flag0) {
				p = p.map(function (c) {
					return new Expression.Polynomial(Polynomial.toPolynomial(c, v2));
				});
			}
			return p;
		}

		var Av2 = toPolynomialByAnotherVar(f(A));
		var Bv2 = toPolynomialByAnotherVar(f(B));

		var Res = null;
		var points = [];
		if (Av2.getDegree() === 0 && A.getDegree() <= 1) {

		}
		if (Bv2.getDegree() === 0 && B.getDegree() <= 1) {

		}
		var d = Bv2.getDegree() * A.getDegree() + Av2.getDegree() * B.getDegree();

		var tabulatePolynomial = function (p, x0, count) {

			var n = p.getDegree();
			var result = [];

			var initialTableColumn = new Array(n + 1).fill(null);
			for (var i = 0; i <= n; i += 1) {
				initialTableColumn[i] = p.calcAt(Expression.Integer.fromNumber(x0 + i));
				result.push(initialTableColumn[i]);
			}
			for (var j = 1; j <= n; j += 1) {
				for (var i = 0; i <= n - j; i += 1) {
					initialTableColumn[i] = initialTableColumn[i + 1].subtract(initialTableColumn[i]);
				}
			}
			var diagonal = initialTableColumn;

			for (var i = 0; i < count - n - 1; i += 1) {
				for (var j = 1; j <= n; j += 1) {
					diagonal[j] = diagonal[j].add(diagonal[j - 1]);
				}
				result.push(diagonal[n]);
			}
			return result;
		};

		var x0 = 0 - Math.floor(d / 2);
		basisPolynomialCache[x0] = basisPolynomialCache[x0] || {};
		basisPolynomialCacheBigInt[x0] = basisPolynomialCacheBigInt[x0] || {};

		var Av2Values = tabulatePolynomial(Av2, x0, d + 1);
		var Bv2Values = tabulatePolynomial(Bv2, x0, d + 1);

		for (var i = 0; i <= d; i += 1) {
			var r = Expression.Integer.fromNumber(i + x0);

			var Av2_r = Av2Values[i].polynomial;
			var Bv2_r = Bv2Values[i].polynomial;

			var Res_r = null;
			if (Av2_r.getDegree() < A.getDegree() && Bv2_r.getDegree() < B.getDegree()) {
				Res_r = Expression.ZERO;

			} else {

				Res_r = Polynomial._resultantByModularAlgorithm(Av2_r, Bv2_r, internalResultant);
				if (B.getDegree() !== Bv2_r.getDegree()) {
					if (!Res_r.equals(Expression.ZERO)) {
						var tmp = Av2_r.getLeadingCoefficient()._pow(B.getDegree() - Bv2_r.getDegree());

						Res_r = Res_r.multiply(tmp);
					}
				}
				if (A.getDegree() !== Av2_r.getDegree()) {
					if (!Res_r.equals(Expression.ZERO)) {
						var tmp = Bv2_r.getLeadingCoefficient()._pow(A.getDegree() - Av2_r.getDegree()).multiply(B.getDegree() % 2 === 1 ? Expression.ONE.negate() : Expression.ONE);

						Res_r = Res_r.multiply(tmp);
					}
				}
			}

			points.push({
				r: r.toNumber(),
				Res_r: Res_r
			});
		}

		var useBigIntField = BigIntField.ONE != undefined && points.reduce(function (p, point) {
			return p && point.Res_r instanceof Expression.Integer;
		}, true) === true;

		NewtonInterpolation.setField(useBigIntField ? BigIntField : Expression._FIELD);
		var polynomialInterpolation = NewtonInterpolation(useBigIntField ? basisPolynomialCacheBigInt[x0] : basisPolynomialCache[x0]);
		polynomialInterpolation.next();
		var scale = useBigIntField ? Expression.Integer.fromNumber(d).factorial() : Expression.ONE;
		for (var i = 0; i < points.length; i += 1) {
			var p = points[i];
			Res = polynomialInterpolation.next([p.r, useBigIntField ? BigInt(p.Res_r.toBigInt()) * BigInt(scale.toBigInt()) : p.Res_r]).value;
		}
		if (useBigIntField) {
			Res = Res.map(function (x) {
				return Expression.Integer.fromBigInt(x / BigInt(scale.toBigInt()));
			});
		}

		var result = flag0 ? new Expression.Polynomial(Polynomial.from(Res)) : Polynomial.from(Res).calcAt(v2);

		if (true) {

			if (result instanceof Expression.Division) {
				console.error(A.toString(), B.toString());
				throw new Error();
			}
		}

		return result;
	};

	Expression._FIELD = {
		ONE: Expression.ONE,
		sub: function (a, b) {
			return a.subtract(b);
		},
		mul: function (a, b) {
			return a.multiply(b);
		},
		div: function (a, b) {
			return a.divide(b);
		},
		scale: function (a, s) {
			return a.multiply(Expression.Integer.fromBigInt(s));
		}
	};

	Polynomial.resultant = function (p, q) {
		var isBivariatePolynomial = function (p) {
			for (var i = 0; i < p.getDegree(); i += 1) {
				var c = p.getCoefficient(i);
				if (!(c instanceof Expression.Polynomial) || !c.polynomial.hasIntegerCoefficients()) {
					if (!(c instanceof Expression.Integer)) {
						return false;
					}
				}
			}
			return true;
		};
		if (isBivariatePolynomial(p) && isBivariatePolynomial(q)) {
			return Polynomial._resultantByModularAlgorithm(p, q);
		}
		return Polynomial._resultantUsingSubresultantPseudoRemainderSequence(p, q);
	};

	function GramSchmidtOrthogonalization(vectors) {
		if (false) {

			var V = vectors;
			var n = V[0].dimensions();
			var k = V.length;
			var U = new Array(k).fill(null).map(function (x) {
				return new Matrix.Vector(new Array(n).fill(Expression.ZERO));
			});
			;U[0] = V[0];
			for (var i = 1; i < k; i += 1) {
				U[i] = V[i];
				for (var j = 0; j < i; j += 1) {
					U[i] = U[i].subtract(U[j].scale(U[i].dot(U[j]).divide(U[j].dot(U[j]))));
				}
			}
			return U;
		}

		var rowVectorsMatrix = Matrix.fromVectors(vectors).transpose();
		var A = rowVectorsMatrix;
		var matrix = A.multiply(A.conjugateTranspose()).augment(A).toRowEchelon(Matrix.Gauss, "row-reduction").matrix;
		var tmp = matrix.slice(0, matrix.rows(), A.rows(), matrix.cols());
		var result = new Array(tmp.rows());
		for (var i = 0; i < tmp.rows(); i += 1) {
			result[i] = tmp.row(i);
		}
		return result;
	}

	globalThis.GramSchmidtOrthogonalization = GramSchmidtOrthogonalization;

	Expression.Complex.prototype.abs = function () {

		return this.multiply(this.conjugate()).squareRoot();
	};
	Expression.Division.prototype.abs = function () {
		return this.getNumerator().abs().divide(this.getDenominator().abs());
	};
	Expression.prototype.abs = function () {
		var isSimple = function (e) {
			if (e instanceof Expression.Addition) {
				for (var iterators = e.summands()[globalThis.Symbol.iterator](), s = iterators.next().value; s != null; s = iterators.next().value) {
					for (var iteratorf = s.factors()[globalThis.Symbol.iterator](), f = iteratorf.next().value; f != null; f = iteratorf.next().value) {
						if (!(f instanceof Expression.Symbol && !(f instanceof Expression.MatrixSymbol) || f instanceof Expression.Integer)) {
							return false;
						}
					}
				}
				return true;
			}
			return false;
		};
		var x = this;
		if (x instanceof Expression.Symbol && !(x instanceof Expression.PolynomialRootSymbol) && !(x instanceof Expression.ExpressionPolynomialRoot) && !(x instanceof Expression.ExpressionWithPolynomialRoot)) {
			if (x === Expression.PI || x === Expression.E) {
				return x;
			}
			return new Expression.Abs(this);
		}

		if (this instanceof Expression.ComplexConjugate) {
			return this.a.abs();
		}
		if (this instanceof Expression.Multiplication) {
			return this.a.abs().multiply(this.b.abs());
		}
		if (this instanceof Expression.Abs) {
			return this;
		}
		if (this.isNegative()) {
			return this.negate().abs();
		}
		if (this instanceof Expression.Exponentiation && (this.a instanceof Expression.Symbol || isSimple(this.a))) {
			if (this.b instanceof Expression.Integer) {
				return this.a.multiply(this.a.complexConjugate()).multiply(this.a.pow(this.b.subtract(Expression.TWO)).abs());
			}
		}
		var d = Expression.simpleDivisor(this);
		if (d != null && !d.equals(Expression.ONE) && !d.equals(this)) {
			if (!(this.divide(d).divide(d) instanceof Expression.Division)) {
				return new Expression.Exponentiation(d, Expression.TWO).abs().multiply(this.divide(d).divide(d).abs());
			}
			return d.abs().multiply(this.divide(d).abs());
		}
		if (isSimple(this)) {
			return new Expression.Abs(this);
		}
		if (isSimple(this.complexConjugate())) {
			return this.complexConjugate().abs();
		}
		if (Expression.isConstant(this)) {
			var tmp = Expression.getComplexNumberParts(this);
			if (!tmp.imaginary.equals(Expression.ZERO)) {

				return this.multiply(this.complexConjugate()).squareRoot();
			}
		}
		if (this.compareTo(Expression.ZERO) < 0) {
			return this.negate();
		}
		return this;
	};
	Expression.prototype.compareTo = function (other) {
		if (other.equals(Expression.ZERO)) {
			if (Expression._isPositive(this)) {
				return +1;
			}
			if (Expression._isPositive(this.negate())) {
				return -1;
			}
			throw new TypeError(this.toString());
		}
		return this.subtract(other).getNumerator().compareTo(Expression.ZERO);
	};
	Expression.prototype.sign = function () {
		return this.compareTo(Expression.ZERO);
	};
	Expression.prototype.round = function () {
		var n = this.getNumerator();
		var d = this.getDenominator();
		if (n instanceof Expression.Integer && d instanceof Expression.Integer) {
			if (d.compareTo(Expression.ZERO) > 0) {
				if (n.compareTo(Expression.ZERO) >= 0) {
					return n.add(d.leftShift(-1)).truncatingDivide(d);
				}
				return n.subtract(d.leftShift(-1)).truncatingDivide(d);
			}
		}

		return ExpressionParser.parse(toDecimalStringInternal(this, {fractionDigits: 0}));
	};

	Polynomial.prototype._log2hypot = function () {
		var max = Expression.ZERO;
		for (var i = 0; i < this.a.size; i += 1) {
			var c = this.a.coefficient(i).abs();
			if (c.compareTo(max) > 0) {
				max = c;
			}
		}
		var shift = Math.max(max.bitLength() - ((1024 - 53 - 1) / 2), 0);
		var s = 0;
		for (var i = 0; i < this.a.size; i += 1) {
			s += Math.pow(this.a.coefficient(i).abs().leftShift(0 - shift).toNumber(), 2);
		}
		return shift + Math.log2(Math.sqrt(s));
	};

	Polynomial.prototype._log2OfBoundForCoefficientsOfFactor = function (factorDegreeBound, factorLeadingCoefficientBound) {

		if (factorDegreeBound == undefined) {
			factorDegreeBound = this.getDegree();
		}
		if (factorDegreeBound === 0) {
			return 0;
		}
		if (factorLeadingCoefficientBound == undefined) {
			factorLeadingCoefficientBound = this.getLeadingCoefficient().abs();
		}
		var log2 = function (integer) {
			var e = integer.bitLength();
			if (e <= 53) {
				return Math.log2(integer.toNumber());
			}
			return (e - 53) + Math.log2(integer.truncatingDivide(Expression.TWO._pow(e - 53)).toNumber());
		};
		var centralBinomialCoefficientBound = function (n) {
			return (n - Math.log2(Math.sqrt(Math.PI * Math.ceil(n / 2))));
		};
		var m = factorDegreeBound;
		var e = centralBinomialCoefficientBound(m) + (log2(factorLeadingCoefficientBound.abs()) - log2(this.getLeadingCoefficient().abs())) + this._log2hypot();
		return e;
	};

	Polynomial.prototype.isDivisibleBy = function (guess) {
		var w = undefined;
		var s = Expression.ONE;
		if (this._hasIntegerLikeCoefficients() && guess._hasIntegerLikeCoefficients()) {

			w = "undefined";
			s = guess.getContent();
		}
		var tmp = this.scale(s).divideAndRemainder(guess, w);
		return tmp != null && tmp.remainder.equals(Polynomial.ZERO);
	};

	function polynomialGCDModuloPolynomial(A, B, M) {
		function modulo(B, M) {
			var BmodM = B.map(function (c) {
				return new Expression.Polynomial(c.polynomial.divideAndRemainder(M).remainder);
			});
			var d = BmodM.map(function (c) {
				return c.polynomial.getContent();
			}).getContent().inverse();
			return BmodM.scale(new Expression.Polynomial(Polynomial.of(d)));
		}

		function toMonic(A, M) {

			if (A.getDegree() < 0) {
				return A;
			}
			return modulo(A.scale(new Expression.Polynomial(A.getLeadingCoefficient().polynomial.primitivePart().modularInverse(M).primitivePart())), M);
		}

		A = A.map(function (c) {
			return new Expression.Polynomial(c);
		});
		B = B.map(function (c) {
			return new Expression.Polynomial(c);
		});
		if (A.getDegree() < B.getDegree()) {
			var tmp = A;
			A = B;
			B = tmp;
		}
		if (B.getDegree() >= 0 && modulo(Polynomial.of(B.getLeadingCoefficient()), M).equals(Polynomial.ZERO)) {
			return polynomialGCDModuloPolynomial(modulo(A, M).map(function (c) {
				return c.polynomial;
			}), modulo(B, M).map(function (c) {
				return c.polynomial;
			}), M);
		}
		if (true) {
			for (var iteratortmp = Polynomial._pseudoRemainderSequence(A, B, "subresultant")[globalThis.Symbol.iterator](), tmp = iteratortmp.next().value; tmp != null; tmp = iteratortmp.next().value) {
				var newR = tmp.R;
				A = B;
				B = newR;
				if (B.getDegree() >= 0 && modulo(Polynomial.of(B.getLeadingCoefficient()), M).equals(Polynomial.ZERO)) {
					return polynomialGCDModuloPolynomial(modulo(A, M).map(function (c) {
						return c.polynomial;
					}), modulo(B, M).map(function (c) {
						return c.polynomial;
					}), M);
				}
			}
		} else {

		}
		return toMonic(modulo(A, M), M);
	}

	globalThis.testables = globalThis.testables || {};
	globalThis.testables.polynomialGCDModuloPolynomial = polynomialGCDModuloPolynomial;

	globalThis._polynomialGCDModuloPolynomial = polynomialGCDModuloPolynomial;

	function getMinimalPolynomial(g) {
		if (g instanceof ExpressionPolynomialRoot) {
			return g.upgrade().root.getAlpha().polynomial;
		}
		var p = Polynomial.toPolynomial(Expression.getConjugateExpression(ExpressionParser.parse('x').subtract(g)), ExpressionParser.parse('x'));
		if (p.factorize() != null) {
			throw new TypeError();
		}
		return p;
	}

	function convert(a, b) {

		a = a.upgrade();
		b = b.upgrade();
		var pa = a.root.getAlpha().polynomial;
		var pb = b.root.getAlpha().polynomial;

		var step = -1;
		while (true) {
			step += 1;

			var k = step % 2 === 0 ? Math.floor(step / 2) : -Math.floor((step + 1) / 2);

			var g = a.multiply(new Expression.Integer(k)).add(b);
			var pc = getMinimalPolynomial(g);

			var res = Polynomial.resultant(pb, stringToPolynomial(k + '*a-c+x'));

			res = Polynomial.toPolynomial(res, new Expression.Symbol('a')).map(function (c) {
				return Polynomial.toPolynomial(c, new Expression.Symbol('c'));
			});
			var f1 = _polynomialGCDModuloPolynomial(res, pa.map(function (c) {
				return Polynomial.of(c);
			}), pc);
			var f2 = f1.map(function (c) {
				return c.polynomial.calcAt(g);
			});

			if (f2.getDegree() === 1) {
				var a1 = f2.getroots()[0];
				return [a1, g.subtract(a1.multiply(new Expression.Integer(k)))];
			}
			console.log('f2 degree:', f2.getDegree(), k);
		}

	}

	globalThis.convert = convert;

	globalThis.toSameField = function toSameField(algebraicNumbers) {

		if (algebraicNumbers.length <= 1) {
			return algebraicNumbers;
		}
		var m = -1;

		var a = toSameField(algebraicNumbers.slice(0, m));
		var b = toSameField(algebraicNumbers.slice(m));

		var gamma1 = ExpressionPolynomialRoot.create(a[0].root.getAlpha().polynomial, a[0].root.getAlpha().interval, {skipFactorization: true});
		var gamma2 = ExpressionPolynomialRoot.create(b[0].root.getAlpha().polynomial, b[0].root.getAlpha().interval, {skipFactorization: true});
		var tmp = convert(gamma1, gamma2);

		for (var i = 0; i < a.length; i++) {
			var $tmpp1_p2 = a[i].root.getAlphaPolynomial();
			var p1 = $tmpp1_p2[0];
			var p2 = $tmpp1_p2[1];
			console.assert(p2.getDegree() === 0);
			a[i] = p1.calcAt(tmp[0]).divide(p2.getCoefficient(0));
		}
		for (var i = 0; i < b.length; i++) {
			var $tmpp1_p2 = b[i].root.getAlphaPolynomial();
			var p1 = $tmpp1_p2[0];
			var p2 = $tmpp1_p2[1];
			console.assert(p2.getDegree() === 0);
			b[i] = p1.calcAt(tmp[1]).divide(p2.getCoefficient(0));
		}

		return a.concat(b);
	};
}

function PolynomialWasm() {
	var wasmCodef32x4 = typeof Uint8Array !== 'undefined' ? new Uint8Array([0, 97, 115, 109, 1, 0, 0, 0, 1, 20, 2, 96, 4, 127, 127, 123, 127, 0, 96, 8, 127, 127, 127, 127, 127, 127, 127, 127, 1, 127, 2, 15, 1, 3, 101, 110, 118, 6, 109, 101, 109, 111, 114, 121, 2, 0, 0, 3, 3, 2, 0, 1, 7, 37, 1, 33, 114, 101, 115, 117, 108, 116, 97, 110, 116, 79, 102, 73, 110, 116, 101, 103, 101, 114, 80, 111, 108, 121, 110, 111, 109, 105, 97, 108, 115, 77, 111, 100, 80, 0, 1, 10, 232, 13, 2, 225, 3, 2, 9, 123, 4, 127, 253, 12, 0, 0, 0, 0, 0, 0, 240, 66, 0, 0, 0, 0, 0, 0, 240, 66, 253, 12, 0, 0, 0, 0, 0, 0, 240, 66, 0, 0, 0, 0, 0, 0, 240, 66, 253, 12, 1, 0, 0, 0, 0, 0, 240, 63, 1, 0, 0, 0, 0, 0, 240, 63, 32, 2, 253, 95, 34, 6, 253, 243, 1, 34, 8, 253, 242, 1, 253, 117, 32, 6, 253, 242, 1, 253, 241, 1, 33, 9, 253, 12, 0, 0, 0, 0, 0, 0, 240, 66, 0, 0, 0, 0, 0, 0, 240, 66, 253, 12, 0, 0, 0, 0, 0, 0, 240, 66, 0, 0, 0, 0, 0, 0, 240, 66, 253, 12, 1, 0, 0, 0, 0, 0, 240, 63, 1, 0, 0, 0, 0, 0, 240, 63, 32, 2, 32, 2, 253, 13, 8, 9, 10, 11, 12, 13, 14, 15, 0, 1, 2, 3, 4, 5, 6, 7, 253, 95, 34, 7, 253, 243, 1, 34, 10, 253, 242, 1, 253, 117, 32, 7, 253, 242, 1, 253, 241, 1, 33, 11, 32, 0, 65, 3, 117, 33, 0, 3, 64, 32, 1, 32, 14, 74, 4, 64, 32, 0, 65, 3, 116, 43, 3, 0, 252, 2, 33, 15, 253, 12, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 33, 4, 253, 12, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 33, 5, 32, 0, 65, 1, 106, 65, 3, 116, 43, 3, 0, 252, 2, 34, 16, 65, 1, 107, 33, 13, 3, 64, 32, 13, 65, 0, 78, 4, 64, 32, 4, 32, 9, 32, 0, 65, 2, 106, 32, 13, 106, 65, 3, 116, 253, 10, 3, 0, 34, 12, 253, 135, 2, 34, 4, 32, 8, 253, 242, 1, 253, 117, 32, 6, 32, 4, 253, 136, 2, 33, 4, 32, 5, 32, 11, 32, 12, 253, 135, 2, 34, 5, 32, 10, 253, 242, 1, 253, 117, 32, 7, 32, 5, 253, 136, 2, 33, 5, 32, 13, 65, 1, 107, 33, 13, 12, 1, 11, 11, 32, 2, 32, 4, 253, 94, 32, 5, 253, 94, 34, 4, 32, 4, 253, 13, 8, 9, 10, 11, 12, 13, 14, 15, 0, 1, 2, 3, 4, 5, 6, 7, 253, 80, 34, 4, 253, 229, 1, 32, 4, 32, 15, 65, 0, 72, 27, 34, 4, 253, 12, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 253, 67, 32, 4, 32, 2, 253, 68, 253, 80, 253, 83, 4, 64, 0, 11, 32, 3, 32, 14, 106, 65, 4, 116, 32, 4, 253, 11, 4, 0, 32, 0, 65, 2, 106, 32, 16, 106, 33, 0, 32, 14, 65, 1, 106, 33, 14, 12, 1, 11, 11, 11, 130, 10, 2, 10, 123, 1, 127, 253, 12, 0, 0, 128, 63, 0, 0, 128, 63, 0, 0, 128, 63, 0, 0, 128, 63, 32, 2, 65, 4, 116, 253, 0, 4, 0, 34, 11, 253, 231, 1, 33, 16, 32, 0, 32, 5, 32, 11, 32, 4, 16, 0, 32, 1, 32, 7, 32, 11, 32, 6, 16, 0, 32, 5, 32, 7, 72, 4, 64, 32, 5, 33, 0, 32, 4, 33, 1, 32, 6, 33, 4, 32, 7, 34, 5, 65, 1, 107, 32, 0, 34, 7, 65, 1, 107, 113, 33, 18, 32, 1, 33, 6, 11, 253, 12, 0, 0, 128, 63, 0, 0, 128, 63, 0, 0, 128, 63, 0, 0, 128, 63, 33, 17, 3, 64, 32, 7, 65, 1, 107, 65, 0, 78, 4, 64, 32, 6, 32, 7, 106, 65, 1, 107, 65, 4, 116, 253, 0, 4, 0, 34, 13, 253, 12, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 253, 65, 253, 83, 4, 64, 65, 1, 15, 11, 32, 13, 33, 8, 32, 11, 33, 9, 253, 12, 0, 0, 128, 63, 0, 0, 128, 63, 0, 0, 128, 63, 0, 0, 128, 63, 33, 12, 253, 12, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 33, 10, 3, 64, 32, 8, 32, 9, 253, 231, 1, 253, 106, 34, 14, 32, 9, 32, 8, 253, 134, 2, 33, 15, 32, 14, 32, 10, 32, 12, 253, 134, 2, 33, 14, 32, 9, 34, 8, 32, 15, 32, 15, 253, 12, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 253, 55, 34, 15, 253, 82, 33, 9, 32, 10, 34, 12, 32, 14, 32, 15, 253, 82, 33, 10, 32, 15, 253, 164, 1, 65, 15, 71, 13, 0, 11, 253, 12, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 32, 12, 253, 229, 1, 32, 12, 32, 8, 253, 12, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 253, 67, 253, 82, 34, 8, 32, 11, 253, 228, 1, 32, 8, 32, 8, 253, 12, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 253, 67, 253, 82, 33, 8, 65, 0, 33, 0, 3, 64, 32, 0, 32, 7, 72, 4, 64, 32, 0, 32, 6, 106, 65, 4, 116, 34, 1, 253, 0, 4, 0, 34, 9, 32, 8, 253, 230, 1, 34, 10, 32, 16, 253, 230, 1, 253, 104, 32, 11, 32, 10, 253, 134, 2, 33, 12, 32, 9, 32, 8, 32, 10, 253, 134, 2, 34, 9, 32, 11, 253, 228, 1, 33, 10, 32, 1, 32, 12, 32, 9, 32, 11, 253, 229, 1, 253, 229, 1, 32, 12, 32, 9, 253, 229, 1, 32, 12, 32, 9, 253, 67, 253, 82, 32, 12, 32, 10, 253, 229, 1, 32, 12, 32, 10, 253, 67, 253, 82, 253, 11, 4, 0, 32, 0, 65, 1, 106, 33, 0, 12, 1, 11, 11, 32, 5, 65, 1, 107, 33, 0, 253, 12, 0, 0, 128, 63, 0, 0, 128, 63, 0, 0, 128, 63, 0, 0, 128, 63, 33, 8, 3, 64, 32, 0, 4, 64, 32, 0, 32, 0, 65, 1, 117, 34, 0, 32, 0, 106, 71, 4, 64, 32, 8, 32, 13, 253, 230, 1, 34, 9, 32, 16, 253, 230, 1, 253, 104, 32, 11, 32, 9, 253, 134, 2, 33, 10, 32, 8, 32, 13, 32, 9, 253, 134, 2, 34, 8, 32, 11, 253, 228, 1, 33, 9, 32, 10, 32, 8, 32, 11, 253, 229, 1, 253, 229, 1, 32, 10, 32, 8, 253, 229, 1, 32, 10, 32, 8, 253, 67, 253, 82, 32, 10, 32, 9, 253, 229, 1, 32, 10, 32, 9, 253, 67, 253, 82, 33, 8, 11, 32, 13, 32, 13, 253, 230, 1, 34, 9, 32, 16, 253, 230, 1, 253, 104, 32, 11, 32, 9, 253, 134, 2, 33, 10, 32, 13, 32, 13, 32, 9, 253, 134, 2, 34, 9, 32, 11, 253, 228, 1, 33, 12, 32, 10, 32, 9, 32, 11, 253, 229, 1, 253, 229, 1, 32, 10, 32, 9, 253, 229, 1, 32, 10, 32, 9, 253, 67, 253, 82, 32, 10, 32, 12, 253, 229, 1, 32, 10, 32, 12, 253, 67, 253, 82, 33, 13, 12, 1, 11, 11, 32, 17, 32, 8, 253, 230, 1, 34, 9, 32, 16, 253, 230, 1, 253, 104, 32, 11, 32, 9, 253, 134, 2, 33, 10, 32, 17, 32, 8, 32, 9, 253, 134, 2, 34, 8, 32, 11, 253, 228, 1, 33, 9, 32, 10, 32, 8, 32, 11, 253, 229, 1, 253, 229, 1, 32, 10, 32, 8, 253, 229, 1, 32, 10, 32, 8, 253, 67, 253, 82, 32, 10, 32, 9, 253, 229, 1, 32, 10, 32, 9, 253, 67, 253, 82, 33, 17, 32, 4, 33, 0, 32, 6, 33, 4, 65, 127, 33, 1, 32, 7, 4, 127, 32, 6, 32, 7, 106, 65, 1, 107, 65, 4, 116, 253, 0, 4, 0, 253, 12, 0, 0, 128, 63, 0, 0, 128, 63, 0, 0, 128, 63, 0, 0, 128, 63, 253, 66, 253, 83, 5, 65, 1, 11, 69, 4, 64, 32, 5, 33, 1, 3, 64, 32, 1, 32, 7, 78, 4, 64, 32, 0, 32, 1, 106, 65, 1, 107, 65, 4, 116, 253, 0, 4, 0, 33, 8, 32, 1, 32, 7, 107, 33, 2, 3, 64, 32, 1, 32, 2, 74, 4, 64, 32, 0, 32, 2, 106, 65, 4, 116, 34, 6, 253, 0, 4, 0, 33, 9, 32, 8, 32, 4, 32, 7, 106, 32, 2, 106, 32, 1, 107, 65, 4, 116, 253, 0, 4, 0, 34, 10, 253, 230, 1, 34, 12, 32, 16, 253, 230, 1, 253, 104, 32, 11, 32, 12, 253, 134, 2, 33, 13, 32, 8, 32, 10, 32, 12, 253, 134, 2, 34, 10, 32, 11, 253, 228, 1, 33, 12, 32, 6, 32, 9, 32, 11, 253, 228, 1, 32, 13, 32, 10, 32, 11, 253, 229, 1, 253, 229, 1, 32, 13, 32, 10, 253, 229, 1, 32, 13, 32, 10, 253, 67, 253, 82, 32, 13, 32, 12, 253, 229, 1, 32, 13, 32, 12, 253, 67, 253, 82, 34, 10, 253, 229, 1, 32, 9, 32, 10, 253, 229, 1, 32, 9, 32, 10, 253, 67, 253, 82, 253, 11, 4, 0, 32, 2, 65, 1, 106, 33, 2, 12, 1, 11, 11, 3, 64, 32, 1, 65, 0, 74, 4, 127, 32, 0, 32, 1, 106, 65, 1, 107, 65, 4, 116, 253, 0, 4, 0, 253, 12, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 253, 66, 253, 83, 5, 65, 1, 11, 69, 4, 64, 32, 1, 65, 1, 107, 33, 1, 12, 1, 11, 11, 12, 1, 11, 11, 11, 32, 7, 65, 1, 107, 34, 2, 65, 0, 74, 32, 1, 65, 1, 107, 65, 0, 78, 113, 4, 64, 32, 18, 32, 2, 32, 5, 65, 1, 107, 113, 115, 33, 18, 11, 32, 0, 33, 6, 32, 7, 33, 5, 32, 1, 33, 7, 12, 1, 11, 11, 32, 3, 65, 4, 116, 253, 12, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 32, 11, 32, 17, 253, 229, 1, 32, 17, 32, 18, 65, 1, 113, 27, 32, 5, 65, 1, 71, 27, 253, 11, 4, 0, 65, 0, 11]) : null;
	var wasmCodef32x4NoFMA = typeof Uint8Array !== 'undefined' ? new Uint8Array([0, 97, 115, 109, 1, 0, 0, 0, 1, 28, 3, 96, 4, 127, 127, 123, 127, 0, 96, 4, 123, 123, 123, 123, 1, 123, 96, 8, 127, 127, 127, 127, 127, 127, 127, 127, 1, 127, 2, 15, 1, 3, 101, 110, 118, 6, 109, 101, 109, 111, 114, 121, 2, 0, 0, 3, 4, 3, 0, 1, 2, 7, 37, 1, 33, 114, 101, 115, 117, 108, 116, 97, 110, 116, 79, 102, 73, 110, 116, 101, 103, 101, 114, 80, 111, 108, 121, 110, 111, 109, 105, 97, 108, 115, 77, 111, 100, 80, 0, 2, 10, 204, 13, 3, 237, 3, 2, 9, 123, 4, 127, 253, 12, 0, 0, 0, 0, 0, 0, 240, 66, 0, 0, 0, 0, 0, 0, 240, 66, 253, 12, 0, 0, 0, 0, 0, 0, 240, 66, 0, 0, 0, 0, 0, 0, 240, 66, 253, 12, 1, 0, 0, 0, 0, 0, 240, 63, 1, 0, 0, 0, 0, 0, 240, 63, 32, 2, 253, 95, 34, 6, 253, 243, 1, 34, 8, 253, 242, 1, 253, 117, 32, 6, 253, 242, 1, 253, 241, 1, 33, 9, 253, 12, 0, 0, 0, 0, 0, 0, 240, 66, 0, 0, 0, 0, 0, 0, 240, 66, 253, 12, 0, 0, 0, 0, 0, 0, 240, 66, 0, 0, 0, 0, 0, 0, 240, 66, 253, 12, 1, 0, 0, 0, 0, 0, 240, 63, 1, 0, 0, 0, 0, 0, 240, 63, 32, 2, 32, 2, 253, 13, 8, 9, 10, 11, 12, 13, 14, 15, 0, 1, 2, 3, 4, 5, 6, 7, 253, 95, 34, 7, 253, 243, 1, 34, 10, 253, 242, 1, 253, 117, 32, 7, 253, 242, 1, 253, 241, 1, 33, 11, 32, 0, 65, 3, 117, 33, 0, 3, 64, 32, 1, 32, 14, 74, 4, 64, 32, 0, 65, 3, 116, 43, 3, 0, 252, 2, 33, 15, 253, 12, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 33, 4, 253, 12, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 33, 5, 32, 0, 65, 1, 106, 65, 3, 116, 43, 3, 0, 252, 2, 34, 16, 65, 1, 107, 33, 13, 3, 64, 32, 13, 65, 0, 78, 4, 64, 32, 4, 32, 9, 253, 242, 1, 32, 0, 65, 2, 106, 32, 13, 106, 65, 3, 116, 253, 10, 3, 0, 34, 12, 253, 240, 1, 34, 4, 32, 4, 32, 8, 253, 242, 1, 253, 117, 32, 6, 253, 242, 1, 253, 241, 1, 33, 4, 32, 5, 32, 11, 253, 242, 1, 32, 12, 253, 240, 1, 34, 5, 32, 5, 32, 10, 253, 242, 1, 253, 117, 32, 7, 253, 242, 1, 253, 241, 1, 33, 5, 32, 13, 65, 1, 107, 33, 13, 12, 1, 11, 11, 32, 2, 32, 4, 253, 94, 32, 5, 253, 94, 34, 4, 32, 4, 253, 13, 8, 9, 10, 11, 12, 13, 14, 15, 0, 1, 2, 3, 4, 5, 6, 7, 253, 80, 34, 4, 253, 229, 1, 32, 4, 32, 15, 65, 0, 72, 27, 34, 4, 253, 12, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 253, 67, 32, 4, 32, 2, 253, 68, 253, 80, 253, 83, 4, 64, 0, 11, 32, 3, 32, 14, 106, 65, 4, 116, 32, 4, 253, 11, 4, 0, 32, 0, 65, 2, 106, 32, 16, 106, 33, 0, 32, 14, 65, 1, 106, 33, 14, 12, 1, 11, 11, 11, 201, 2, 1, 4, 123, 32, 1, 253, 12, 0, 8, 128, 69, 0, 8, 128, 69, 0, 8, 128, 69, 0, 8, 128, 69, 32, 1, 253, 230, 1, 34, 4, 32, 4, 32, 1, 253, 229, 1, 253, 229, 1, 34, 4, 253, 229, 1, 33, 5, 32, 0, 253, 12, 0, 8, 128, 69, 0, 8, 128, 69, 0, 8, 128, 69, 0, 8, 128, 69, 32, 0, 253, 230, 1, 34, 6, 32, 6, 32, 0, 253, 229, 1, 253, 229, 1, 34, 6, 253, 229, 1, 33, 7, 32, 0, 32, 1, 253, 230, 1, 34, 0, 32, 6, 32, 4, 253, 230, 1, 253, 229, 1, 32, 6, 32, 5, 253, 230, 1, 253, 229, 1, 32, 7, 32, 4, 253, 230, 1, 253, 229, 1, 32, 7, 32, 5, 253, 230, 1, 253, 229, 1, 33, 1, 32, 2, 253, 12, 0, 8, 128, 69, 0, 8, 128, 69, 0, 8, 128, 69, 0, 8, 128, 69, 32, 2, 253, 230, 1, 34, 4, 32, 4, 32, 2, 253, 229, 1, 253, 229, 1, 34, 4, 253, 229, 1, 33, 5, 32, 0, 253, 12, 0, 8, 128, 69, 0, 8, 128, 69, 0, 8, 128, 69, 0, 8, 128, 69, 32, 0, 32, 3, 253, 230, 1, 253, 104, 34, 0, 253, 230, 1, 34, 3, 32, 3, 32, 0, 253, 229, 1, 253, 229, 1, 34, 3, 32, 4, 253, 230, 1, 253, 229, 1, 32, 3, 32, 5, 253, 230, 1, 253, 229, 1, 32, 0, 32, 3, 253, 229, 1, 34, 0, 32, 4, 253, 230, 1, 253, 229, 1, 32, 0, 32, 5, 253, 230, 1, 253, 229, 1, 34, 0, 32, 1, 32, 2, 253, 229, 1, 253, 229, 1, 32, 0, 32, 1, 253, 229, 1, 32, 0, 32, 1, 253, 67, 253, 82, 32, 0, 32, 1, 32, 2, 253, 228, 1, 34, 1, 253, 229, 1, 32, 0, 32, 1, 253, 67, 253, 82, 11, 143, 7, 2, 10, 123, 1, 127, 253, 12, 0, 0, 128, 63, 0, 0, 128, 63, 0, 0, 128, 63, 0, 0, 128, 63, 32, 2, 65, 4, 116, 253, 0, 4, 0, 34, 10, 253, 231, 1, 33, 15, 32, 0, 32, 5, 32, 10, 32, 4, 16, 0, 32, 1, 32, 7, 32, 10, 32, 6, 16, 0, 32, 5, 32, 7, 72, 4, 64, 32, 5, 33, 0, 32, 4, 33, 1, 32, 6, 33, 4, 32, 7, 34, 5, 65, 1, 107, 32, 0, 34, 7, 65, 1, 107, 113, 33, 18, 32, 1, 33, 6, 11, 253, 12, 0, 0, 128, 63, 0, 0, 128, 63, 0, 0, 128, 63, 0, 0, 128, 63, 33, 14, 3, 64, 32, 7, 65, 1, 107, 65, 0, 78, 4, 64, 32, 6, 32, 7, 106, 65, 1, 107, 65, 4, 116, 253, 0, 4, 0, 34, 11, 253, 12, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 253, 65, 253, 83, 4, 64, 65, 1, 15, 11, 32, 11, 33, 8, 32, 10, 33, 9, 253, 12, 0, 0, 128, 63, 0, 0, 128, 63, 0, 0, 128, 63, 0, 0, 128, 63, 33, 12, 253, 12, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 33, 13, 3, 64, 32, 8, 32, 8, 32, 9, 253, 231, 1, 253, 106, 34, 8, 32, 9, 253, 230, 1, 253, 229, 1, 33, 17, 32, 12, 32, 8, 32, 13, 253, 230, 1, 253, 229, 1, 33, 16, 32, 9, 34, 8, 32, 17, 32, 17, 253, 12, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 253, 55, 34, 17, 253, 82, 33, 9, 32, 13, 34, 12, 32, 16, 32, 17, 253, 82, 33, 13, 32, 17, 253, 164, 1, 65, 15, 71, 13, 0, 11, 253, 12, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 32, 12, 253, 229, 1, 32, 12, 32, 8, 253, 12, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 253, 67, 253, 82, 34, 8, 32, 10, 253, 228, 1, 32, 8, 32, 8, 253, 12, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 253, 67, 253, 82, 33, 8, 65, 0, 33, 0, 3, 64, 32, 0, 32, 7, 72, 4, 64, 32, 0, 32, 6, 106, 65, 4, 116, 34, 1, 32, 1, 253, 0, 4, 0, 32, 8, 32, 10, 32, 15, 16, 1, 253, 11, 4, 0, 32, 0, 65, 1, 106, 33, 0, 12, 1, 11, 11, 32, 5, 65, 1, 107, 33, 0, 253, 12, 0, 0, 128, 63, 0, 0, 128, 63, 0, 0, 128, 63, 0, 0, 128, 63, 33, 8, 3, 64, 32, 0, 4, 64, 32, 0, 32, 0, 65, 1, 117, 34, 0, 32, 0, 106, 71, 4, 64, 32, 8, 32, 11, 32, 10, 32, 15, 16, 1, 33, 8, 11, 32, 11, 32, 11, 32, 10, 32, 15, 16, 1, 33, 11, 12, 1, 11, 11, 32, 14, 32, 8, 32, 10, 32, 15, 16, 1, 33, 14, 32, 4, 33, 0, 32, 6, 33, 4, 65, 127, 33, 1, 32, 7, 4, 127, 32, 6, 32, 7, 106, 65, 1, 107, 65, 4, 116, 253, 0, 4, 0, 253, 12, 0, 0, 128, 63, 0, 0, 128, 63, 0, 0, 128, 63, 0, 0, 128, 63, 253, 66, 253, 83, 5, 65, 1, 11, 69, 4, 64, 32, 5, 33, 1, 3, 64, 32, 1, 32, 7, 78, 4, 64, 32, 0, 32, 1, 106, 65, 1, 107, 65, 4, 116, 253, 0, 4, 0, 33, 8, 32, 1, 32, 7, 107, 33, 2, 3, 64, 32, 1, 32, 2, 74, 4, 64, 32, 8, 32, 4, 32, 7, 106, 32, 2, 106, 32, 1, 107, 65, 4, 116, 253, 0, 4, 0, 32, 10, 32, 15, 16, 1, 33, 9, 32, 0, 32, 2, 106, 65, 4, 116, 34, 6, 253, 0, 4, 0, 33, 11, 32, 6, 32, 11, 32, 10, 253, 228, 1, 32, 9, 253, 229, 1, 32, 11, 32, 9, 253, 229, 1, 32, 11, 32, 9, 253, 67, 253, 82, 253, 11, 4, 0, 32, 2, 65, 1, 106, 33, 2, 12, 1, 11, 11, 3, 64, 32, 1, 65, 0, 74, 4, 127, 32, 0, 32, 1, 106, 65, 1, 107, 65, 4, 116, 253, 0, 4, 0, 253, 12, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 253, 66, 253, 83, 5, 65, 1, 11, 69, 4, 64, 32, 1, 65, 1, 107, 33, 1, 12, 1, 11, 11, 12, 1, 11, 11, 11, 32, 7, 65, 1, 107, 34, 2, 65, 0, 74, 32, 1, 65, 1, 107, 65, 0, 78, 113, 4, 64, 32, 18, 32, 2, 32, 5, 65, 1, 107, 113, 115, 33, 18, 11, 32, 0, 33, 6, 32, 7, 33, 5, 32, 1, 33, 7, 12, 1, 11, 11, 32, 3, 65, 4, 116, 253, 12, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 32, 10, 32, 14, 253, 229, 1, 32, 14, 32, 18, 65, 1, 113, 27, 32, 5, 65, 1, 71, 27, 253, 11, 4, 0, 65, 0, 11]) : null;

	function nmaddIsSupported() {

		try {
			var wasm_nmadd = new Uint8Array([0, 97, 115, 109, 1, 0, 0, 0, 1, 8, 1, 96, 3, 124, 124, 124, 1, 124, 3, 2, 1, 0, 7, 9, 1, 5, 110, 109, 97, 100, 100, 0, 0, 10, 22, 1, 20, 0, 32, 0, 253, 20, 32, 1, 253, 20, 32, 2, 253, 20, 253, 136, 2, 253, 33, 0, 11]);
			var wasmModule1 = new WebAssembly.Module(wasm_nmadd);
			var nmaddWasm = new WebAssembly.Instance(wasmModule1).exports.nmadd;
			return nmaddWasm(3, Math.pow(2, 52) - 1, 13510798882111484) === -1;
		} catch (error) {
			console.log(error);
		}
		return false;
	}

	var wasmVectorType = 'f32';
	var wasmVectorLength = 4;
	var resultantOfIntegerPolynomialsModP = null;

	var memory = null;

	function setup(opts, wasmCode) {
		initialized = true;
		primesCache = [];

		wasmVectorType = opts.wasmVectorType;
		wasmVectorLength = opts.wasmVectorLength;
		try {
			var wasmModule = new WebAssembly.Module(wasmCode);
			memory = new WebAssembly.Memory({
				initial: 1
			});
			var resultantOfIntegerPolynomialsModPWASM = new WebAssembly.Instance(wasmModule, {env: {memory: memory}}).exports.resultantOfIntegerPolynomialsModP;
			resultantOfIntegerPolynomialsModP = resultantOfIntegerPolynomialsModPWASM;
		} catch (error) {
			console.log(error);
		}
	}

	Polynomial._setupResultant = setup;

	var primesCacheMax = 0;
	var primesCache = [];
	var getPrimes = function (max, n) {
		if (primesCacheMax !== max) {
			primesCache.length = 0;
			primesCacheMax = max;
		}
		var p = primesCache.length === 0 ? max : primesCache[primesCache.length - 1];
		while (primesCache.length < n && p > 3) {
			do {
				p -= p % 2 === 0 ? 1 : 2;
			} while (!primeFactor._isPrime(p));
			primesCache.push(p);
		}
		return primesCache.slice(0, n);
	};

	function coefficients(buffer, byteOffset, polynomial) {
		var offset = 0;
		var f64 = wasmVectorType === 'f32' || wasmVectorType === 'f64' ? new Float64Array(buffer, byteOffset) : (wasmVectorType === 'u16' ? new Uint16Array(buffer, byteOffset) : null);
		var max = wasmVectorType === 'f32' || wasmVectorType === 'f64' ? Math.pow(2, 48) : (wasmVectorType === 'u16' ? Math.pow(2, 16) : 0);
		var c = Math.floor(Math.log2(max) / 4);
		var n = polynomial.getDegree() + 1;
		for (var i = 0; i < n; i += 1) {
			var coefficient = polynomial.getCoefficient(i).toBigInt();

			if (typeof coefficient === 'number') {
				f64[offset] = coefficient < 0 ? -1 : 1;
				coefficient = Math.abs(coefficient);
				offset += 1;
				var lengthPos = offset;
				var length = 0;
				f64[offset] = -1;
				offset += 1;
				while (coefficient !== 0) {
					var q = Math.floor(coefficient / max);
					var digit = coefficient - q * max;
					coefficient = q;
					f64[offset] = digit;
					offset += 1;
					length += 1;
				}
				f64[lengthPos] = length;
			} else {

				var sign = 1;
				if (coefficient < BigInt(0)) {
					coefficient = -coefficient;
					sign = -1;
				}
				f64[offset] = sign;
				offset += 1;
				var s = coefficient.toString(16);
				var length = Math.ceil(s.length / c);
				f64[offset] = length;
				offset += 1;
				for (var j = 0; j < length; j += 1) {
					var p = s.length - j * c;
					var digit = Number.parseInt(s.slice(p < c ? 0 : p - c, p), 16);
					f64[offset] = digit;
					offset += 1;
				}
			}
		}
		return f64.subarray(0, offset);
	}

	var initialized = false;
	Polynomial._resultantOfIntegerPolynomialsUsingModularAlgorithm = function (A, B) {
		if (!initialized) {
			if (globalThis.BigInt != undefined && typeof BigInt(0) === 'bigint') {
				if (nmaddIsSupported()) {
					Polynomial._setupResultant({
						wasmVectorType: 'f32',
						wasmVectorLength: 4
					}, wasmCodef32x4);
				} else {
					Polynomial._setupResultant({
						wasmVectorType: 'f32',
						wasmVectorLength: 4
					}, wasmCodef32x4NoFMA);
				}
			}
		}
		if (resultantOfIntegerPolynomialsModP == null) {
			return Polynomial._resultantUsingSubresultantPseudoRemainderSequence(A, B);
		}
		if (A.getDegree() === 0) {
			return A.getCoefficient(0)._pow(B.getDegree());
		}
		if (B.getDegree() === 0) {
			return B.getCoefficient(0)._pow(A.getDegree());
		}
		if (A.equals(B.negate())) {
			return Expression.ZERO;
		}

		var n1 = A._log2hypot();
		var n2 = B._log2hypot();
		var BOUND = n1 * B.getDegree() + n2 * A.getDegree() + 1;

		var An = A.getDegree() + 1;
		var Bn = B.getDegree() + 1;

		var memorySize = 16 * 3 + (Math.ceil(n1 / 8 * 4 / 3) + 24 + 16) * An + (Math.ceil(n2 / 8 * 4 / 3) + 24 + 16) * Bn;
		if (memorySize > Math.pow(2, 30)) {
			return Polynomial._resultantUsingSubresultantPseudoRemainderSequence(A, B);
		}
		if (memory.buffer.byteLength < memorySize) {
			memory.grow(Math.ceil((memorySize - memory.buffer.byteLength) / (64 * 1024)));
		}

		var vectorSize = 4;

		var byteOffset = 0;

		var createVecArray = function (n) {
			var array = wasmVectorType === 'f32' ? new Float32Array(memory.buffer, byteOffset, wasmVectorLength * n) : (wasmVectorType === 'u16' ? new Uint16Array(memory.buffer, byteOffset, wasmVectorLength * n) : (wasmVectorType === 'f64' ? new Float64Array(memory.buffer, byteOffset, wasmVectorLength * n) : null));
			byteOffset += n << vectorSize;
			return array;
		};

		var cA = coefficients(memory.buffer, byteOffset, A);
		byteOffset += cA.byteLength;
		var cB = coefficients(memory.buffer, byteOffset, B);
		byteOffset += cB.byteLength;

		byteOffset += (1 << vectorSize) - byteOffset % (1 << vectorSize);

		var prime = createVecArray(1);
		var result = createVecArray(1);
		var polynomialAmodP = createVecArray(An);
		var polynomialBmodP = createVecArray(Bn);

		if (memorySize < byteOffset) {
			throw new TypeError();
		}

		var M = (wasmVectorType === 'u16' ? 16 : (wasmVectorType === 'f32' ? 23 : (wasmVectorType === 'f64' ? 52 : 0)));
		var avgLog = M * 0.89;
		var primesNeeded = Math.ceil(BOUND / avgLog / wasmVectorLength) * wasmVectorLength;
		var primes = getPrimes(Math.ceil(Math.pow(2, M)), primesNeeded);
		if (primes.length < primesNeeded) {

			console.warn('FIX ME', primes.length);
			return Polynomial._resultantUsingSubresultantPseudoRemainderSequence(A, B);
		}

		var i = 0;
		var P = 0;
		var array = [];
		while (P < BOUND) {
			for (var k = 0; k < wasmVectorLength; k += 1) {
				if (i >= primes.length) {
					throw new TypeError();
				}
				var p = primes[i];
				i += 1;
				prime[k] = p;
			}
			if (resultantOfIntegerPolynomialsModP(cA.byteOffset, cB.byteOffset, prime.byteOffset >> vectorSize, result.byteOffset >> vectorSize, polynomialAmodP.byteOffset >> vectorSize, An, polynomialBmodP.byteOffset >> vectorSize, Bn) !== 0) {

				console.warn('fallback');

				var p1 = new Array(wasmVectorLength);
				for (var k = 0; k < wasmVectorLength; k += 1) {
					p1[k] = prime[k];
				}
				var r1 = new Array(wasmVectorLength);
				for (var k = 0; k < wasmVectorLength; k += 1) {
					prime.fill(p1[k]);
					if (resultantOfIntegerPolynomialsModP(cA.byteOffset, cB.byteOffset, prime.byteOffset >> vectorSize, result.byteOffset >> vectorSize, polynomialAmodP.byteOffset >> vectorSize, An, polynomialBmodP.byteOffset >> vectorSize, Bn) !== 0) {
						throw new TypeError();
					}
					r1[k] = result[0];
				}
				for (var k = 0; k < wasmVectorLength; k += 1) {
					prime[k] = p1[k];
					result[k] = r1[k];
				}
			}
			for (var k = 0; k < wasmVectorLength; k += 1) {
				var p = prime[k];
				var Res_p = result[k];
				array.push({
					modulus: p,
					integer: Res_p
				});
				if (false) {
					var expected = Polynomial._resultantUsingSubresultantPseudoRemainderSequence(A, B).modulo(new Expression.Integer(p)).toNumber();
					if (expected !== Res_p) {
						console.assert(expected === Res_p)
					}
				}
			}
			for (var k = 0; k < wasmVectorLength; k += 1) {
				P += Math.log2(prime[k]);
			}
		}

		function fastCRT(array) {
			if (array.length === 1) {
				return array[0];
			}
			var m = array.length >> 1;
			var a = fastCRT(array.slice(0, m));
			var b = fastCRT(array.slice(m));
			return {
				integer: ChineseRemainderTheorem(a.modulus, b.modulus)(a.integer, b.integer),
				modulus: a.modulus.multiply(b.modulus)
			};
		}

		function CRT2(array) {
			var a2 = array.map(function (a) {
				return {
					integer: Expression.Integer.fromBigInt(a.integer),
					modulus: Expression.Integer.fromBigInt(a.modulus)
				};
			});
			var s = fastCRT(a2);
			return s.integer.roundMod(s.modulus).toBigInt();
		}

		var Res = Expression.Integer.fromBigInt(array.length > 1000 ? CRT2(array) : CRT(array));

		if (false) {
			var expected = Polynomial._resultantUsingSubresultantPseudoRemainderSequence(A, B);
			if (!Res.equals(expected)) {
				throw new Error(expected + ' ' + Res + ' ' + P + ' ' + ' ' + BOUND + ' ' + primes + '  ' + M);
			}
		}

		return Res;
	};
}

function Eigenvalues() {
	globalThis.factorsMap = new Map();

	Expression.getPolynomialRootsWithSteps = function (polynomial, callback, flag0) {
		var roots = polynomial.getroots(callback);

		var zeros = [];
		if (typeof polynomial.getZeros === "function" && roots.length !== polynomial.getDegree()) {
			var p = Polynomial.of(Expression.ONE);
			for (var i = 0; i < roots.length; i += 1) {
				p = p.multiply(Polynomial.of(roots[i].negate(), Expression.ONE));
			}
			var r = polynomial.divideAndRemainder(p).quotient;
			globalThis.factorsMap = new Map();
			var getZerosTricky = function (f) {
				var pp = f.primitivePart();
				if (!pp.hasIntegerCoefficients()) {
					if (!pp.hasComplexCoefficients()) {
						return f.getZeros(true);
					}
				}
				f = pp;

				var tmp = f.squareFreeFactors();
				var a0 = tmp.a0;
				var a1 = tmp.a1;

				if (a0.getDegree() !== 0) {
					var tmp1 = getZerosTricky(a1);
					var tmp2 = getZerosTricky(a0);
					var result = [];
					var previous = undefined;
					for (var i = 0; i < tmp2.length; i += 1) {
						var zero = tmp2[i];
						if (zero !== previous) {
							result.push(zero);
							previous = zero;
						}
						result.push(zero);
					}
					return tmp1.concat(result);
				}

				var factor = !flag0 ? f._factorizeOverGaussianIntegers().next().value : f.factorize();
				if (factor == null) {
					factor = f;
				}
				if (!factor.equals(f)) {
					return getZerosTricky(factor).concat(getZerosTricky(f.divideAndRemainder(factor, "throw").quotient));
				}
				var zeros = factor.getZeros(true);
				for (var iteratorzero = zeros[globalThis.Symbol.iterator](), zero = iteratorzero.next().value; zero != null; zero = iteratorzero.next().value) {
					globalThis.factorsMap.set(zero, factor);
				}
				return zeros;
			};

			zeros = getZerosTricky(r);
			if (callback != undefined) {
				if (zeros.length === r.getDegree()) {
					callback({
						content: Expression.ONE,
						roots: roots.concat(zeros),
						newPolynomial: Polynomial.of(polynomial.getLeadingCoefficient()),
						type: "realRootIsolationAndNewton'sMethod"
					});
				}
			}
		}

		for (var i = 0; i < roots.length; i += 1) {
			var root = roots[i];
			for (var j = 0; j < roots.length; j += 1) {
				if (roots[j].equals(root)) {
					roots[j] = root;
				}
			}
		}

		return roots.concat(zeros);
	};

	Expression.getEigenvalues = function (matrix, callback) {

		if (!matrix.isSquare()) {
			throw new RangeError("NonSquareMatrixException");
		}

		var entriesGCD = function (matrix) {
			var g1 = Expression.ZERO;
			var g2 = Expression.ONE;
			matrix.map(function (e) {
				if (Expression.isScalar(e)) {
					g1 = g1.gcd(e.getNumerator());
					g2 = g2.lcm(e.getDenominator());
				}
				return Expression.ZERO;
			});
			return g1.divide(g2);
		};
		var g = Expression.ONE;
		var gInv = Expression.ONE;
		if (callback == null) {
			g = entriesGCD(matrix);
			if (g.equals(Expression.ZERO)) {
				g = Expression.ONE;
			} else {
				gInv = g.inverse();
				matrix = matrix.scale(gInv);
			}
		}

		var determinant = matrix.map(function (e, i, j) {
			var p = i === j ? Polynomial.of(e, Expression.ONE.negate()) : (e.equals(Expression.ZERO) ? Polynomial.ZERO : Polynomial.of(e));
			return new Expression.Polynomial(p);
		}).determinant();

		determinant = determinant.polynomial;

		determinant = determinant._scaleRoots(g);
		determinant = determinant.scale(g._pow(matrix.cols()));

		determinant = determinant.map(function (e) {
			return e.simplifyExpression();
		});

		var characteristicPolynomial = determinant;
		if (callback != null) {
			callback(characteristicPolynomial);
		}

		console.time('p3');
		var eigenvalues = Expression.getPolynomialRootsWithSteps(characteristicPolynomial, callback, Expression.isRationalMatrix(matrix));
		console.timeEnd('p3');

		return eigenvalues;
	};

	Expression.isRational = function (e) {
		return e instanceof Expression.Integer || e instanceof Expression.BinaryOperation && Expression.isRational(e.a) && Expression.isRational(e.b);
	};

	Expression.isRationalMatrix = function (A) {
		for (var i = 0; i < A.rows(); i += 1) {
			for (var j = 0; j < A.cols(); j += 1) {
				if (!Expression.isRational(A.e(i, j))) {
					return false;
				}
			}
		}
		return true;
	};

	Expression.isGaussianRational = function (e) {
		return e instanceof Expression.Complex || e instanceof Expression.Integer || (e instanceof Expression.BinaryOperation && Expression.isGaussianRational(e.a) && Expression.isGaussianRational(e.b));
	};

	Expression.isGaussianRationalMatrix = function (A) {
		for (var i = 0; i < A.rows(); i += 1) {
			for (var j = 0; j < A.cols(); j += 1) {
				if (!Expression.isGaussianRational(A.e(i, j))) {
					return false;
				}
			}
		}
		return true;
	};

	Expression.getSolutionSet = function getSolutionSet(matrix) {
		var fullMatrix = matrix.augment(Matrix.Zero(matrix.cols(), 1));
		var result = fullMatrix.toRowEchelon(Matrix.GaussMontante, "solving", undefined);
		var tmp = Matrix.solveByGaussNext(result.matrix);
		var basisVectors = Matrix.getSolutionSet(tmp).basisVectors;
		return basisVectors;
	};

	Expression.getEigenvectors = function (matrix, eigenvalues, internal) {
		internal = internal == undefined ? false : internal;

		if (eigenvalues == undefined) {

			eigenvalues = Expression.getEigenvalues(matrix);
		}

		var eigenvectors = new Array(eigenvalues.length).fill(null);
		var uniqueEigenvalues = Expression.unique(eigenvalues);

		var setResults = function (eigenvalue, currentEigenvectors) {
			var j = 0;
			for (var k = 0; k < eigenvalues.length && j < currentEigenvectors.length; k += 1) {
				if (eigenvalues[k] === eigenvalue) {
					eigenvectors[k] = currentEigenvectors[j];
					j += 1;
				}
			}
			if (j < currentEigenvectors.length) {
				throw new TypeError("wrong eigenvalues argument: the eigenvalue should appear multiple times");
			}
		};

		if (!internal && matrix.isSquare() && Expression.isGaussianRationalMatrix(matrix)) {
			var map = new Map();
			for (var iteratoreigenvalue = uniqueEigenvalues[globalThis.Symbol.iterator](), eigenvalue = iteratoreigenvalue.next().value; eigenvalue != null; eigenvalue = iteratoreigenvalue.next().value) {
				var factor = globalThis.factorsMap.get(eigenvalue);
				if (factor == null || factor.getDegree() <= 1) {
					var currentEigenvectors = Expression.getEigenvectors(matrix, eigenvalues.filter(function (e) {
						return e === eigenvalue;
					}), true);
					setResults(eigenvalue, currentEigenvectors);
				} else {
					var currentEigenvectors = map.get(factor);
					if (currentEigenvectors == null) {
						var root = SomePolynomialRoot.create(factor);
						currentEigenvectors = Expression.getEigenvectors(matrix, eigenvalues.filter(function (e) {
							return e === eigenvalue;
						}).map(function (e) {
							return root;
						}), true);
						map.set(factor, currentEigenvectors);
					}
					var zeroPows = [];
					zeroPows.push(Expression.ONE);
					var subs = function (x) {
						return x instanceof SomePolynomialRoot ? x.calcAt(eigenvalue, zeroPows) : x;
					};
					setResults(eigenvalue, currentEigenvectors.map(function (v) {
						return new Matrix.Vector(v.elements.map(function (e) {
							return subs(e);
						}));
					}));
				}
			}

			return eigenvectors;
		}

		var entriesGCD = function (matrix) {
			var g1 = Expression.ZERO;
			var g2 = Expression.ONE;
			matrix.map(function (e) {
				if (Expression.isScalar(e)) {
					g1 = g1.gcd(e.getNumerator());
					g2 = g2.lcm(e.getDenominator());
				}
				return Expression.ZERO;
			});
			return g1.divide(g2);
		};
		var g = Expression.ONE;
		var gInv = Expression.ONE;
		if (true) {
			g = entriesGCD(matrix);
			if (g.equals(Expression.ZERO)) {
				g = Expression.ONE;
			}
			gInv = g.inverse();
		}

		var isRealMatrix = false;
		try {
			isRealMatrix = matrix.eql(matrix.map(function (e) {
				return e.complexConjugate();
			}));
		} catch (error) {

			console.error(error);
		}

		for (var i = 0; i < uniqueEigenvalues.length; i += 1) {
			var eigenvalue = uniqueEigenvalues[i];
			var n = matrix.cols();

			var currentEigenvectors = Expression.getSolutionSet(matrix.scale(gInv).subtract(Matrix.I(n).scale(eigenvalue.multiply(gInv))));
			setResults(eigenvalue, currentEigenvectors);
			console.debug('eigenvectors: ' + (i + 1) + '/' + uniqueEigenvalues.length);

			var cc = null;
			if (i + 1 < uniqueEigenvalues.length) {
				try {
					cc = eigenvalue.complexConjugate();
				} catch (error) {

					console.error(error);
				}
			}

			if (i + 1 < uniqueEigenvalues.length && isRealMatrix && cc != null && cc.equals(uniqueEigenvalues[i + 1])) {

				var complexConjugate = function (vector) {
					return new Matrix.Vector(vector.elements.map(function (e) {
						return e.complexConjugate();
					}));
				};
				setResults(uniqueEigenvalues[i + 1], currentEigenvectors.map(function (vector) {
					return complexConjugate(vector);
				}));
				i += 1;
			}
		}
		return eigenvectors;
	};

	Expression.isReal = function (e) {
		var isReal = function (e) {
			if (e instanceof Expression.Integer) {
				return true;
			}
			if (e instanceof Expression.NthRoot) {
				return isReal(e.a);
			}
			if (e instanceof Expression.BinaryOperation) {
				if (isReal(e.a) && isReal(e.b)) {
					return true;
				}
			}
			if (e === Expression.E || e === Expression.PI) {
				return true;
			}
			if (e instanceof Expression.Function) {
				return isReal(e.a);
			}
			if (e instanceof Expression.PolynomialRootSymbol) {
				return true;
			}
			if (e instanceof Expression.ExpressionWithPolynomialRoot) {
				return isReal(e.e);
			}
			if (e instanceof Expression.ExpressionPolynomialRoot) {
				return true;
			}
			if (!(e instanceof Expression.Symbol)) {
				if (!(e instanceof Expression.Exponentiation)) {
					if (e.complexConjugate().equals(e)) {
						return true;
					}
				}
			}
			return false;
		};
		return isReal(e);
	};

	Expression.isRealMatrix = function (A) {
		for (var i = 0; i < A.rows(); i += 1) {
			for (var j = 0; j < A.cols(); j += 1) {
				if (!Expression.isReal(A.e(i, j))) {
					return false;
				}
			}
		}
		return true;
	};

	Matrix.prototype.conjugateTranspose = function () {
		return this.transpose().map(function (e) {
			return e.complexConjugate();
		});
	};

	Matrix.fromVectors = function (vectors) {
		if (vectors.length === 0) {
			throw new RangeError();
		}
		var dimensions = vectors[0].dimensions();
		for (var i = 0; i < vectors.length; i += 1) {
			if (vectors[i].dimensions() !== dimensions) {
				throw new RangeError();
			}
		}
		return Matrix.Zero(dimensions, vectors.length).map(function (e, i, j) {
			return vectors[j].e(i);
		});
	};
}

function ConditionClass() {
	function Condition(array) {
		Object.freeze(array);
		this.array = array;
	}

	Condition.NEZ = " != 0";
	Condition.EQZ = " == 0";

	Condition.GTZ = " > 0";

	Condition.prototype._and = function (operator, e) {

		if (operator !== Condition.NEZ && operator !== Condition.EQZ && operator !== Condition.GTZ) {
			throw new TypeError();
		}
		if (e == undefined) {
			throw new RangeError();
		}
		if (this === Condition.FALSE) {
			return this;
		}

		var contains = function (array, operator, e) {
			for (var i = 0; i < array.length; i += 1) {
				if (array[i].operator === operator && array[i].expression.equals(e)) {
					return true;
				}
			}
			return false;
		};

		if (e instanceof Expression.GF2Value) {
			return this._and(operator, e.value === 0 ? Expression.ZERO : Expression.ONE);
		}

		var add = function (oldArray, y) {

			if (contains(oldArray, y.operator, y.expression)) {
				return oldArray;
			}
			if (contains(oldArray, y.operator === Condition.EQZ ? Condition.NEZ : Condition.EQZ, y.expression)) {
				return null;
			}

			var operator = null;
			var e = y.expression;

			if (Expression.has(e, Expression.Sin) || Expression.has(e, Expression.Cos) || Expression.has(e, Expression.Exponentiation) || Expression.has(e, Expression.Arctan) || Expression.has(e, Expression.Logarithm) || Expression.has(e, Expression.Abs)) {
				if (oldArray.length > 0) {
					e = Expression._map(function (x) {
						if (x instanceof Expression.Function && !(x instanceof Expression.NthRoot) || x instanceof Expression.Exponentiation && (!(x.b instanceof Expression.Integer) || !(x.a instanceof Expression.Symbol))) {
							var r = x instanceof Expression.Exponentiation ? x.b : x.a;
							var arg = null;
							var array = null;
							if (!(r instanceof Expression.Symbol)) {
								arg = new Expression.Symbol('__arg');
								var argsr = arg.subtract(r);
								console.assert(!argsr.isNegative());
								array = add(oldArray, {
									expression: argsr,
									operator: Condition.EQZ
								});
								if (array == null) {

									return x;
								}
							} else {
								arg = r;
								array = oldArray;
							}
							for (var i = 0; i < array.length; i += 1) {
								var y = array[i];
								if (y.operator === Condition.EQZ) {
									var polynomial = Polynomial.toPolynomial(y.expression, arg);
									if (polynomial.getDegree() === 1) {
										var yy = polynomial.getCoefficient(0).negate().divide(polynomial.getCoefficient(1));
										if (!Expression.has(yy, Expression.Function)) {
											if (yy.compare4Addition(arg) < 0 && !(yy instanceof Expression.Division) || Expression.isConstant(yy) || Expression.isConstant(yy.divide(Expression.PI))) {
												if (x instanceof Expression.Exponentiation) {

													return x.a.pow(yy);
												} else if (x instanceof Expression.Arctan) {
													return yy.arctan();
												} else if (x instanceof Expression.Logarithm) {
													return yy.logarithm();
												} else if (x instanceof Expression.Abs) {
													return yy.abs();
												} else {
													yy = Expression.isConstant(yy) && !(yy.equals(Expression.ZERO)) && !(yy instanceof Expression.Radians) && !Expression.has(yy, Expression.Symbol) ? new Expression.Radians(yy) : yy;
													if (x instanceof Expression.Sin) {
														return yy.sin();
													} else if (x instanceof Expression.Cos) {
														return yy.cos();
													} else {
														throw new TypeError("NotSupportedError");
													}
												}
											}
										}
									}
								}
							}
							return x;
						}
						return x;
					}, e);
					y = {
						expression: e,
						operator: y.operator
					};
				}
			}

			if (e.isNegative() && (y.operator === Condition.EQZ || y.operator === Condition.NEZ)) {
				return add(oldArray, {
					expression: e.negate(),
					operator: y.operator
				});
			}

			if (e instanceof Expression.Exponentiation

			) {
				if (y.operator === Condition.EQZ || y.operator === Condition.NEZ) {
					return add(oldArray, {
						expression: e.a,
						operator: y.operator
					});
				}
			}

			if (e instanceof Expression.Addition && e.a instanceof Expression.Exponentiation && Expression.isConstant(e.b) && e.a.b.getDenominator() instanceof Expression.Integer && !e.a.b.getDenominator().equals(Expression.ONE)) {
				if (e.a.b.getDenominator().remainder(Expression.TWO).equals(Expression.ZERO) && !e.b.isNegative()) {
					return add(oldArray, {
						expression: Expression.ONE,
						operator: y.operator
					});
				}

				return add(oldArray, {
					expression: e.a.a.pow(e.a.b.getNumerator()).subtract(e.b.negate().pow(e.a.b.getDenominator())),
					operator: y.operator
				});
			}

			if (y.expression instanceof Expression.Multiplication && y.expression.b instanceof Expression.IdentityMatrix) {
				return add(oldArray, {
					expression: y.expression.a,
					operator: y.operator
				});
			}
			if (y.expression instanceof Expression.Division) {
				var tmp = oldArray;
				tmp = add(tmp, {
					expression: y.expression.a,
					operator: y.operator
				});
				if (tmp == null) {
					return null;
				}
				tmp = add(tmp, {
					expression: y.expression.b,
					operator: Condition.NEZ
				});
				return tmp;
			}

			if (y.expression instanceof Expression.Integer || y.expression instanceof Expression.Complex) {
				if (y.operator === Condition.NEZ && y.expression.equals(Expression.ZERO) || y.operator === Condition.EQZ && !y.expression.equals(Expression.ZERO)) {
					return null;
				}
				if (y.operator === Condition.GTZ && y.expression.equals(Expression.ZERO)) {
					return null;
				}
				if (y.operator === Condition.GTZ && y.expression instanceof Expression.Integer && y.expression.compareTo(Expression.ZERO) < 0) {
					return null;
				}
				return oldArray;
			}

			if (Expression.isConstant(y.expression) && !y.expression.equals(Expression.ZERO)) {
				if (y.operator === Condition.NEZ) {
					return oldArray;
				}
				if (y.operator === Condition.EQZ) {
					return null;
				}
			}
			if (y.expression instanceof Expression.Matrix) {
				if (y.expression.matrix.isZero()) {
					if (y.operator === Condition.EQZ) {
						return oldArray;
					}
					if (y.operator === Condition.NEZ) {
						return null;
					}
				}
			}
			if (y.expression instanceof Expression.NthRoot) {
				return add(oldArray, {
					expression: y.expression.a,
					operator: y.operator
				});
			}
			if (Expression.has(y.expression, Expression.Abs)) {
				if (y.expression instanceof Expression.Abs && (y.operator === Condition.EQZ || y.operator === Condition.NEZ)) {
					return add(oldArray, {
						expression: y.expression.a,
						operator: y.operator
					});
				}
				if (y.expression instanceof Expression.Abs && (y.operator === Condition.GTZ)) {
					return oldArray;
				}
				if (y.expression.negate() instanceof Expression.Abs && (y.operator === Condition.GTZ)) {
					return null;
				}
				if (y.expression instanceof Expression.Addition) {
					if (y.expression.a instanceof Expression.Abs && y.expression.b instanceof Expression.Integer) {
						if (y.operator === Condition.GTZ) {
							return oldArray;
						}
					}
				}
			}
			if (Expression.has(y.expression, Expression.ComplexConjugate)) {
				if (!Expression.has(y.expression.complexConjugate(), Expression.ComplexConjugate)) {
					return add(oldArray, {
						expression: y.expression.complexConjugate(),
						operator: y.operator
					});
				}
			}
			if (y.expression instanceof Expression.Multiplication) {
				if (y.operator === Condition.EQZ) {
					if (y.expression.a instanceof Expression.Integer && !y.expression.a.equals(Expression.ZERO)) {

						y = {
							expression: y.expression.b,
							operator: y.operator
						};
						return add(oldArray, y);
					}
				}
				if (y.operator === Condition.NEZ) {
					var tmp = oldArray;
					tmp = add(tmp, {
						expression: y.expression.a,
						operator: Condition.NEZ
					});
					if (tmp == null) {
						return null;
					}
					tmp = add(tmp, {
						expression: y.expression.b,
						operator: Condition.NEZ
					});
					return tmp;
				}
			}

			var p = Expression.getMultivariatePolynomial(y.expression);
			if (p != null) {

				var t = Expression.getNthRootConjugate(p.p.getLeadingCoefficient());
				if (t != undefined && Expression.isConstant(t)) {
					return add(oldArray, {
						expression: t.multiply(y.expression),
						operator: y.operator
					});
				}

				var content = p.p.getContent();
				if (!content.equals(Expression.ONE) && !content.equals(Expression.ONE.negate())) {

					if (y.operator === Condition.NEZ) {
						var tmp = add(oldArray, {
							expression: y.expression.divide(content),
							operator: Condition.NEZ
						});
						if (tmp == null) {
							return null;
						}
						return add(tmp, {
							expression: content,
							operator: Condition.NEZ
						});
					}
					while (p != null) {
						if (y.operator === Condition.EQZ) {
							var sf = p.p.getSquareFreePolynomial();
							if (sf.getDegree() !== p.p.getDegree()) {

								return add(oldArray, {
									expression: y.expression.divide(p.p.divideAndRemainder(sf).quotient.calcAt(p.v)),
									operator: Condition.EQZ
								});
							}
						}
						content = p.p.getContent();
						p = Expression.getMultivariatePolynomial(content);
					}

					if (Expression.isConstant(content)) {
						if (!content.equals(Expression.ONE) && !content.equals(Expression.ONE.negate())) {
							return add(oldArray, {
								expression: y.expression.divide(content),
								operator: Condition.EQZ
							});
						}
					}

				}
				if (p != null && p.p.getDegree() > 1 && p.p.getCoefficient(0).equals(Expression.ZERO)) {
					if (y.operator === Condition.NEZ) {
						var tmp = add(oldArray, {
							expression: p.v,
							operator: Condition.NEZ
						});
						if (tmp == null) {
							return null;
						}
						return add(tmp, {
							expression: y.expression.divide(p.v),
							operator: Condition.NEZ
						});
					}
				}
			}

			var p = Expression.getMultivariatePolynomial(y.expression);
			if (p != null && p.p.getDegree() > 1) {
				var sf = p.p.getSquareFreePolynomial();
				if (sf.getDegree() !== p.p.getDegree()) {
					if (y.operator === Condition.EQZ || y.operator === Condition.NEZ) {
						return add(oldArray, {
							expression: sf.calcAt(p.v),
							operator: y.operator
						});
					}
				}
			}

			var addRest = function (newArray, oldArray, i, other) {
				if (newArray == null) {
					return null;
				}
				for (var j = i + 1; j < oldArray.length; j += 1) {
					newArray = add(newArray, oldArray[j]);
					if (newArray == null) {
						return null;
					}
				}
				if (other != null) {
					newArray = add(newArray, other);
				}
				return newArray;
			};

			var newArray = [];
			for (var i = 0; i < oldArray.length; i += 1) {
				var x = oldArray[i];

				if (Expression.has(x.expression, Expression.Sin) || Expression.has(x.expression, Expression.Cos)) {
					if (Expression.has(y.expression, Expression.Sin) || Expression.has(y.expression, Expression.Cos)) {
						var xx = {
							operator: x.operator,
							expression: Expression._replaceSinCos(x.expression)
						};
						var yy = {
							operator: y.operator,
							expression: Expression._replaceSinCos(y.expression)
						};
						var tmp1 = add([], xx);
						if (tmp1 == null) {
							return null;
						}
						var tmp = add(tmp1, yy);
						if (tmp == null) {
							return null;
						}
						if (tmp.length === 0) {
							return [];
						}
						if (tmp.length === 1) {
							return addRest(newArray, oldArray, i, {
								operator: tmp[0].operator,
								expression: Expression._replaceBySinCos(tmp[0].expression)
							});
						}

						for (var i = 0; i < tmp.length; i++) {
							if (!Expression.has(tmp[i], Expression.Exponentiation)) {
								if (tmp[i].expression.gcd(y.expression).equals(tmp[i].expression)) {
									newArray = add(newArray, x);
									return addRest(newArray, oldArray, i, {
										operator: tmp[i].operator,
										expression: Expression._replaceBySinCos(tmp[i].expression)
									});
								}
							}
						}

					}
				}

				if (Expression.has(x.expression, Expression.Function) || Expression.has(x.expression, Expression.Exponentiation)) {
					if (!(Expression.has(y.expression, Expression.Function) || Expression.has(y.expression, Expression.Exponentiation))) {
						return addRest(add(newArray, y), oldArray, i, x);
					}
				}

				if ((x.operator === Condition.NEZ && y.operator === Condition.EQZ || x.operator === Condition.EQZ && y.operator === Condition.NEZ) && (Expression.isSingleVariablePolynomial(x.expression.multiply(y.expression)) || true)) {
					var g = x.expression.polynomialGCD(y.expression);

					while (!g.equals(Expression.ONE) && !g.equals(Expression.ONE.negate())) {
						if (x.operator === Condition.EQZ) {
							x = {
								operator: x.operator,
								expression: x.expression.divide(g)
							};

						} else {
							y = {
								operator: y.operator,
								expression: y.expression.divide(g)
							};

						}
						newArray = add(newArray, x);
						if (newArray == null) {
							return null;
						}
						return addRest(newArray, oldArray, i, y);

					}

					if (x.operator === Condition.EQZ && Expression.isConstant(x.expression)) {
						return null;
					}
					if (y.operator === Condition.EQZ && Expression.isConstant(y.expression)) {
						return null;
					}

				}
				var newMethodEnabled = true;
				var singleVariablePolynomials = Expression.isSingleVariablePolynomial(x.expression) && Expression.isSingleVariablePolynomial(y.expression) && Expression.isSingleVariablePolynomial(x.expression.multiply(y.expression));
				if (x.operator === Condition.NEZ && y.operator === Condition.EQZ && singleVariablePolynomials) {
					y = y;
				} else if (x.operator === Condition.EQZ && y.operator === Condition.NEZ && singleVariablePolynomials) {
					y = x;
				} else if (x.operator === Condition.EQZ && y.operator === Condition.EQZ && singleVariablePolynomials) {
					var g = x.expression.polynomialGCD(y.expression);

					if (g instanceof Expression.Integer) {
						return null;
					}
					y = {
						operator: y.operator,
						expression: g
					};
					return addRest(newArray, oldArray, i, y);
				} else if (x.operator === Condition.NEZ && y.operator === Condition.NEZ && singleVariablePolynomials) {
					var g = x.expression.gcd(y.expression);
					x = {
						operator: x.operator,
						expression: x.expression.divide(g)
					};
					if (!Expression.isConstant(x.expression)) {
						newArray.push(x);
					}
				} else {

					var getConstant = function (e) {
						if (e instanceof Expression.Multiplication && e.a instanceof Expression.Matrix) {
							return e.a.multiply(getConstant(e.b));
						}
						var c = Expression.getConstant(e);
						for (var iteratorf = e.divide(c).factors()[globalThis.Symbol.iterator](), f = iteratorf.next().value; f != null; f = iteratorf.next().value) {
							if (f instanceof Expression.NthRoot && Expression.isConstant(f.a)) {
								c = c.multiply(f);
							}
						}
						return c;
					};
					var collapse = function (e, candidate) {
						var term0 = candidate.divide(getConstant(candidate));
						var result = Expression.ZERO;
						for (var iteratora = e.summands()[globalThis.Symbol.iterator](), a = iteratora.next().value; a != null; a = iteratora.next().value) {
							var term = a.divide(getConstant(a));
							if (term.equals(term0)) {
								result = result.add(a);
							}
						}
						return result;
					};
					var getPivotMonomial = function (e) {

						var getExponent = function (x) {
							return x instanceof Expression.Exponentiation ? x.b : Expression.ONE;
						};
						var getBase = function (x) {
							return x instanceof Expression.Exponentiation ? x.a : x;
						};
						var totalDegree = function (e) {
							var result = Expression.ZERO;
							for (var iteratorf = e.factors()[globalThis.Symbol.iterator](), f = iteratorf.next().value; f != null; f = iteratorf.next().value) {
								if (!Expression.isConstant(f)) {
									var e = getExponent(f);

									result = result.add(e);

								}
							}
							return result;
						};
						var compare = function (x, y) {

							var s = totalDegree(x).subtract(totalDegree(y));
							var c = s.isNegative() ? -1 : (s.negate().isNegative() ? +1 : 0);
							if (c !== 0) {
								return c;
							}

							var reversedFactors = function (e) {
								return Array.from(e.divide(Expression.getConstant(e)).factors()).reverse().filter(function (e) {
									return !Expression.isConstant(e);
								}).values();
							};
							var i = reversedFactors(x);
							var j = reversedFactors(y);
							var a = i.next().value;
							var b = j.next().value;
							while (a != null && b != null) {
								var c = (0 - getBase(a).compare4Multiplication(getBase(b))) || getExponent(a).compare4Multiplication(getExponent(b));
								if (c !== 0) {
									return c;
								}
								a = i.next().value;
								b = j.next().value;
							}
							return a != null ? +1 : (b != null ? -1 : 0);
						};
						var candidate = null;
						for (var iteratora = e.summands()[globalThis.Symbol.iterator](), a = iteratora.next().value; a != null; a = iteratora.next().value) {
							if (candidate == null || compare(a, candidate) > 0) {
								candidate = a;
							}
						}
						return candidate;
					};
					if (newMethodEnabled && x.operator === Condition.EQZ) {
						var pivot = getPivotMonomial(x.expression);
						var p = pivot.divide(getConstant(pivot))._abs();
						pivot = collapse(x.expression, pivot);
						var newYExpression = y.expression;
						var c1 = 0;
						for (var iteratora = y.expression.summands()[globalThis.Symbol.iterator](), a = iteratora.next().value; a != null; a = iteratora.next().value) {
							if (a.gcd(p)._abs().equals(p)) {
								newYExpression = newYExpression.subtract(a.divide(pivot).multiply(x.expression));
								c1 += 1;
							}
						}
						if (c1 > 0) {
							return addRest(add(newArray, x), oldArray, i, {
								expression: newYExpression,
								operator: y.operator
							});
						}
					}
					if (newMethodEnabled && y.operator === Condition.EQZ) {
						var pivot = getPivotMonomial(y.expression);
						var p = pivot.divide(getConstant(pivot))._abs();
						pivot = collapse(y.expression, pivot);
						for (var iteratora = x.expression.summands()[globalThis.Symbol.iterator](), a = iteratora.next().value; a != null; a = iteratora.next().value) {
							if (a.gcd(p)._abs().equals(p)) {
								var newXExpression = x.expression.subtract(a.divide(pivot).multiply(y.expression));

								if (x.operator === Condition.EQZ) {
									return addRest(add(newArray, {
										expression: newXExpression,
										operator: x.operator
									}), oldArray, i, y);
								}
								return addRest(add(newArray, y), oldArray, i, {
									expression: newXExpression,
									operator: x.operator
								});
							}
						}
					}
					if (newMethodEnabled && true) {

						if (x.operator === Condition.NEZ && y.operator === Condition.EQZ) {

							var pivot = getPivotMonomial(x.expression);
							var p = pivot.divide(Expression.getConstant(pivot));
							for (var iteratora = y.expression.summands()[globalThis.Symbol.iterator](), a = iteratora.next().value; a != null; a = iteratora.next().value) {
								if (a.gcd(p).equals(p) || a.gcd(p).equals(p.negate())) {
									var q = a.divide(pivot);
									if (q instanceof Expression.Integer && !q.equals(Expression.ZERO)) {

										var r = y.expression.subtract(q.multiply(x.expression));
										var rr = {
											expression: r,
											operator: Condition.NEZ
										};
										var flag = false;
										if (true) {

											var flag = false;
											for (var ii = 0; ii < oldArray.length; ii++) {
												var n = oldArray[ii];
												if (n.operator === Condition.EQZ) {
													var g = n.expression.gcd(rr.expression);
													if (!g.equals(Expression.ONE) && !g.equals(Expression.ONE.negate())) {
														flag = true;
													}
												}
											}
										}

										if (flag) {
											return addRest(add(add(newArray, x), rr), oldArray, i - 1, y);
										}
									}
								}
							}

						}
					}

					if (!newMethodEnabled || true) {

						var p = null;
						var pOperator = null;
						var pp = null;
						var other = null;
						var px = Expression.getMultivariatePolynomial(x.expression);
						var py = Expression.getMultivariatePolynomial(y.expression);

						if (y.operator === Condition.EQZ && py != null && py.p.getDegree() !== 1) {
							var tmp = Expression.getMultivariatePolynomial(py.p.getCoefficient(0));
							if (tmp != null) {
								var v = tmp.v;
								if (v instanceof Expression.Symbol && tmp.p.getDegree() === 1) {
									py = {
										p: Polynomial.toPolynomial(y.expression, v),
										v: v
									};
								}
							}
						}

						if (

							px != null && py != null) {

							if (y.operator === Condition.EQZ && py != null && py.p.getDegree() === 1 && x.operator === Condition.EQZ && px != null && px.p.getDegree() === 1) {

								if (Expression._getReplacement(y.expression, px.v).equals(px.v) && Polynomial.toPolynomial(y.expression, px.v).getDegree() === 0) {
									px = null;
								}
								if (Expression._getReplacement(x.expression, py.v).equals(py.v) && Polynomial.toPolynomial(x.expression, py.v).getDegree() === 0) {
									py = null;
								}

								if (px != null && py != null) {
									if (!(px.p.getCoefficient(1) instanceof Expression.Integer)) {
										px = null;
									}
									if (!(py.p.getCoefficient(1) instanceof Expression.Integer)) {
										py = null;
									}
								}

								if (px != null && py != null) {

									if (px.v.compare4Addition(py.v) < 0) {
										px = null;
									}

								}
							}

							if (y.operator === Condition.EQZ && py != null && py.p.getDegree() === 1) {
								pp = py;
								p = x.expression;
								pOperator = x.operator;
								other = y;
							}
							if (x.operator === Condition.EQZ && px != null && px.p.getDegree() === 1) {
								pp = px;
								p = y.expression;
								pOperator = y.operator;
								other = x;
							}
						}
						if (pp != null) {
							var ok = false;

							ok = ok || pp.p.getDegree() === 1 && Expression.isConstant(pp.p.getCoefficient(1)) && Expression.isConstant(pp.p.getCoefficient(0));

							ok = ok || pp.p.getDegree() === 1 && Expression.isConstant(pp.p.getCoefficient(0)) && !pp.p.getCoefficient(0).equals(Expression.ZERO) && Expression.has(p, Expression.Exponentiation);

							if (ok) {
								var alpha = pp.p.getCoefficient(0).negate().divide(pp.p.getCoefficient(1));

								var a = Expression._substitute(p, pp.v, alpha, {uniqueObject: 1});
								if (!a.equals(p)) {
									var tmp = {
										operator: pOperator,
										expression: a
									};
									newArray = add(newArray, tmp);
									if (newArray == null) {
										return null;
									}
									if (true) {
										return addRest(newArray, oldArray, i, other);
									} else {
										y = other;
									}
								} else {
									newArray.push(x);
								}
							} else {
								newArray.push(x);
							}
						} else {
							newArray.push(x);
						}
					} else {
						newArray.push(x);
					}
				}
			}
			newArray.push(y);

			if (newMethodEnabled && true) {
				var base = new Condition(newArray);
				for (var i = 0; i < newArray.length; i += 1) {
					var y = newArray[i];
					if (y.operator === Condition.EQZ) {
						var f = y.expression;

						var g = null;
						for (var iterators = f.summands()[globalThis.Symbol.iterator](), s = iterators.next().value; s != null; s = iterators.next().value) {
							var a = s.divide(Expression.getConstant(s));
							if (g == null) {
								g = a;
							} else {
								g = g.gcd(a);
							}
						}
						if (!g.equals(Expression.ONE) && f instanceof Expression.Addition) {

							if (new Condition(newArray.slice(0, i).concat(newArray.slice(i + 1))).andZero(g).isFalse()) {
								return add(newArray, {
									expression: g,
									operator: Condition.NEZ
								});
							}
						}

					}
				}
			}

			return newArray;
		};

		if (e instanceof Expression.Division) {
			return this._and(operator, e.getNumerator()).andNotZero(e.getDenominator());
		}

		var c = this;
		if (true && operator === Condition.EQZ) {
			var getVariable1 = function (e) {
				var candidate = undefined;
				for (var iterators = e.summands()[globalThis.Symbol.iterator](), s = iterators.next().value; s != null; s = iterators.next().value) {
					for (var iteratorf = s.factors()[globalThis.Symbol.iterator](), f = iteratorf.next().value; f != null; f = iteratorf.next().value) {
						var b = f instanceof Expression.Exponentiation ? f.a : f;
						if (b instanceof Expression.Symbol) {
							if (candidate == undefined || b.symbol < candidate.symbol) {
								candidate = b;
							}
						}
					}
				}
				return candidate;
			};
			var v = getVariable1(e);
			if (v != undefined && Polynomial.of(e)._hasIntegerLikeCoefficients()) {
				var ep = Polynomial.toPolynomial(e, v);
				for (var iteratorx = this.array[globalThis.Symbol.iterator](), x = iteratorx.next().value; x != null; x = iteratorx.next().value) {
					if (x.operator === Condition.EQZ) {
						if (Polynomial.of(x.expression)._hasIntegerLikeCoefficients() && getVariable1(x.expression).symbol >= v.symbol) {
							var xp = Polynomial.toPolynomial(x.expression, v);
							if (xp.getDegree() >= 1) {
								var g = Polynomial.polynomialGCD(ep, xp);
								if (g.getDegree() === 0) {
									var res = Polynomial.resultant(ep, xp);
									c = c.andZero(res);
									if (c.isFalse()) {
										return c;
									}
								}
							}
						}
					}
				}
			}
		}

		var newArray = add(c.array, {
			operator: operator,
			expression: e
		});
		if (newArray == null) {
			return Condition.FALSE;
		}
		if (newArray.length === 0) {
			return Condition.TRUE;
		}

		return new Condition(newArray);
	};

	Condition.prototype.andNotZero = function (e) {
		return this._and(Condition.NEZ, e);
	};
	Condition.prototype.andZero = function (e) {
		return this._and(Condition.EQZ, e);
	};
	Condition.prototype.andGreaterZero = function (e) {
		return this._and(Condition.GTZ, e);
	};
	Condition.prototype.and = function (b) {
		if (!(b instanceof Condition)) {
			throw new TypeError();
		}
		var c = this;
		for (var i = 0; i < b.array.length; i += 1) {
			c = c._and(b.array[i].operator, b.array[i].expression);
		}
		return c;
	};
	Condition.prototype.isFalse = function () {
		return this === Condition.FALSE;
	};
	Condition.prototype.isTrue = function () {
		return this === Condition.TRUE;
	};
	Condition.prototype.toString = function (options) {
		if (this === Condition.TRUE || this === Condition.FALSE) {

			throw new TypeError();
		}
		if (this.array.length === 0) {

			throw new TypeError();
		}
		var s = '';
		for (var i = 0; i < this.array.length; i += 1) {
			s += (i !== 0 ? ', ' : '') + this.array[i].expression.toString(options) + this.array[i].operator;
		}
		return s;
	};

	Condition.TRUE = new Condition(new Array(0));
	Condition.FALSE = new Condition(undefined);

	Condition.prototype.getSolutionFor = function (variable) {
		var condition = this;
		if (condition.array == null) {
			return null;
		}
		for (var i = 0; i < condition.array.length; i += 1) {
			var c = condition.array[i];
			if (c.operator === Condition.EQZ) {
				var p = Polynomial.toPolynomial(c.expression, variable);
				if (p.getDegree() === 1) {
					return p.getroots()[0];
				}
			}
		}
		return null;
	};

	Condition.prototype.updateExpression = function (e, options) {
		return this.andNotZero(e).isFalse() ? Expression.ZERO : e;

	};

	self.Condition = Condition;
}

function MathMLRendering() {
	Polynomial.prototype.toString = function (options) {
		options = options || {};
		return this.toExpression(options.polynomialVariable || new Expression.Symbol("x")).toString(options);
	};

	Polynomial.prototype.toMathML = function (options) {
		options = options || {};
		return this.toExpression(options.polynomialVariable || new Expression.Symbol("x")).toMathML(options);
	};

	Expression.Polynomial.prototype.toString = function (options) {
		return this.polynomial.toString(options);
	};

	Expression.Polynomial.prototype.toMathML = function (options) {
		return this.polynomial.toMathML(options);
	};

	var printPartOfAddition = function (isLast, isFirst, coefficient, variable, options) {
		if (coefficient.equals(Expression.ZERO)) {
			return isLast && isFirst ? Expression.ZERO.toMathML() : "";
		}
		var isNegative = false;
		if (coefficient.isNegative() && !isFirst) {
			isNegative = true;
			coefficient = coefficient.negateCarefully();
		}

		var precedenceOfMultiptication = new Expression.Multiplication(Expression.ZERO, Expression.ZERO).getPrecedence();
		var areBracketsRequired = coefficient.getPrecedence() < precedenceOfMultiptication;
		var c = coefficient.equals(Expression.ONE);

		return (isFirst ? '' : '') + (!isFirst && isNegative ? '<mo form="infix">&minus;</mo>' : '') + (!isFirst && !isNegative ? '<mo form="infix">+</mo>' : '') + (c ? '' : '<mrow>') + (c || !areBracketsRequired ? '' : '<mrow><mo>(</mo>') + (c ? '' : coefficient.toMathML(options)) + (c || !areBracketsRequired ? '' : '<mo>)</mo></mrow>') + (c ? '' : '<mo>&sdot;</mo>') + variable.toMathML(options) + (c ? '' : '</mrow>');
	};

	var decimalToMathML = function (decimal) {
		var match = /^([+\-])?(\d+\.?\d*(?:\(\d+\)\d*)?)(?:[eE]\+?(\-?\d+))?$/.exec(decimal);
		var sign = match[1] || '';
		var significand = match[2] || '';
		var exponent = match[3] || '';
		return (exponent !== "" ? "<mrow>" : "") + (sign !== "" ? "<mrow>" : "") + (sign === "+" ? "<mo>+</mo>" : "") + (sign === "-" ? "<mo>&minus;</mo>" : "") + "<mn>" + numberFormat.format(significand.replace(/[\(\)]/g, '')).replace(/^[\s\S]+$/g, function (p) {
			var a = significand.indexOf('(');
			var b = significand.lastIndexOf(')');
			if (a === -1 || b === -1) {
				return p;
			}
			var digitLength = numberFormat.format('0').trim().length;
			var i = p.length - (significand.length - a - '('.length - ')'.length) * digitLength;
			var j = p.length - (significand.length - b - ')'.length) * digitLength;
			return p.slice(0, i) + '<span style="text-decoration:overline;">' + p.slice(i, j) + '</span>' + p.slice(j);
		}) + "</mn>" + (sign !== "" ? "</mrow>" : "") + (exponent !== "" ? "<mo lspace=\"0\" rspace=\"0\">&sdot;</mo>" + "<msup>" + "<mn>" + numberFormat.format('10') + "</mn>" + decimalToMathML(exponent) + "</msup>" : "") + (exponent !== "" ? "</mrow>" : "");
	};

	var complexToMathML = function (real, imaginary) {
		if (imaginary.replace(/<[^>]+>/g, '') === '1') {
			return '<mrow>' + real + '<mo>+</mo><mi>&ii;</mi></mrow>';
		}
		if (imaginary.replace(/<[^>]+>/g, '').replace(/&minus;/g, '-') === '-1') {
			return '<mrow>' + real + '<mo>&minus;</mo><mi>&ii;</mi></mrow>';
		}
		if (real === '') {
			return '<mrow>' + imaginary + '<mo>' + (/<msup>/.test(imaginary) || /[^0-9]/.test(imaginary) ? '&sdot;' : '&it;') + '</mo><mi>&ii;</mi></mrow>';
		}
		var signBetween = '+';
		if (/<mrow><mo>&minus;<\/mo><mn>([^<]*)<\/mn><\/mrow>(?!<\/msup>)/.test(imaginary)) {
			signBetween = '-';
			imaginary = imaginary.replace(/<mrow><mo>&minus;<\/mo><mn>([^<]*)<\/mn><\/mrow>(?!<\/msup>)/g, '<mn>$1</mn>');
		}
		return '<mrow>' + real + '<mo>' + (signBetween === '-' ? '&minus;' : '+') + '</mo>' + '<mrow>' + imaginary + '<mo>' + (/<msup>/.test(imaginary) || /[^0-9]/.test(imaginary) ? '&sdot;' : '&it;') + '</mo>' + '<mi>&ii;</mi>' + '</mrow>' + '</mrow>';
	};

	Expression._decimalToMathML = decimalToMathML;

	Expression._complexToMathML = complexToMathML;

	function isConstant(e) {
		if (e instanceof Expression.NonSimplifiedExpression) {
			return false;
		}
		if (e instanceof Expression.Matrix) {
			return false;
		}
		if (e instanceof Expression.Polynomial) {
			return false;
		}
		return Expression.isConstant(e);
	}

	var groupByTerm = function (e) {
		if (e instanceof Expression.Division || e instanceof Expression.Addition) {
			var numerator = e.getNumerator();
			var denominator = e.getDenominator();

			var denominatorContent = denominator instanceof Expression.Integer ? denominator : (Expression.getMultivariatePolynomial(denominator) || {
				p: {
					getContent: function () {
						return Expression.ONE;
					}
				}
			}).p.getContent();
			var denominatorRest = denominator.divide(denominatorContent);
			if (isConstant(denominatorContent)) {

				var summands = [];
				for (var iteratorsummand = numerator.summands()[globalThis.Symbol.iterator](), summand = iteratorsummand.next().value; summand != null; summand = iteratorsummand.next().value) {
					summands.push(summand);
				}
				var map = {};
				summands.reverse();
				for (var i = 0; i < summands.length; i += 1) {
					var summand = summands[i];

					var constant = Expression.ONE;
					for (var iteratorfactor = summand.factors()[globalThis.Symbol.iterator](), factor = iteratorfactor.next().value; factor != null; factor = iteratorfactor.next().value) {
						if (isConstant(factor)) {
							constant = constant.multiply(factor);
						}
					}
					var term = summand.divide(constant);
					var key = "_" + term.toString();
					map[key] = map[key] || {
						constant: Expression.ZERO,
						term: term
					};
					map[key].constant = map[key].constant.add(constant.divide(denominatorContent));
				}
				var result = null;
				for (var key in map) {
					if (Object.prototype.hasOwnProperty.call(map, key)) {
						var constant = map[key].constant;
						var term = map[key].term;
						var s = false;
						if (result != null && constant.isNegative()) {
							constant = constant.negate();
							s = true;
						}
						var x = new NonSimplifiedExpression(term.equals(Expression.ONE) ? constant : constant.equals(Expression.ONE) ? map[key].term : new Expression.Multiplication(constant, map[key].term));
						result = result == null ? x : new Expression.Addition(result, s ? new Expression.Multiplication(Expression.ONE.negate(), x) : x);
					}
				}
				if (!denominatorRest.equals(Expression.ONE)) {
					result = new Expression.Division(result, denominatorRest);
				}
				return new NonSimplifiedExpression(result);
			}
		}
		return undefined;
	};

	var getRounding = function (options) {
		var rounding = options != undefined ? options.rounding : undefined;
		if (options != undefined && rounding == undefined && options.fractionDigits != undefined && options.fractionDigits !== -1) {
			console.debug('deprecated fractionDigits, use rounding instead');
			rounding = {
				fractionDigits: options.fractionDigits
			};
		}
		return rounding;
	};

	Expression.toDecimalString = function (x, options) {
		var rounding = getRounding(options);
		if (rounding != null) {
			if (isConstant(x)) {
				return toDecimalStringInternal(x, rounding, decimalToMathML, complexToMathML);
			} else if (!Expression.has(x, NonSimplifiedExpression)) {
				var grouped = groupByTerm(x);
				if (grouped != undefined) {
					return grouped.toMathML(options);
				}
			}
		}
		return undefined;
	};

	var getPrecedence = function (x, options) {
		var rounding = getRounding(options);
		if (rounding != null && isConstant(x.unwrap()) && Expression.has(x.unwrap(), Expression.Complex)) {
			if (!x.unwrap().equals(Expression.I)) {
				return new Expression.Addition(Expression.ONE, Expression.ONE).getPrecedence();
			}
		}
		return x.getPrecedence();
	};

	Expression.idCounter = 0;

	Expression.id = function () {
		return (Expression.idCounter += 1).toString();
	};

	Expression.escapeHTML = function (s) {
		return s.replace(/&/g, "&amp;").replace(/"/g, "&quot;").replace(/</g, "&lt;").replace(/>/g, "&gt;");
	};

	Expression.defaultOptions = {
		useMatrixContainer: false
	};

	Expression.Matrix.prototype.toMathML = function (options) {
		var x = this.matrix;
		options = Expression.setTopLevel(true, options);
		var useMatrixContainer = options.useMatrixContainer == undefined && Expression.defaultOptions.useMatrixContainer ? true : options.useMatrixContainer;

		var braces = options.useBraces == undefined ? undefined : options.useBraces;
		var columnlines = options.columnlines == undefined ? 0 : options.columnlines;
		var variableNames = options.variableNames == undefined ? undefined : options.variableNames;
		var verticalStrike = options.verticalStrike == undefined ? -1 : options.verticalStrike;
		var horizontalStrike = options.horizontalStrike == undefined ? -1 : options.horizontalStrike;
		var cellIdGenerator = options.cellIdGenerator == undefined ? undefined : options.cellIdGenerator;
		var pivotCell = options.pivotCell == undefined ? undefined : options.pivotCell;
		var isLUDecomposition2 = options.isLUDecomposition2 == undefined ? undefined : options.isLUDecomposition2;
		var highlightRow = options.highlightRow == undefined ? -1 : options.highlightRow;
		var highlightCol = options.highlightCol == undefined ? -1 : options.highlightCol;
		options = Object.assign({}, options, {
			useBraces: undefined,
			columnlines: undefined,
			variableNames: undefined,
			verticalStrike: undefined,
			horizontalStrike: undefined,
			cellIdGenerator: undefined,
			pivotCell: undefined,
			isLUDecomposition2: undefined,
			highlightRow: undefined,
			highlightCol: undefined
		});
		var result = "";
		var rows = x.rows();
		var cols = x.cols();
		var i = -1;

		var containerId = options.idPrefix + "-" + Expression.id();
		if (useMatrixContainer) {
			result += "<munder accentunder=\"true\">";
			result += '<mrow id="' + containerId + '" data-matrix="' + Expression.escapeHTML(x.toString()) + '" draggable="true" tabindex="0">';
		}
		result += braces == undefined ? '<mrow><mo>(</mo>' : '<mrow>' + (braces[0] === ' ' ? '' : '<mo>' + braces[0] + '</mo>');

		result += '<mtable' + (variableNames != undefined ? ' columnalign="right"' : '') + '>';
		while (++i < rows) {
			var j = -1;
			if (variableNames != undefined) {

				var row = "";
				var wasNotZero = false;
				while (++j < cols - 1) {

					row += "<mtd>";
					row += printPartOfAddition(j === cols - 2, !wasNotZero, x.e(i, j), new Expression.Symbol(variableNames[j]), options);
					row += "</mtd>";
					wasNotZero = wasNotZero || !x.e(i, j).equals(Expression.ZERO);
				}
				row += "<mtd><mo>=</mo></mtd><mtd>" + x.e(i, cols - 1).toMathML(options) + "</mtd>";
				if (wasNotZero || !x.e(i, cols - 1).equals(Expression.ZERO)) {
					result += "<mtr>";
					result += row;
					result += "</mtr>";
				}
			} else {
				result += "<mtr>";
				while (++j < cols) {
					var inert = '';
					var style = '';
					if (columnlines !== 0 && cols - 1 > 0) {
						style += cols + columnlines === j ? "border-left: 1px solid;" : "";
					}
					if (pivotCell != undefined && i === pivotCell.i && j === pivotCell.j) {
						style += 'border: 1px solid; border-radius: 50%;';
						style += 'font-weight: bolder;';
					}
					if (horizontalStrike === i && verticalStrike === j) {
						style += 'background: linear-gradient(currentColor, currentColor) no-repeat 50% 0 / 2px auto, linear-gradient(currentColor, currentColor) no-repeat 0 50% / auto 2px; opacity: 0.5;';
						inert = 'inert';
					} else {
						if (verticalStrike === j) {
							style += 'background: linear-gradient(currentColor, currentColor) no-repeat 50% 0 / 2px auto; opacity: 0.5;';
							inert = 'inert';
						}
						if (horizontalStrike === i) {
							style += 'background: linear-gradient(currentColor, currentColor) no-repeat 0 50% / auto 2px; opacity: 0.5;';
							inert = 'inert';
						}
					}
					var id = cellIdGenerator != undefined ? cellIdGenerator(i, j) : '';
					result += ('<mtd id="' + id + '" inert="' + inert + '" style="' + style + '">').replace(/\s+[a-z\-]+\=""/g, '');

					var highlight = j < i && isLUDecomposition2 || highlightRow === i && (columnlines === 0 || j <= cols - 1 + columnlines) || highlightCol === j;
					if (highlight) {
						result += '<mrow style="background: #80FF80; color: #3C78C2">';
					}

					result += x.e(i, j).toMathML(options);
					if (highlight) {
						result += "</mrow>";
					}
					result += "</mtd>";
				}
				result += "</mtr>";
			}
		}
		result += "</mtable>";
		result += braces == undefined ? '<mo>)</mo></mrow>' : (braces[1] === ' ' ? '' : '<mo>' + braces[1] + '</mo>') + '</mrow>';
		if (useMatrixContainer) {
			result += '</mrow>';
			result += "<mtext>";

			result += "</mtext>";
			result += "</munder>";
		}
		return result;
	};

	Expression.Determinant.prototype.toMathML = function (options) {
		var x = this;
		if (x.a instanceof Expression.Matrix || x.a instanceof NonSimplifiedExpression && x.a.e instanceof Expression.Matrix) {
			options = Object.assign({}, options, {
				useBraces: ["|", "|"]
			});

			return x.a.toMathML(options);
		}

		return Expression.Function.prototype.toMathML.call(this, options);
	};

	Expression.Transpose.prototype.toMathML = function (options) {
		var x = this;

		var f = this.getPrecedence() >= x.a.getPrecedence();
		return "<msup>" + (f ? "<mrow><mo>(</mo>" : "") + x.a.toMathML(options) + (f ? "<mo>)</mo></mrow>" : "") + "<mi>T</mi>" + "</msup>";
	};

	Expression.ComplexConjugate.prototype.toMathML = function (options) {
		var x = this;

		return "<mover accent=\"true\">" + x.a.toMathML(options) + "<mo>¯</mo>" + "</mover>";
	};

	Expression.Pseudoinverse.prototype.toMathML = function (options) {
		var x = this;
		var f = this.getPrecedence() >= x.a.getPrecedence();
		return "<msup>" + (f ? "<mrow><mo>(</mo>" : "") + x.a.toMathML(options) + (f ? "<mo>)</mo></mrow>" : "") + "<mi><span title=\"pseudoinverse\">+</span></mi>" + "</msup>";
	};

	Expression.SquareRoot.prototype.toMathML = function (options) {
		var d = Expression.toDecimalString(this, options);
		if (d != undefined) {
			return d;
		}
		return "<msqrt>" + this.a.toMathML(Expression.setTopLevel(true, options)) + "</msqrt>";
	};

	Expression.NthRoot.prototype.toMathML = function (options) {
		var d = Expression.toDecimalString(this, options);
		if (d != undefined) {
			return d;
		}
		console.assert(typeof this.n === "number" && Math.floor(this.n) === this.n && this.n >= 3);
		return "<mroot>" + this.a.toMathML(Expression.setTopLevel(true, options)) + "<mn>" + numberFormat.format(this.n.toString()) + "</mn>" + "</mroot>";
	};

	Expression.Function.prototype.toMathML = function (options) {
		var d = Expression.toDecimalString(this, options);
		if (d != undefined) {
			return d;
		}
		var x = this;
		var fa = !(x.a instanceof Expression.Matrix) && !(x.a instanceof NonSimplifiedExpression && x.a.e instanceof Expression.Matrix);

		return "<mrow>" + "<mi>" + x.name + "</mi>" + "<mo>&af;</mo>" + (fa ? "<mrow><mo>(</mo>" : "") + x.a.toMathML(Expression.setTopLevel(true, options)) + (fa ? "<mo>)</mo></mrow>" : "") + "</mrow>";
	};

	Expression.Division.prototype.toMathML = function (options) {
		if (options != null && options.nofractions) {
			return Expression.BinaryOperation.prototype.toMathML.call(this, options);
		}
		var d = Expression.toDecimalString(this, options);
		if (d != undefined) {
			return d;
		}
		var x = this;
		var denominator = x.getDenominator();
		var numerator = x.getNumerator();

		return "<mfrac>" + numerator.toMathML(Expression.setTopLevel(true, options)) + denominator.toMathML(Expression.setTopLevel(true, options)) + "</mfrac>";
	};

	Expression.numberFormat = {
		format: function (number) {
			return number.toString();
		}
	};

	var decimalNumberRegExp = new RegExp('\\p{Decimal_Number}', 'u');

	var replaceSimpleDigit = function (codePoint) {
		var i = 0;
		while (decimalNumberRegExp.test(String.fromCodePoint(codePoint - i))) {
			i += 1;
		}
		return i === 0 ? -1 : (i - 1) % 10;
	};

	var cachedFormatData = {
		format: null,
		decimalSeparator: '.',
		decimalZeroOffset: 0
	};

	var numberFormat = {

		format: function (string) {
			var getDecimalSeparator = function () {
				var s = Expression.numberFormat.format(1.5).trim();
				var tmp = /[٫,\.]/.exec(s);
				if (tmp == null) {
					console.error(s);
					return '.';
				}
				return tmp[0];
			};
			var getDecimalZeroOffset = function () {
				var codePoint = Expression.numberFormat.format(0).trim().codePointAt(0);
				var isDecimalZero = replaceSimpleDigit(codePoint) === 0;
				if (!isDecimalZero) {
					console.error(codePoint);
					return 0;
				}
				return codePoint - "0".charCodeAt(0);
			};
			if (cachedFormatData.format !== Expression.numberFormat) {
				cachedFormatData = {
					format: Expression.numberFormat,
					decimalSeparator: getDecimalSeparator(),
					decimalZeroOffset: getDecimalZeroOffset()
				};
			}

			var decimalSeparator = string.indexOf('.');
			if (decimalSeparator !== -1) {
				return numberFormat.format(string.slice(0, decimalSeparator)) + cachedFormatData.decimalSeparator + numberFormat.format(string.slice(decimalSeparator + '.'.length));
			}
			var decimalZeroOffset = cachedFormatData.decimalZeroOffset;
			if (decimalZeroOffset === 0) {
				return string;
			}
			var result = "";
			for (var i = 0; i < string.length; i += 1) {
				result += String.fromCodePoint(decimalZeroOffset + string.charCodeAt(i));
			}
			return result;
		}
	};

	Expression.Integer.prototype.toMathML = function (options) {

		var x = this;
		var sign = x.compareTo(Expression.ZERO) < 0 ? '-' : '';
		var abs = x.compareTo(Expression.ZERO) < 0 ? x.negate() : x;
		var s = abs.value.toString();
		var tmp = numberFormat.format(s);
		return sign === "-" ? "<mrow>" + "<mo>&minus;</mo>" + "<mn>" + tmp + "</mn>" + "</mrow>" : "<mn>" + tmp + "</mn>";
	};

	Expression.BinaryOperation.prototype.toMathML = function (options) {
		options = options == null ? {} : options;
		if (options != null && options.rounding != null && this.unwrap() instanceof Expression.Exponentiation && this.unwrap().a.unwrap() instanceof Expression.Symbol && this.unwrap().a.unwrap() !== Expression.E && this.unwrap().a.unwrap() !== Expression.PI && !(this.unwrap().a.unwrap() instanceof Expression.PolynomialRootSymbol) && !(this.unwrap().a.unwrap() instanceof Expression.ExpressionPolynomialRoot) && (this.unwrap().b.unwrap() instanceof Expression.Integer || this.unwrap().b.unwrap() instanceof Expression.Negation && this.unwrap().b.unwrap().b.unwrap() instanceof Expression.Integer)) {
			options = Object.assign({}, options, {
				rounding: null
			});
		}
		var d = Expression.toDecimalString(this, options);
		if (d != undefined) {
			return d;
		}

		if (this instanceof Expression.Addition && options.printId == undefined) {
			var summands = function (e) {

				var result = [];
				while (e.unwrap() instanceof Expression.Addition) {
					result.push(e.unwrap().b);
					e = e.unwrap().a;
				}
				result.push(e);
				return result;
			};
			var s = [];
			var b = null;
			for (var iteratorx = summands(this)[globalThis.Symbol.iterator](), x = iteratorx.next().value; x != null; x = iteratorx.next().value) {
				if (b != null) {
					var n = false;
					if (b.isNegative()) {
						n = true;
						b = b.negateCarefully();
					}
					var fence = this.getPrecedence() >= getPrecedence(b, options);
					fence = fence || b.isUnaryPlusMinus();
					s.push((fence ? '<mrow><mo>(</mo>' : '') + b.toMathML(Expression.setTopLevel(fence, options)) + (fence ? '<mo>)</mo></mrow>' : ''));
					s.push(n ? '<mo>&minus;</mo>' : '<mo>+</mo>');
				}
				b = x;
			}
			s = s.reverse().join('');
			var a = b;
			var fence = a.getPrecedence() + (a.isRightToLeftAssociative() ? -1 : 0) < this.getPrecedence();
			if (options != undefined && options.isTopLevel != undefined && options.isTopLevel === false) {
				fence = fence || a.isUnaryPlusMinus();
			}
			s = (fence ? "<mrow><mo>(</mo>" : "") + a.toMathML(Expression.setTopLevel(fence || options == undefined || options.isTopLevel, options)) + (fence ? "<mo>)</mo></mrow>" : "") + s;
			return '<mrow>' + s + '</mrow>';
		}

		var a = this.a;
		var b = this.b;
		var isSubtraction = false;

		if (this instanceof Expression.Addition && b.isNegative()) {
			isSubtraction = true;
			b = b.negateCarefully();
		}

		var fa = a.getPrecedence() + (a.isRightToLeftAssociative() ? -1 : 0) < this.getPrecedence();
		var fb = this.getPrecedence() + (this.isRightToLeftAssociative() ? -1 : 0) >= b.getPrecedence();
		if (options != undefined && options.isTopLevel != undefined && options.isTopLevel === false) {
			fa = fa || a.isUnaryPlusMinus();
		}
		fb = fb || b.isUnaryPlusMinus();
		fb = fb || this.unwrap() instanceof Expression.Exponentiation && b.unwrap() instanceof Expression.Exponentiation;
		fa = fa || this.unwrap() instanceof Expression.Exponentiation && a.unwrap() instanceof Expression.Function;
		fa = fa || options.rounding != null && isConstant(a.unwrap()) && Expression.has(a.unwrap(), Expression.Complex);
		var s = isSubtraction ? "-" : this.getS();
		if (this instanceof Expression.Exponentiation) {
			if (a.unwrap() === Expression.E && b.unwrap() instanceof Expression.Matrix) {
				return '<mrow><mi>exp</mi><mo>&af;</mo>' + b.toMathML(options) + '</mrow>';
			}
			var boptions = options;
			if (!(a.unwrap() instanceof Expression.Matrix)) {
				boptions = Object.assign({}, options || {}, {
					nofractions: true
				});
			}
			return "<msup>" + (fa ? "<mrow><mo>(</mo>" : "") + a.toMathML(Expression.setTopLevel(fa || options == undefined || options.isTopLevel, options)) + (fa ? "<mo>)</mo></mrow>" : "") + (fb ? "<mrow><mo>(</mo>" : "") + b.toMathML(Expression.setTopLevel(fb, boptions)) + (fb ? "<mo>)</mo></mrow>" : "") + "</msup>";
		}
		if (this.isNegation()) {

			return "<mrow><mo>&minus;</mo>" + (fb ? "<mrow><mo>(</mo>" : "") + b.toMathML(Expression.setTopLevel(fb, options)) + (fb ? "<mo>)</mo></mrow>" : "") + "</mrow>";
		}

		var isScalarOrMatrixSymbol = function (e) {
			return Expression.isScalar(e.unwrap()) || e.unwrap() instanceof Expression.MatrixSymbol;
		};
		var base = function (e) {
			return e instanceof Expression.Exponentiation && (e.b.unwrap() instanceof Expression.Integer || e.b.unwrap() instanceof Expression.Symbol && e.b.unwrap().symbol === "T") ? e.a.unwrap() : e;
		};
		var canUseInvisibleTimes = function (e) {
			return !fa && !fb && (e.a.unwrap() instanceof Expression.Integer || base(e.a.unwrap()) instanceof Expression.Symbol || e.a.unwrap() instanceof Expression.Multiplication && base(e.a.unwrap().b.unwrap()) instanceof Expression.Symbol) && (base(e.b.unwrap()) instanceof Expression.Symbol || options.rounding == null && e.b.unwrap() instanceof Expression.SquareRoot);

		};

		if (this instanceof Expression.Multiplication && options.printId == undefined) {
			var f = true;
			for (var x = this; x != null; x = x instanceof Expression.Multiplication ? x.a.unwrap() : null) {
				var factor = x instanceof Expression.Multiplication ? x.b.unwrap() : x;
				if (!(base(factor).unwrap() instanceof Expression.Symbol && Expression.isScalar(factor))) {
					f = false;
				}
				if (factor instanceof Expression.ExpressionWithPolynomialRoot) {
					f = false;
				}

				if (factor instanceof Expression.ExpressionPolynomialRoot) {
					f = false;
				}
			}
			if (f) {
				var s = [];
				for (var x = this; x != null; x = x instanceof Expression.Multiplication ? x.a.unwrap() : null) {
					var factor = x instanceof Expression.Multiplication ? x.b.unwrap() : x;

					s.push(factor.toMathML(Expression.setTopLevel(fence, options)));
				}
				s = s.reverse().join('<mo>&it;</mo>');
				return '<mrow>' + s + '</mrow>';
			}
		}
		return "<mrow>" + (fa ? "<mrow><mo>(</mo>" : "") + a.toMathML(Expression.setTopLevel(fa || options == undefined || options.isTopLevel, options)) + (fa ? "<mo>)</mo></mrow>" : "") + (s === '*' ? canUseInvisibleTimes(this) ? '<mo>&it;</mo>' : '<mo>&sdot;</mo>' : s === '-' ? '<mo>&minus;</mo>' : s === '/' ? '<mo>&#x2215;</mo>' : this instanceof Expression.Comma ? '<mo lspace="0em" rspace="0.55em">' + ',' + '</mo>' : '<mo>' + s + '</mo>') + (fb ? "<mrow><mo>(</mo>" : "") + b.toMathML(Expression.setTopLevel(fb, options)) + (fb ? "<mo>)</mo></mrow>" : "") + "</mrow>";
	};

	Expression.Symbol.prototype.toMathML = function (options) {
		var x = this;
		var s = x.symbol;
		var i = s.indexOf("_");
		if (i !== -1) {
			var indexes = s.slice(i + 1).replace(/^\(|\)$/g, "").split(",");
			var indexesMathML = "";
			for (var j = 0; j < indexes.length; j += 1) {
				indexesMathML += j !== 0 ? "<mo>,</mo>" : "";
				indexesMathML += /^\d+$/.exec(indexes[j]) != undefined ? Expression.Integer.fromString(indexes[j]).toMathML() : "<mi>" + indexes[j] + "</mi>";
			}
			if (indexes.length > 1) {
				indexesMathML = "<mrow>" + indexesMathML + "</mrow>";
			}
			var isVector = this instanceof Expression.MatrixSymbol && /^[a-z]$/.test(s.slice(0, i));
			return "<msub>" + "<mi" + (isVector ? " mathvariant=\"bold-italic\"" : "") + ">" + s.slice(0, i) + "</mi>" + indexesMathML + "</msub>";
		}
		var isVector = this instanceof Expression.MatrixSymbol && /^[a-z]$/.test(s);
		return "<mi" + (isVector ? " mathvariant=\"bold-italic\"" : "") + ">" + (this instanceof Expression.IdentityMatrix && typeof i18n !== 'undefined' && i18n["misc"] != undefined ? '<span title="' + i18n['matrix.identity'] + '">' + s + '</span>' : s) + "</mi>";
	};

	Expression.Negation.prototype.toMathML = function (options) {
		var b = this.b;
		var fb = this.getPrecedence() + (this.isRightToLeftAssociative() ? -1 : 0) >= b.getPrecedence();
		fb = fb || b.isUnaryPlusMinus();

		return "<mrow><mo>&minus;</mo>" + (fb ? "<mrow><mo>(</mo>" : "") + b.toMathML(Expression.setTopLevel(fb, options)) + (fb ? "<mo>)</mo></mrow>" : "") + "</mrow>";
	};

	Expression.Factorial.prototype.toMathML = function (options) {
		var n = this.n.unwrap();
		var fn = !(n instanceof Expression.Integer && n.compareTo(Expression.ZERO) > 0);
		return "<mrow>" + (fn ? "<mrow><mo>(</mo>" : "") + n.toMathML(Expression.setTopLevel(fn, options)) + (fn ? "<mo>)</mo></mrow>" : "") + "<mo>!</mo></mrow>";
	};

	Condition.prototype.toMathML = function (options) {
		if (this === Condition.TRUE || this === Condition.FALSE) {

			throw new TypeError();
		}
		if (this.array.length === 0) {

			throw new TypeError();
		}
		var s = '';
		for (var i = 0; i < this.array.length; i += 1) {
			var c = this.array[i];
			s += i !== 0 ? '<mo lspace="0em" rspace="0.55em">,</mo>' : '';
			s += '<mrow>';
			var operator = '<mo>' + (c.operator === Condition.NEZ ? '&ne;' : c.operator === Condition.EQZ ? '=' : c.operator === Condition.GTZ ? '&gt;' : '???') + '</mo>';
			if (c.expression instanceof Expression.Addition && c.expression.a instanceof Expression.Symbol && c.expression.b instanceof Expression.Integer) {

				var left = c.expression.a;
				var right = c.expression.b.negate();
				s += left.toMathML(options) + operator + right.toMathML(options);
			} else {
				s += c.expression.toMathML(options) + operator + Expression.ZERO.toMathML();
			}
			s += '</mrow>';
		}
		return this.array.length === 1 ? s : '<mrow>' + s + '</mrow>';
	};

	Expression.Complex.prototype.toMathML = function (options) {
		return this.toStringInternal(options, "<mo>&it;</mo>", "<mi>&ii;</mi>", "<mo>&minus;</mo>", "<mo>+</mo>", "<mrow>", "</mrow>", function (x, options) {
			return x.toMathML(options);
		});
	};

	Expression.GF2.prototype.toMathML = function (options) {

		return this.a.toMathML(options);
	};

	Expression.GF2Value.prototype.toMathML = function (options) {
		return "<mrow>" + "<mn>" + this.value.toString() + "</mn>" + "</mrow>";
	};

	Expression.Degrees.prototype.toMathML = function (options) {
		return "<mrow>" + this.value.toMathML(options) + "<mo>&it;</mo><mi>&deg;</mi></mrow>";
	};

	Expression.Radians.prototype.toMathML = function (options) {
		return "<mrow>" + this.value.toMathML(options) + "<mo>&it;</mo><mi>rad</mi></mrow>";
	};

	NonSimplifiedExpression.prototype.toMathML = function (options) {

		if (options != null && options.printId != undefined) {
			return "<mrow id=\"" + this.getId() + "\">" + this.e.toMathML(options) + "</mrow>";
		}
		return this.e.toMathML(options);
	};

	Expression.prototype.toMathML = function (options) {
		throw new TypeError();
	};

	Expression.DecimalFraction.prototype.toMathML = function (options) {
		return decimalToMathML(this.toString());
	};
}

function QuadraticInteger() {
	function abs(a) {
		return JSBI.lessThan(a, JSBI.BigInt(0)) ? JSBI.subtract(JSBI.BigInt(0), a) : a;
	}

	function ngcd(a, b) {
		return JSBI.BigInt(bigIntGCD(JSBI.BigInt(a), JSBI.BigInt(b)));
	}

	function QuadraticInteger($a, $b, $D, overTwo) {
		overTwo = overTwo == undefined ? false : overTwo;
		var a = JSBI.BigInt($a);
		var b = JSBI.BigInt($b);
		var D = typeof $D === "number" ? $D : JSBI.toNumber(JSBI.BigInt($D));
		if (overTwo && D % 4 === 0) {
			throw new RangeError();
		}
		if (overTwo && JSBI.equal(JSBI.remainder(a, JSBI.BigInt(2)), JSBI.BigInt(0)) && JSBI.equal(JSBI.remainder(b, JSBI.BigInt(2)), JSBI.BigInt(0))) {
			overTwo = false;
			a = JSBI.divide(a, JSBI.BigInt(2));
			b = JSBI.divide(b, JSBI.BigInt(2));
		}
		if (overTwo && (JSBI.equal(JSBI.remainder(a, JSBI.BigInt(2)), JSBI.BigInt(0)) || JSBI.equal(JSBI.remainder(b, JSBI.BigInt(2)), JSBI.BigInt(0)))) {
			throw new RangeError();
		}
		this.a = a;
		this.b = b;
		this.D = D;
		this.overTwo = overTwo;
	}

	QuadraticInteger.prototype.multiply = function (y) {
		var x = this;
		if (+x.D !== +y.D) {
			throw new TypeError();
		}
		var a = JSBI.add(JSBI.multiply(JSBI.BigInt(x.a), y.a), JSBI.multiply(JSBI.multiply(JSBI.BigInt(x.b), y.b), JSBI.BigInt(y.D)));
		var b = JSBI.add(JSBI.multiply(JSBI.BigInt(x.a), y.b), JSBI.multiply(JSBI.BigInt(x.b), y.a));
		var d = (x.overTwo ? 1 : 0) + (y.overTwo ? 1 : 0);
		while (d > 0 && JSBI.equal(JSBI.remainder(a, JSBI.BigInt(2)), JSBI.BigInt(0)) && JSBI.equal(JSBI.remainder(b, JSBI.BigInt(2)), JSBI.BigInt(0))) {
			a = JSBI.divide(a, JSBI.BigInt(2));
			b = JSBI.divide(b, JSBI.BigInt(2));
			d -= 1;
		}
		return new QuadraticInteger(a, b, x.D, d === 1);
	};

	QuadraticInteger.prototype.conjugate = function (y) {
		return new QuadraticInteger(this.a, JSBI.unaryMinus(JSBI.BigInt(this.b)), this.D, this.overTwo);
	};

	QuadraticInteger.prototype.norm = function () {
		var a = JSBI.BigInt(this.a);
		var b = JSBI.BigInt(this.b);
		var D = +this.D;
		var aa = JSBI.multiply(a, a);
		var bb = JSBI.multiply(b, b);
		var norm = JSBI.subtract(aa, JSBI.multiply(bb, JSBI.BigInt(D)));
		if (this.overTwo) {
			if (!JSBI.equal(JSBI.remainder(norm, JSBI.BigInt(4)), JSBI.BigInt(0))) {
				throw new RangeError("assertion");
			}
			norm = JSBI.divide(norm, JSBI.BigInt(4));
		}
		return norm;
	};

	QuadraticInteger.prototype.truncatingDivideInteger = function (x) {
		return new QuadraticInteger(x.toBigInt(), Expression.ZERO.toBigInt(), this.D).truncatingDivide(this);
	};

	QuadraticInteger.prototype.truncatingDivide = function (y) {
		if (!(y instanceof QuadraticInteger)) {
			if (!y instanceof Expression.Integer) {
				throw new RangeError();
			}
			y = new QuadraticInteger(y.toBigInt(), Expression.ZERO.toBigInt(), this.D);
		}
		var x = this;
		if (+x.D !== +y.D) {
			throw new TypeError();
		}
		var n = x.multiply(y.conjugate());
		var d = y.norm();
		while (JSBI.equal(JSBI.remainder(d, JSBI.BigInt(2)), JSBI.BigInt(0)) && JSBI.equal(JSBI.remainder(n.a, JSBI.BigInt(2)), JSBI.BigInt(0)) && JSBI.equal(JSBI.remainder(n.b, JSBI.BigInt(2)), JSBI.BigInt(0))) {
			n = new QuadraticInteger(JSBI.divide(n.a, JSBI.BigInt(2)), JSBI.divide(n.b, JSBI.BigInt(2)), n.D, n.overTwo);
			d = JSBI.divide(d, JSBI.BigInt(2));
		}
		if (!n.overTwo && n.D % 4 === 1 && JSBI.notEqual(JSBI.remainder(n.a, JSBI.BigInt(2)), JSBI.BigInt(0)) && JSBI.notEqual(JSBI.remainder(n.b, JSBI.BigInt(2)), JSBI.BigInt(0)) && JSBI.equal(JSBI.remainder(d, JSBI.BigInt(2)), JSBI.BigInt(0))) {
			n = new QuadraticInteger(n.a, n.b, n.D, true);
			d = JSBI.divide(d, JSBI.BigInt(2));
		}
		return JSBI.equal(JSBI.remainder(JSBI.BigInt(n.a), d), JSBI.BigInt(0)) && JSBI.equal(JSBI.remainder(JSBI.BigInt(n.b), d), JSBI.BigInt(0)) ? new QuadraticInteger(JSBI.divide(JSBI.BigInt(n.a), d), JSBI.divide(JSBI.BigInt(n.b), d), x.D, n.overTwo) : null;
	};

	QuadraticInteger.prototype.negate = function () {
		return new QuadraticInteger(JSBI.unaryMinus(JSBI.BigInt(this.a)), JSBI.unaryMinus(JSBI.BigInt(this.b)), this.D, this.overTwo);
	};

	function factors(n) {
		if (JSBI.lessThan(n, JSBI.BigInt(1))) {
			throw new TypeError();
		}
		var p = JSBI.greaterThan(n, JSBI.BigInt(1)) ? JSBI.BigInt(primeFactor(n)) : JSBI.BigInt(1);
		var t = JSBI.BigInt(1);
		var f = JSBI.BigInt(1);
		var fs = null;
		var i = JSBI.BigInt(1);
		var result = {
			done: false,
			value: null,
			next: function () {
				if (JSBI.equal(p, JSBI.BigInt(1))) {
					this.value = null;
					this.done = true;
					return this;
				}
				if (fs == null) {
					if (JSBI.equal(JSBI.remainder(n, p), JSBI.BigInt(0))) {
						t = JSBI.multiply(t, p);
						n = JSBI.divide(n, p);
						this.value = t;
						this.done = false;
						return this;
					}
					fs = factors(n);
					i = t;
				}
				if (JSBI.equal(i, t)) {
					i = JSBI.BigInt(1);
					f = fs.next().value;
				} else {
					i = JSBI.multiply(i, p);
				}
				this.value = f == null ? null : JSBI.multiply(f, i);
				this.done = f == null;
				return this;
			}
		};
		result[Symbol.iterator] = function () {
			return this;
		};
		return result;
	}

	QuadraticInteger._factors = function (n) {
		return factors(JSBI.BigInt(n));
	};

	QuadraticInteger._complexIntegerPrimeFactor = function (r, i) {
		r = JSBI.BigInt(r);
		i = JSBI.BigInt(i);
		function canBePerfectSquare(n) {
			var bitset = 33751571;
			var result = (bitset >> JSBI.toNumber(JSBI.remainder(n, JSBI.BigInt(32)))) % 2;
			return result === 1;
		}
		function norm(a, b) {
			if (!(a instanceof JSBI) || !(b instanceof JSBI)) {
				throw new TypeError();
			}
			return JSBI.add(JSBI.multiply(a, a), JSBI.multiply(b, b));
		}
		function hasDivisor(r, i, a, b) {
			if (!(a instanceof JSBI) || !(b instanceof JSBI)) {
				throw new TypeError();
			}
			var d = JSBI.add(JSBI.multiply(a, a), JSBI.multiply(b, b));
			var x = JSBI.add(JSBI.multiply(r, a), JSBI.multiply(i, b));
			var y = JSBI.subtract(JSBI.multiply(i, a), JSBI.multiply(r, b));
			return JSBI.equal(JSBI.remainder(x, d), JSBI.BigInt(0)) && JSBI.equal(JSBI.remainder(y, d), JSBI.BigInt(0));
		}
		var n = norm(r, i);

		for (var iteratorp = QuadraticInteger._factors(n)[globalThis.Symbol.iterator](), p = iteratorp.next().value; p != null; p = iteratorp.next().value) {
			var b = JSBI.BigInt(0);
			var c = p;
			while (JSBI.greaterThan(c, JSBI.BigInt(0))) {
				if (canBePerfectSquare(c)) {
					var a = JSBI.BigInt(nthRoot(JSBI.BigInt(c), 2));
					if (JSBI.equal(JSBI.multiply(a, a), JSBI.BigInt(c))) {
						if (JSBI.greaterThan(norm(a, b), JSBI.BigInt(1)) && hasDivisor(r, i, a, b)) {
							return JSBI.equal(b, JSBI.BigInt(0)) ? new Expression.Complex(Expression.ZERO, Expression.Integer.fromBigInt(a)) : new Expression.Complex(Expression.Integer.fromBigInt(a), Expression.Integer.fromBigInt(b));
						}
					}
				}
				b = JSBI.add(b, JSBI.BigInt(1));
				c = JSBI.subtract(p, JSBI.multiply(b, b));
			}
		}
		if (JSBI.greaterThan(n, JSBI.BigInt(1))) {
			throw new TypeError();
		}
		return new Expression.Complex(Expression.Integer.fromBigInt(r), Expression.Integer.fromBigInt(i));
	};

	function jacobiSymbol(k, n) {
		if (k < 0 || n % 2 == 0) {
			throw new Error("Invalid value. k = " + k + ", n = " + n);
		}
		k %= n;
		var jacobi = 1;
		while (k > 0) {
			while (k % 2 == 0) {
				k /= 2;
				var r = n % 8;
				if (r == 3 || r == 5) {
					jacobi = -jacobi;
				}
			}
			var temp = n;
			n = k;
			k = temp;
			if (k % 4 == 3 && n % 4 == 3) {
				jacobi = -jacobi;
			}
			k %= n;
		}
		if (n == 1) {
			return jacobi;
		}
		return 0;
	}

	function LegendreSymbol(a, p) {
		return jacobiSymbol(a, p);
	}

	function quadraticIntegers(norm, D, b) {
		if (!(norm instanceof JSBI) || !(D instanceof JSBI) || !(b instanceof JSBI)) {
			throw new TypeError();
		}
		var overTwo = JSBI.toNumber(JSBI.BigInt(D)) % 4 === 1;
		while (true) {
			var bbD = JSBI.multiply(JSBI.multiply(JSBI.BigInt(b), b), D);
			var guess1 = JSBI.add(JSBI.multiply(JSBI.unaryMinus(norm), overTwo ? JSBI.BigInt(4) : JSBI.BigInt(1)), bbD);
			var guess2 = JSBI.add(JSBI.multiply(norm, overTwo ? JSBI.BigInt(4) : JSBI.BigInt(1)), bbD);
			if (JSBI.toNumber(guess2) > Number.MAX_SAFE_INTEGER || JSBI.toNumber(guess1) > Number.MAX_SAFE_INTEGER) {
				throw new RangeError(norm);
			}
			var guess = guess1;
			if (JSBI.greaterThanOrEqual(guess, JSBI.BigInt(0))) {
				var a = JSBI.BigInt(nthRoot(JSBI.BigInt(guess), 2));
				if (JSBI.equal(guess, JSBI.exponentiate(a, JSBI.BigInt(2)))) {
					return new QuadraticInteger(a, b, D, overTwo);
				}
			}
			var guess = guess2;
			if (JSBI.greaterThanOrEqual(guess, JSBI.BigInt(0))) {
				var a = JSBI.BigInt(nthRoot(JSBI.BigInt(guess), 2));
				if (JSBI.equal(guess, JSBI.exponentiate(a, JSBI.BigInt(2)))) {
					return new QuadraticInteger(a, b, D, overTwo);
				}
			}
			b = JSBI.add(b, JSBI.BigInt(1));
		}
	}

	QuadraticInteger._fundamentalUnit = function (D) {
		return quadraticIntegers(JSBI.BigInt(1), D, JSBI.BigInt(1));
	};

	QuadraticInteger.prototype.primeFactor = function () {
		var a = this.a;
		var b = this.b;
		var D = JSBI.BigInt(this.D);
		var g = ngcd(a, D);

		var k = ngcd(a, b);
		if (JSBI.notEqual(k, JSBI.BigInt(1)) && JSBI.notEqual(k, JSBI.unaryMinus(JSBI.BigInt(1)))) {
			return JSBI.notEqual(k, D) ? Expression.Integer.fromBigInt(k).primeFactor() : new QuadraticInteger(JSBI.BigInt(0), JSBI.BigInt(1), D);
		}

		if (JSBI.equal(g, D)) {
			return new QuadraticInteger(JSBI.BigInt(0), JSBI.BigInt(1), D);
		}

		var g = k;

		var norm = this.norm();

		if (JSBI.equal(norm, JSBI.BigInt(1)) || JSBI.equal(norm, JSBI.unaryMinus(JSBI.BigInt(1)))) {
			var unit = QuadraticInteger._fundamentalUnit(D);
			var uniti = unit.conjugate();
			var x = this;
			if (JSBI.lessThan(JSBI.multiply(JSBI.BigInt(x.b), x.a), JSBI.BigInt(1))) {
				return JSBI.lessThan(x.a, JSBI.BigInt(0)) ? uniti.negate() : uniti;
			}
			return unit;
		}
		var v = this;
		for (var fs = QuadraticInteger._factors(abs(norm)), p = fs.next().value; p != null; p = fs.next().value) {
			if (JSBI.equal(JSBI.remainder(D, JSBI.BigInt(4)), JSBI.BigInt(1)) && JSBI.equal(p, JSBI.BigInt(2))) {
				continue;
			}
			if (JSBI.equal(D, JSBI.BigInt(37)) && (JSBI.equal(p, JSBI.BigInt(7)) || JSBI.equal(p, JSBI.BigInt(14)) || JSBI.equal(p, JSBI.BigInt(3)) || JSBI.equal(p, JSBI.BigInt(11)))) {
				continue;
			}
			if (isPrime(p) && JSBI.notEqual(JSBI.remainder(D, p), JSBI.BigInt(0)) && JSBI.notEqual(p, JSBI.BigInt(2)) && LegendreSymbol(JSBI.toNumber(D), JSBI.toNumber(JSBI.BigInt(p))) !== 1) {
				continue;
			}
			var i = quadraticIntegers(p, D, JSBI.BigInt(0));
			var x = v.truncatingDivide(i);
			if (x != null) {
				return this.equals(i) ? i : i.primeFactor();
			}
			var ic = i.conjugate();
			var x = v.truncatingDivide(ic);
			if (x != null) {
				return this.equals(ic) ? ic : ic.primeFactor();
			}
		}

		return this;

	};

	QuadraticInteger.prototype.toString = function () {
		var s = this.a.toString() + '+' + this.b.toString() + 'sqrt(' + this.D + ')';
		if (this.overTwo) {
			s = '(' + s + ')' + '/' + '2';
		}
		return s;
	};

	QuadraticInteger.prototype.isUnit = function () {
		var n = this.norm();
		return JSBI.equal(n, JSBI.BigInt(1)) || JSBI.equal(n, JSBI.unaryMinus(JSBI.BigInt(1)));
	};

	QuadraticInteger.prototype.equals = function (y) {
		var x = this;
		if (!(y instanceof QuadraticInteger)) {
			if (y.equals(Expression.ZERO)) {
				return JSBI.equal(x.a, JSBI.BigInt(0)) && JSBI.equal(x.b, JSBI.BigInt(0));
			}
			if (y.equals(Expression.ONE)) {
				return JSBI.equal(x.a, JSBI.BigInt(1)) && JSBI.equal(x.b, JSBI.BigInt(0));
			}
			throw new TypeError();
		}
		return JSBI.equal(JSBI.BigInt(x.a), y.a) && JSBI.equal(JSBI.BigInt(x.b), y.b) && +x.D === +y.D && Boolean(x.overTwo) === Boolean(y.overTwo);
	};

	QuadraticInteger.prototype.subtract = function (y) {
		var x = this;
		if (+x.D !== +y.D) {
			throw new TypeError();
		}
		var xa = JSBI.BigInt(x.a);
		var xb = JSBI.BigInt(x.b);
		var ya = JSBI.BigInt(y.a);
		var yb = JSBI.BigInt(y.b);
		if (Boolean(x.overTwo) !== Boolean(y.overTwo)) {
			if (x.overTwo) {
				ya = JSBI.multiply(ya, JSBI.BigInt(2));
				yb = JSBI.multiply(yb, JSBI.BigInt(2));
			}
			if (y.overTwo) {
				xa = JSBI.multiply(xa, JSBI.BigInt(2));
				xb = JSBI.multiply(xb, JSBI.BigInt(2));
			}
		}
		return new QuadraticInteger(JSBI.subtract(xa, ya), JSBI.subtract(xb, yb), x.D, x.overTwo || y.overTwo);
	};

	QuadraticInteger.prototype.isDivisibleBy = function (y) {
		return this.truncatingDivide(y) != null;
	};

	QuadraticInteger.prototype.isDivisibleByInteger = function (x) {
		return x.truncatingDivide(this) != null;
	};

	QuadraticInteger.prototype.remainder = function (y) {
		if (!(y instanceof QuadraticInteger)) {
			if (y instanceof Expression.Multiplication && y.a instanceof Expression.Integer && y.b instanceof Expression.SquareRoot) {
				return this.remainder(new QuadraticInteger(Expression.ZERO.toBigInt(), y.a.toBigInt(), y.b.a.toBigInt()));
			}
			if (!(y instanceof Expression.Integer)) {
				throw new RangeError();
			}
			y = new QuadraticInteger(y.toBigInt(), Expression.ZERO.toBigInt(), this.D);
		}
		var x = this;
		if (+x.D !== +y.D) {
			throw new TypeError();
		}
		var n = x.multiply(y.conjugate());
		var d = y.norm();
		if (JSBI.equal(d, JSBI.BigInt(1)) || JSBI.equal(d, JSBI.unaryMinus(JSBI.BigInt(1)))) {

			return x.subtract(x);
		}
		var q1 = JSBI.divide(JSBI.subtract(n.a, JSBI.remainder(JSBI.BigInt(n.a), d)), d);
		var q2 = JSBI.divide(JSBI.subtract(n.b, JSBI.remainder(JSBI.BigInt(n.b), d)), d);
		var xa = JSBI.BigInt(x.a);
		var ya = JSBI.BigInt(y.a);
		if (JSBI.equal(q1, JSBI.BigInt(0)) && JSBI.equal(q2, JSBI.BigInt(0))) {

			if (JSBI.greaterThan(xa, ya) && JSBI.greaterThan(ya, JSBI.BigInt(0))) {
				return x.subtract(y.multiply(new QuadraticInteger(JSBI.divide(JSBI.subtract(xa, JSBI.remainder(xa, ya)), ya), JSBI.BigInt(0), x.D)));
			}
			if (JSBI.greaterThan(xa, JSBI.unaryMinus(ya)) && JSBI.lessThan(ya, JSBI.BigInt(0))) {
				return x.subtract(y.multiply(new QuadraticInteger(JSBI.divide(JSBI.subtract(xa, JSBI.remainder(xa, JSBI.unaryMinus(ya))), JSBI.unaryMinus(ya)), JSBI.BigInt(0), x.D)));
			}
			if (JSBI.equal(y.b, JSBI.BigInt(0))) {
				return new QuadraticInteger(JSBI.BigInt(1), JSBI.BigInt(0), x.D);
			}

		}

		var q = new QuadraticInteger(q1, q2, x.D);
		var r = x.subtract(y.multiply(q));
		return r;
	};

	QuadraticInteger.prototype.remainderInteger = function (x) {
		return new QuadraticInteger(x.toBigInt(), Expression.ZERO.toBigInt(), this.D).remainder(this);
	};

	QuadraticInteger.prototype.toExpression = function () {
		return Expression.Integer.fromBigInt(this.a).add(Expression.Integer.fromBigInt(this.b).multiply(Expression.Integer.fromNumber(this.D).squareRoot())).divide(this.overTwo ? Expression.TWO : Expression.ONE);
	};

	QuadraticInteger.prototype.abs = function () {
		if (JSBI.lessThanOrEqual(this.a, JSBI.BigInt(0)) && JSBI.lessThanOrEqual(this.b, JSBI.BigInt(0)) || JSBI.lessThan(this.a, JSBI.BigInt(0)) && JSBI.greaterThan(this.norm(), JSBI.BigInt(0)) || JSBI.lessThan(this.b, JSBI.BigInt(0)) && JSBI.lessThan(this.norm(), JSBI.BigInt(0))) {
			return this.negate();
		}
		return this;
	};

	QuadraticInteger.prototype.isValid = function () {
		if (true) {

		}
		if (this.D === 5) {

		}
		if (this.D === 37) {

		}
		if (this.D === 6) {

			return false;
		}
		if (this.D % 4 === 1) {

			return false;
		}
		if ([2, 3, 5, 6, 7, 11, 13, 17, 19, 21, 29, 33, 37, 41, 57, 73].indexOf(this.D) === -1) {

			return false;
		}
		return true;
	};

	QuadraticInteger.prototype.isPositive = function () {
		var qq = this;
		return JSBI.greaterThan(qq.a, JSBI.BigInt(0)) && JSBI.greaterThan(qq.b, JSBI.BigInt(0)) || JSBI.greaterThan(qq.a, JSBI.BigInt(0)) && JSBI.greaterThan(qq.norm(), JSBI.BigInt(0)) || JSBI.greaterThan(qq.b, JSBI.BigInt(0)) && JSBI.lessThan(qq.norm(), JSBI.BigInt(0));
	};

	self.QuadraticInteger = QuadraticInteger;
	function toQuadraticInteger(e) {
		if (e instanceof Expression.Addition && e.b instanceof Expression.Integer && e.a instanceof Expression.SquareRoot && e.a.a instanceof Expression.Integer) {
			return new QuadraticInteger(e.b.toBigInt(), Expression.ONE.toBigInt(), e.a.a.toBigInt());
		}
		if (e instanceof Expression.Addition && e.b instanceof Expression.Integer && e.a instanceof Expression.Multiplication && e.a.a instanceof Expression.Integer && e.a.b instanceof Expression.SquareRoot && e.a.b.a instanceof Expression.Integer) {
			return new QuadraticInteger(e.b.toBigInt(), e.a.a.toBigInt(), e.a.b.a.toBigInt());
		}
		if (e instanceof Expression.Division) {
			if (e.getDenominator().equals(Expression.TWO)) {
				var tmp = toQuadraticInteger(e.getNumerator());
				if (tmp != null) {
					return tmp.truncatingDivide(new QuadraticInteger(2, 0, tmp.D));
				}
			}
		}
	}

	QuadraticInteger.toQuadraticInteger = toQuadraticInteger;

	QuadraticInteger.gcd = function (x, y) {
		var a = x;
		var b = y;
		while (!b.equals(Expression.ZERO)) {
			var r = a.remainder(b);
			if (!JSBI.lessThanOrEqual(JSBI.BigInt(abs(r.norm())), JSBI.BigInt(abs(b.norm())))) {
				throw new TypeError("norm");
			}
			a = b;
			b = r;
		}
		return a;
	};

	function isPrime(n) {
		return JSBI.equal(JSBI.BigInt(primeFactor(n)), JSBI.BigInt(n));
	}

	globalThis.QuadraticInteger = QuadraticInteger;

	QuadraticInteger._checkFactorization = function checkFactorization(i) {
		if (typeof i === "string") {
			i = QuadraticInteger.toQuadraticInteger(ExpressionParser.parse(i));
		}
		var results = [];
		var x = i;
		while (Math.abs(JSBI.toNumber(JSBI.BigInt(x.norm()))) > 1) {

			var p = x.primeFactor();
			results.push(p);
			x = x.truncatingDivide(p);
		}
		if (x.a.toString() !== '1' || x.b.toString() !== '0') {
			results.unshift(x);
		}
		console.log(i + '=' + results.map(function (x) {
			return '(' + x.toString() + ')';
		}).join(''));
	};
}

function MatrixExpressions() {
	var getTableFromAsciiMathMatrix = function (input) {

		var rows = [[]];
		var cellStart = 0;
		var b = 0;
		for (var i = 0; i < input.length; i += 1) {
			var c = input.charCodeAt(i);
			if (c === "{".charCodeAt(0)) {
				b += 1;
				if (b === 2) {
					cellStart = i + 1;
				}
			} else if (c === "}".charCodeAt(0)) {
				if (b === 2) {
					rows[rows.length - 1].push(input.slice(cellStart, i));
				} else if (b === 0) {
					return null;
				}
				b -= 1;
			} else if (c === ",".charCodeAt(0)) {
				if (b === 2) {
					rows[rows.length - 1].push(input.slice(cellStart, i));
					cellStart = i + 1;
				} else if (b === 1) {
					rows.push([]);
				} else if (b === 0) {
					return null;
				}
			} else if (c === "(".charCodeAt(0)) {
				if (b < 2) {
					return null;
				}
				b += 1;
			} else if (c === ")".charCodeAt(0)) {
				if (b < 3) {
					return null;
				}
				b -= 1;
			} else if (/[^\s]/.test(String.fromCharCode(c))) {
				if (b < 2) {
					return null;
				}
			}
		}
		return rows;
	};

	var polynomialToExpression3 = function (matrix, row, variableSymbols) {
		var pivotColumn = 0;
		while (pivotColumn < matrix.cols() - 1 && matrix.e(row, pivotColumn).equals(Expression.ZERO)) {
			pivotColumn += 1;
		}
		if (pivotColumn === matrix.cols() - 1) {
			throw new TypeError();
		}
		var result = undefined;
		for (var i = pivotColumn; i < matrix.cols() - 1; i += 1) {
			var c = i === pivotColumn ? matrix.e(row, matrix.cols() - 1) : matrix.e(row, i).negate();
			var v = i === pivotColumn ? undefined : variableSymbols[i];
			if (!c.equals(Expression.ZERO)) {
				var current = v == undefined ? c : c.equals(Expression.ONE) ? v : new Expression.Multiplication(c, v);
				result = result == undefined ? current : new Expression.Addition(result, current);
			}
		}
		return result == undefined ? Expression.ZERO : result;
	};

	ExpressionParser.toMathML = function (input, printOptions) {
		return ExpressionParser.parse(input, new ExpressionParser.Context()).toMathML(printOptions);
	};

	ExpressionParser.getElementsArray = function (matrixTableState) {
		var mode = matrixTableState.mode;
		var type = matrixTableState.type;
		var textareaValue = matrixTableState.textareaValue;
		var inputValues = matrixTableState.inputValues;
		if (mode !== "cells") {

			var resultRows = Matrix.split(textareaValue);
			return {
				elements: resultRows,
				variableNames: undefined
			};
		}

		return {
			elements: inputValues,
			variableNames: matrixTableState.variableNames
		};
	};

	Matrix.toMatrix = function (array) {
		var context = new ExpressionParser.Context();
		return Matrix.padRows(array, function (e) {
			return ExpressionParser.parse(e, context);
		});
	};

	Expression.defaultOptions.useMatrixContainer = true;

	var getResultAndHTML = function (expression, variableNames, result, printOptions) {
		var resultHTML = "";
		if (result instanceof Expression.NoAnswerExpression) {
			var name = result.name;
			var matrix = result.a.matrix;
			var second = result.second;

			if (name === "solve") {
				resultHTML = "";
			} else {
				resultHTML = Expression.Details.getCallback(name)(printOptions, matrix, second == undefined ? variableNames : second);
			}
		} else if (result instanceof Expression.Equality) {

			resultHTML = "";
			resultHTML += "<div>" + "<math>" + expression.toMathML(printOptions) + "</math>" + "</div>";
			resultHTML += "<div>" + "<math>" + result.toMathML(printOptions) + "</math>" + "</div>";
		} else {
			resultHTML = "<math>" + expression.toMathML(printOptions) + "<mo>=</mo>" + result.toMathML(printOptions) + "</math>";
		}
		return {
			result: result,
			html: resultHTML
		};
	};

	var createDetailsSummary = function (idPrefix, details, bestMethodsLimit) {
		bestMethodsLimit = bestMethodsLimit == undefined ? 1 : bestMethodsLimit;
		var s = "";
		for (var j = 0; j < details.length; j += 1) {

			var countRows = function (s) {
				var state = 0;
				var result = 1;
				for (var i = 0; i < s.length; i += 1) {
					var c = s.charCodeAt(i);
					if (c === ",".charCodeAt(0)) {
						if (state === 1) {
							result += 1;
						}
					} else if (c === "{".charCodeAt(0)) {
						state += 1;
					} else if (c === "}".charCodeAt(0)) {
						state -= 1;
					}
				}
				return result;
			};
			var rows = countRows(details[j].matrix);

			var type = details[j].type;
			var items = [];
			var edetails = Expression.Details.getAll(type, rows);
			for (var i = 0; i < edetails.length; i += 1) {
				var x = edetails[i];
				var jsonObject = {
					type: x.type,
					matrix: details[j].matrix,
					second: details[j].second
				};

				var detailsIdPrefix = idPrefix + '-' + 'd' + i;

				var item = "" + "<details data-id-prefix=\"" + detailsIdPrefix + "\" " + "data-details=\"" + Expression.escapeHTML(JSON.stringify(jsonObject)) + "\"" + ">" + "<summary>" + i18n['ui.details'] + (x.i18n != undefined ? " (" + x.i18n() + ")" : "") + "</summary>" + "<div class=\"indented\"></div>" + "</details>";
				items.push(item);
			}
			var groupId = idPrefix + "-" + Expression.id();
			if (items.length > bestMethodsLimit + 1) {
				s += items.slice(0, bestMethodsLimit).join("");

				s += "<div id=\"" + groupId + "\" role=\"group\">";
				s += items.slice(bestMethodsLimit).join("");
				s += "</div>";

			} else {
				s += items.join("");
			}
		}
		return s;
	};

	Expression.Minor = function (matrix, i, j) {
		Expression.Determinant.call(this, matrix);
		this.i = i;
		this.j = j;
	};

	Expression.Minor.prototype = Object.create(Expression.Determinant.prototype);

	Expression.Minor.prototype.toMathML = function (options) {
		options = Object.assign({}, options, {
			horizontalStrike: this.i,
			verticalStrike: this.j,
			useBraces: ["|", "|"]
		});
		return this.a.toMathML(options);
	};

	Expression.p = function (s, args, printOptions) {
		if (typeof s === "number") {
			return Expression.Integer.fromNumber(s).toMathML(printOptions);
		}
		if (args == null && printOptions != null || args != null && printOptions == null) {
			throw new TypeError();
		}
		args = args || null;
		printOptions = printOptions || null;
		var result = "";
		var parts = s.split("=");
		for (var i = 0; i < parts.length; i += 1) {
			var e = ExpressionParser.parse(parts[i], new ExpressionParser.Context(function (id) {
				return args != undefined && args[id] != undefined ? args[id] : undefined;
			}));

			if (i !== 0) {
				result += "<mo>" + (e.isExact() ? "=" : "&asymp;") + "</mo>";
			}
			result += e.toMathML(printOptions);
		}
		return result;
	};

	Expression.Details = function () {};
	Expression.Details._details = [];
	Expression.Details.details = null;

	var lowerBound = function (array, compare) {
		var start = 0;
		var end = array.length;
		while (start < end) {
			var middle = start + Math.floor((end - start) / 2);
			var value = array[middle];
			if (compare(value) <= 0) {
				end = middle;
			} else {
				start = middle + 1;
			}
		}
		return start;
	};

	var sortDetails = function () {
		if (Expression.Details.details == null) {
			Expression.Details._details.sort(function (a, b) {
				return a.type < b.type ? -1 : +1;
			});
			Expression.Details.details = Expression.Details._details;
		}
	};

	Expression.Details.getCallback = function (type) {
		console.warn(type)
		sortDetails();
		var i = lowerBound(Expression.Details.details, function (a) {
			return type <= a.type ? -1 : +1;
		});
		if (i < Expression.Details.details.length) {
			if (Expression.Details.details[i].type === type) {
				return Expression.Details.details[i].callback;
			}
		}
		return undefined;
	};

	Expression.Details.add = function (data) {
		var x = {
			type: data.type,
			i18n: data.i18n,
			minRows: data.minRows || 1,
			maxRows: data.maxRows || 1 / 0,
			priority: data.priority || 0,

			callback: data.callback
		};
		Expression.Details._details.push(x);
		Expression.Details.details = null;

		if (x.type !== "multiply" && x.type !== "add" && x.type !== "pow" && x.type !== "special-determinant") {
			ExpressionParser.addOperation(x.type, x.type === "expand-along-column" || x.type === "expand-along-row" || x.type === "obtain-zeros-in-column" || x.type === "obtain-zeros-in-row" || x.type === "polynomial-multiply" ? 2 : 1);
		}
	};

	Expression.Details.getAll = function (typePrefix, rows) {
		var result = [];
		sortDetails();
		for (var i = lowerBound(Expression.Details.details, function (a) {
			return typePrefix <= a.type ? -1 : +1;
		}); i < Expression.Details.details.length && Expression.Details.details[i].type.indexOf(typePrefix) === 0; i += 1) {
			var x = Expression.Details.details[i];
			if (x.type.indexOf(typePrefix) === 0) {
				if (rows >= x.minRows && rows <= x.maxRows) {
					if (rows <= 4 || rows >= 10) {

						result.push(x);
					}
				}
			}
		}
		result.sort(function (a, b) {
			return b.priority - a.priority;
		});
		console.warn(result)
		return result;
	};

	var roman = function (n) {
		var digits = "IVXLCDM";
		var i = digits.length + 1;
		var result = "";
		var value = 1000;
		while ((i -= 2) >= 0) {
			var v = Math.floor(value / 10);
			var j = -1;
			while (++j < 2) {
				while (n >= value) {
					n -= value;
					result += digits.slice(i - j, i - j + 1);
				}
				value -= v;
				while (n >= value) {
					n -= value;
					result += digits.slice(i - 2, i - 2 + 1) + digits.slice(i - j, i - j + 1);
				}
				value -= 4 * v;
			}
			value = v;
		}
		return result;
	};
	var numberFormat1 = null;
	var initNumberFormat = function (event) {
		Expression.numberFormat = {
			format: function (number) {

				if (numberFormat1 == null) {

					var lang = String(navigator.language || 'en').slice(0, 2);
					if (lang === 'en') {
						numberFormat1 = {
							format: function (number) {
								return number.toString();
							}
						};
					} else {
						numberFormat1 = new Intl.NumberFormat(undefined, {
							useGrouping: false
						});
					}
				}

				return numberFormat1.format(number);
			}
		};
	};
	globalThis.addEventListener('languagechange', initNumberFormat);
	initNumberFormat();
	var numberFormat = null;
	globalThis.addEventListener('languagechange', function (event) {
		numberFormat = null;
	});
	var localeString = function (number) {
		console.assert(Math.floor(number) === number && number >= 0 && number <= Number.MAX_SAFE_INTEGER);
		if (numberFormat == null) {
			numberFormat = new Intl.NumberFormat(undefined, {
				useGrouping: false
			});
		}
		return numberFormat.format(number);
	};
	var getMatrixRowDenotation = function (i) {
		return i18n['matrix.row.notation'].replace(/\$\{i\}/g, localeString(i)).replace(/\$\{i\:roman\}/g, roman(i));
	};

	Matrix.prototype.getDeterminantEventType = function (base) {
		for (var i = 0; i < this.rows(); i += 1) {
			var isZero = true;
			for (var j = 0; j < this.cols(); j += 1) {
				var e = this.e(i, j);
				if (!e.equals(Expression.ZERO)) {
					isZero = false;
				}
			}
			if (isZero) {
				return {
					type: "special-determinant",
					row: i,
					col: -1
				};
			}
		}
		for (var j = 0; j < this.cols(); j += 1) {
			var isZero = true;
			for (var i = 0; i < this.rows(); i += 1) {
				var e = this.e(i, j);
				if (!e.equals(Expression.ZERO)) {
					isZero = false;
				}
			}
			if (isZero) {
				return {
					type: "special-determinant",
					row: -1,
					col: j
				};
			}
		}
		return {
			type: base,
			row: -1,
			col: -1
		};
	};

	Expression.someDetailsNew = {
		"determinant2x2": "<span data-custom-paint=\"custom-menclose\" data-color=\"0a\" data-cells=\"[[0,0],[1,1]]\"><span data-custom-paint=\"custom-menclose\" data-color=\"1a\" data-cells=\"[[0,1],[1,0]]\"><math><mrow><mo>|</mo><mtable><mtr><mtd><msub><mi>a</mi><mrow><mn>1</mn><mo>&ic;</mo><mn>1</mn></mrow></msub></mtd><mtd><msub><mi>a</mi><mrow><mn>1</mn><mo>&ic;</mo><mn>2</mn></mrow></msub></mtd></mtr><mtr><mtd><msub><mi>a</mi><mrow><mn>2</mn><mo>&ic;</mo><mn>1</mn></mrow></msub></mtd><mtd><msub><mi>a</mi><mrow><mn>2</mn><mo>&ic;</mo><mn>2</mn></mrow></msub></mtd></mtr></mtable><mo>|</mo></mrow><mo>=</mo><mrow><mrow style=\"color: #D64040\"><msub><mi>a</mi><mrow><mn>1</mn><mo>&ic;</mo><mn>1</mn></mrow></msub><mo>&sdot;</mo><msub><mi>a</mi><mrow><mn>2</mn><mo>&ic;</mo><mn>2</mn></mrow></msub></mrow><mo>&minus;</mo><mrow style=\"color: #4040D6\"><msub><mi>a</mi><mrow><mn>1</mn><mo>&ic;</mo><mn>2</mn></mrow></msub><mo>&sdot;</mo><msub><mi>a</mi><mrow><mn>2</mn><mo>&ic;</mo><mn>1</mn></mrow></msub></mrow></mrow></math></span></span>",
		"determinant3x3": "<math><mrow><mo>|</mo><mtable><mtr><mtd><msub><mi>a</mi><mrow><mn>1</mn><mo>&ic;</mo><mn>1</mn></mrow></msub></mtd><mtd><msub><mi>a</mi><mrow><mn>1</mn><mo>&ic;</mo><mn>2</mn></mrow></msub></mtd><mtd><msub><mi>a</mi><mrow><mn>1</mn><mo>&ic;</mo><mn>3</mn></mrow></msub></mtd></mtr><mtr><mtd><msub><mi>a</mi><mrow><mn>2</mn><mo>&ic;</mo><mn>1</mn></mrow></msub></mtd><mtd><msub><mi>a</mi><mrow><mn>2</mn><mo>&ic;</mo><mn>2</mn></mrow></msub></mtd><mtd><msub><mi>a</mi><mrow><mn>2</mn><mo>&ic;</mo><mn>3</mn></mrow></msub></mtd></mtr><mtr><mtd><msub><mi>a</mi><mrow><mn>3</mn><mo>&ic;</mo><mn>1</mn></mrow></msub></mtd><mtd><msub><mi>a</mi><mrow><mn>3</mn><mo>&ic;</mo><mn>2</mn></mrow></msub></mtd><mtd><msub><mi>a</mi><mrow><mn>3</mn><mo>&ic;</mo><mn>3</mn></mrow></msub></mtd></mtr></mtable><mo>|</mo></mrow></math><math><mo>=</mo></math>",
		"matrix3x3": "<math><mtable><mtr><mtd><msub><mi>a</mi><mrow><mn>1</mn><mo>&ic;</mo><mn>1</mn></mrow></msub></mtd><mtd><msub><mi>a</mi><mrow><mn>1</mn><mo>&ic;</mo><mn>2</mn></mrow></msub></mtd><mtd><msub><mi>a</mi><mrow><mn>1</mn><mo>&ic;</mo><mn>3</mn></mrow></msub></mtd></mtr><mtr><mtd><msub><mi>a</mi><mrow><mn>2</mn><mo>&ic;</mo><mn>1</mn></mrow></msub></mtd><mtd><msub><mi>a</mi><mrow><mn>2</mn><mo>&ic;</mo><mn>2</mn></mrow></msub></mtd><mtd><msub><mi>a</mi><mrow><mn>2</mn><mo>&ic;</mo><mn>3</mn></mrow></msub></mtd></mtr><mtr><mtd><msub><mi>a</mi><mrow><mn>3</mn><mo>&ic;</mo><mn>1</mn></mrow></msub></mtd><mtd><msub><mi>a</mi><mrow><mn>3</mn><mo>&ic;</mo><mn>2</mn></mrow></msub></mtd><mtd><msub><mi>a</mi><mrow><mn>3</mn><mo>&ic;</mo><mn>3</mn></mrow></msub></mtd></mtr></mtable></math>",
		"determinantTriangle": "${determinant3x3}<table class=\"some-details-table\"><tr><td><math><mrow><mo>+</mo><msub><mi>a</mi><mrow><mn>1</mn><mo>&ic;</mo><mn>1</mn></mrow></msub></mrow><mo>&sdot;</mo><msub><mi>a</mi><mrow><mn>2</mn><mo>&ic;</mo><mn>2</mn></mrow></msub><mo>&sdot;</mo><msub><mi>a</mi><mrow><mn>3</mn><mo>&ic;</mo><mn>3</mn></mrow></msub></math></td><td><span data-custom-paint=\"custom-menclose\" data-color=\"0a\" data-cells=\"[[0,0],[1,1],[2,2]]\">${matrix3x3}</span></td></tr><tr><td><math><mrow><mo>+</mo><msub><mi>a</mi><mrow><mn>1</mn><mo>&ic;</mo><mn>2</mn></mrow></msub></mrow><mo>&sdot;</mo><msub><mi>a</mi><mrow><mn>2</mn><mo>&ic;</mo><mn>3</mn></mrow></msub><mo>&sdot;</mo><msub><mi>a</mi><mrow><mn>3</mn><mo>&ic;</mo><mn>1</mn></mrow></msub></math></td><td><span data-custom-paint=\"custom-menclose\" data-color=\"0\" data-cells=\"[[0,0],[1,1],[2,2]]\"><span data-custom-paint=\"custom-menclose\" data-color=\"0a\" data-cells=\"[[0,1],[1,2],[2,0]]\">${matrix3x3}</span></span></td></tr><tr><td><math><mrow><mo>+</mo><msub><mi>a</mi><mrow><mn>1</mn><mo>&ic;</mo><mn>3</mn></mrow></msub></mrow><mo>&sdot;</mo><msub><mi>a</mi><mrow><mn>2</mn><mo>&ic;</mo><mn>1</mn></mrow></msub><mo>&sdot;</mo><msub><mi>a</mi><mrow><mn>3</mn><mo>&ic;</mo><mn>2</mn></mrow></msub></math></td><td><span data-custom-paint=\"custom-menclose\" data-color=\"0\" data-cells=\"[[0,0],[1,1],[2,2]]\"><span data-custom-paint=\"custom-menclose\" data-color=\"0\" data-cells=\"[[0,1],[1,2],[2,0]]\"><span data-custom-paint=\"custom-menclose\" data-color=\"0a\" data-cells=\"[[0,2],[1,0],[2,1]]\">${matrix3x3}</span></span></span></td></tr><tr><td><math><mrow><mo>&minus;</mo><msub><mi>a</mi><mrow><mn>1</mn><mo>&ic;</mo><mn>3</mn></mrow></msub></mrow><mo>&sdot;</mo><msub><mi>a</mi><mrow><mn>2</mn><mo>&ic;</mo><mn>2</mn></mrow></msub><mo>&sdot;</mo><msub><mi>a</mi><mrow><mn>3</mn><mo>&ic;</mo><mn>1</mn></mrow></msub></math></td><td><span data-custom-paint=\"custom-menclose\" data-color=\"0\" data-cells=\"[[0,0],[1,1],[2,2]]\"><span data-custom-paint=\"custom-menclose\" data-color=\"0\" data-cells=\"[[0,1],[1,2],[2,0]]\"><span data-custom-paint=\"custom-menclose\" data-color=\"0\" data-cells=\"[[0,2],[1,0],[2,1]]\"><span data-custom-paint=\"custom-menclose\" data-color=\"1a\" data-cells=\"[[2,0],[1,1],[0,2]]\">${matrix3x3}</span></span></span></span></td></tr><tr><td><math><mrow><mo>&minus;</mo><msub><mi>a</mi><mrow><mn>1</mn><mo>&ic;</mo><mn>1</mn></mrow></msub></mrow><mo>&sdot;</mo><msub><mi>a</mi><mrow><mn>2</mn><mo>&ic;</mo><mn>3</mn></mrow></msub><mo>&sdot;</mo><msub><mi>a</mi><mrow><mn>3</mn><mo>&ic;</mo><mn>2</mn></mrow></msub></math></td><td><span data-custom-paint=\"custom-menclose\" data-color=\"0\" data-cells=\"[[0,0],[1,1],[2,2]]\"><span data-custom-paint=\"custom-menclose\" data-color=\"0\" data-cells=\"[[0,1],[1,2],[2,0]]\"><span data-custom-paint=\"custom-menclose\" data-color=\"0\" data-cells=\"[[0,2],[1,0],[2,1]]\"><span data-custom-paint=\"custom-menclose\" data-color=\"1\" data-cells=\"[[2,0],[1,1],[0,2]]\"><span data-custom-paint=\"custom-menclose\" data-color=\"1a\" data-cells=\"[[2,1],[1,2],[0,0]]\">${matrix3x3}</span></span></span></span></span></td></tr><tr><td><math><mrow><mo>&minus;</mo><msub><mi>a</mi><mrow><mn>1</mn><mo>&ic;</mo><mn>2</mn></mrow></msub></mrow><mo>&sdot;</mo><msub><mi>a</mi><mrow><mn>2</mn><mo>&ic;</mo><mn>1</mn></mrow></msub><mo>&sdot;</mo><msub><mi>a</mi><mrow><mn>3</mn><mo>&ic;</mo><mn>3</mn></mrow></msub></math></td><td><span data-custom-paint=\"custom-menclose\" data-color=\"0\" data-cells=\"[[0,0],[1,1],[2,2]]\"><span data-custom-paint=\"custom-menclose\" data-color=\"0\" data-cells=\"[[0,1],[1,2],[2,0]]\"><span data-custom-paint=\"custom-menclose\" data-color=\"0\" data-cells=\"[[0,2],[1,0],[2,1]]\"><span data-custom-paint=\"custom-menclose\" data-color=\"1\" data-cells=\"[[2,0],[1,1],[0,2]]\"><span data-custom-paint=\"custom-menclose\" data-color=\"1\" data-cells=\"[[2,1],[1,2],[0,0]]\"><span data-custom-paint=\"custom-menclose\" data-color=\"1a\" data-cells=\"[[2,2],[1,0],[0,1]]\">${matrix3x3}</span></span></span></span></span></span></td></tr></table>",
		"matrix5x3": "<math><mtable><mtr><mtd><msub><mi>a</mi><mrow><mn>1</mn><mo>&ic;</mo><mn>1</mn></mrow></msub></mtd><mtd><msub><mi>a</mi><mrow><mn>1</mn><mo>&ic;</mo><mn>2</mn></mrow></msub></mtd><mtd><msub><mi>a</mi><mrow><mn>1</mn><mo>&ic;</mo><mn>3</mn></mrow></msub></mtd><mtd style=\"color: #808080; border-left: 1px dashed;\"><msub><mi>a</mi><mrow><mn>1</mn><mo>&ic;</mo><mn>1</mn></mrow></msub></mtd><mtd style=\"color: #808080\"><msub><mi>a</mi><mrow><mn>1</mn><mo>&ic;</mo><mn>2</mn></mrow></msub></mtd></mtr><mtr><mtd><msub><mi>a</mi><mrow><mn>2</mn><mo>&ic;</mo><mn>1</mn></mrow></msub></mtd><mtd><msub><mi>a</mi><mrow><mn>2</mn><mo>&ic;</mo><mn>2</mn></mrow></msub></mtd><mtd><msub><mi>a</mi><mrow><mn>2</mn><mo>&ic;</mo><mn>3</mn></mrow></msub></mtd><mtd style=\"color: #808080; border-left: 1px dashed;\"><msub><mi>a</mi><mrow><mn>2</mn><mo>&ic;</mo><mn>1</mn></mrow></msub></mtd><mtd style=\"color: #808080\"><msub><mi>a</mi><mrow><mn>2</mn><mo>&ic;</mo><mn>2</mn></mrow></msub></mtd></mtr><mtr><mtd><msub><mi>a</mi><mrow><mn>3</mn><mo>&ic;</mo><mn>1</mn></mrow></msub></mtd><mtd><msub><mi>a</mi><mrow><mn>3</mn><mo>&ic;</mo><mn>2</mn></mrow></msub></mtd><mtd><msub><mi>a</mi><mrow><mn>3</mn><mo>&ic;</mo><mn>3</mn></mrow></msub></mtd><mtd style=\"color: #808080; border-left: 1px dashed;\"><msub><mi>a</mi><mrow><mn>3</mn><mo>&ic;</mo><mn>1</mn></mrow></msub></mtd><mtd style=\"color: #808080\"><msub><mi>a</mi><mrow><mn>3</mn><mo>&ic;</mo><mn>2</mn></mrow></msub></mtd></mtr></mtable></math>",
		"determinantSarrus": "${determinant3x3}<table class=\"some-details-table\"><tr><td><math><mrow><mrow><mo>+</mo><msub><mi>a</mi><mrow><mn>1</mn><mo>&ic;</mo><mn>1</mn></mrow></msub></mrow><mo>&sdot;</mo><msub><mi>a</mi><mrow><mn>2</mn><mo>&ic;</mo><mn>2</mn></mrow></msub><mo>&sdot;</mo><msub><mi>a</mi><mrow><mn>3</mn><mo>&ic;</mo><mn>3</mn></mrow></msub></mrow><mo>+</mo><mrow><msub><mi>a</mi><mrow><mn>1</mn><mo>&ic;</mo><mn>2</mn></mrow></msub><mo>&sdot;</mo><msub><mi>a</mi><mrow><mn>2</mn><mo>&ic;</mo><mn>3</mn></mrow></msub><mo>&sdot;</mo><msub><mi>a</mi><mrow><mn>3</mn><mo>&ic;</mo><mn>1</mn></mrow></msub></mrow><mo>+</mo><mrow><msub><mi>a</mi><mrow><mn>1</mn><mo>&ic;</mo><mn>3</mn></mrow></msub><mo>&sdot;</mo><msub><mi>a</mi><mrow><mn>2</mn><mo>&ic;</mo><mn>1</mn></mrow></msub><mo>&sdot;</mo><msub><mi>a</mi><mrow><mn>3</mn><mo>&ic;</mo><mn>2</mn></mrow></msub></mrow></math></td><td><span data-custom-paint=\"custom-menclose\" data-color=\"0a\" data-cells=\"[[0,0],[1,1],[2,2]]\"><span data-custom-paint=\"custom-menclose\" data-color=\"0a\" data-cells=\"[[0,1],[1,2],[2,3]]\"><span data-custom-paint=\"custom-menclose\" data-color=\"0a\" data-cells=\"[[0,2],[1,3],[2,4]]\">${matrix5x3}</span></span></span></td></tr><tr><td><math><mrow><mrow><mo>&minus;</mo><msub><mi>a</mi><mrow><mn>1</mn><mo>&ic;</mo><mn>3</mn></mrow></msub></mrow><mo>&sdot;</mo><msub><mi>a</mi><mrow><mn>2</mn><mo>&ic;</mo><mn>2</mn></mrow></msub><mo>&sdot;</mo><msub><mi>a</mi><mrow><mn>3</mn><mo>&ic;</mo><mn>1</mn></mrow></msub></mrow><mo>&minus;</mo><mrow><msub><mi>a</mi><mrow><mn>1</mn><mo>&ic;</mo><mn>1</mn></mrow></msub><mo>&sdot;</mo><msub><mi>a</mi><mrow><mn>2</mn><mo>&ic;</mo><mn>3</mn></mrow></msub><mo>&sdot;</mo><msub><mi>a</mi><mrow><mn>3</mn><mo>&ic;</mo><mn>2</mn></mrow></msub></mrow><mo>&minus;</mo><mrow><msub><mi>a</mi><mrow><mn>1</mn><mo>&ic;</mo><mn>2</mn></mrow></msub><mo>&sdot;</mo><msub><mi>a</mi><mrow><mn>2</mn><mo>&ic;</mo><mn>1</mn></mrow></msub><mo>&sdot;</mo><msub><mi>a</mi><mrow><mn>3</mn><mo>&ic;</mo><mn>3</mn></mrow></msub></mrow></math></td><td><span data-custom-paint=\"custom-menclose\" data-color=\"0\" data-cells=\"[[0,0],[1,1],[2,2]]\"><span data-custom-paint=\"custom-menclose\" data-color=\"0\" data-cells=\"[[0,1],[1,2],[2,3]]\"><span data-custom-paint=\"custom-menclose\" data-color=\"0\" data-cells=\"[[0,2],[1,3],[2,4]]\"><span data-custom-paint=\"custom-menclose\" data-color=\"1a\" data-cells=\"[[0,2],[1,1],[2,0]]\"><span data-custom-paint=\"custom-menclose\" data-color=\"1a\" data-cells=\"[[0,3],[1,2],[2,1]]\"><span data-custom-paint=\"custom-menclose\" data-color=\"1a\" data-cells=\"[[0,4],[1,3],[2,2]]\">${matrix5x3}</span></span></span></span></span></span></td></tr></table>",
		"someDetails3": "<span data-custom-paint=\"custom-menclose\" data-color=\"0a\" data-cells=\"[[0,0],[2,2]]\"><span data-custom-paint=\"custom-menclose\" data-color=\"1a\" data-cells=\"[[0,2],[2,0]]\"><math><mtable><mtr><mtd style=\"font-weight: bolder; border: 1px solid; border-radius: 50%;\"><msub><mi>a</mi><mrow><mi>r</mi><mo>,</mo><mi>c</mi></mrow></msub></mtd><mtd><mtext>&hellip;</mtext></mtd><mtd><msub><mi>a</mi><mrow><mi>r</mi><mo>,</mo><mi>j</mi></mrow></msub></mtd></mtr><mtr><mtd><mtext>&vellip;</mtext></mtd><mtd></mtd><mtd><mtext>&vellip;</mtext></mtd></mtr><mtr><mtd><msub><mi>a</mi><mrow><mi>i</mi><mo>,</mo><mi>c</mi></mrow></msub></mtd><mtd><mtext>&hellip;</mtext></mtd><mtd><msub><mi>a</mi><mrow><mi>i</mi><mo>,</mo><mi>j</mi></mrow></msub></mtd></mtr></mtable></math></span></span>",
		"": ""
	};

	Expression.getSomeDetails = function (id) {
		var s = Expression.someDetailsNew[id];
		return s.replace(/\$\{determinant3x3\}/g, Expression.someDetailsNew.determinant3x3).replace(/\$\{matrix3x3\}/g, Expression.someDetailsNew.matrix3x3).replace(/\$\{matrix5x3\}/g, Expression.someDetailsNew.matrix5x3).replace(/\<mn>(\d+)\<\/mn>/g, function (p, digits) {
			return Expression.p(Number(digits));
		});
	};

	var getDeterminant = function (matrix, k, r, z, coefficient) {
		if (matrix.cols() === 1) {
			return coefficient.multiply(matrix.e(0, 0));
		}
		var o = Expression.ZERO;
		for (var i = 0; i < matrix.cols(); i += 1) {

			var mx = matrix.minorMatrix(i, k);
			var e = matrix.e(i, k);
			var kk = coefficient.multiply(Expression.ONE.negate().pow((i + k) % 2 !== 0 ? Expression.ONE : Expression.ZERO).multiply(e));
			r.push({
				m: mx,
				a: kk,
				z: z,
				minor: new Expression.Minor(new Expression.Matrix(matrix), i, k),
				e: e
			});
			o = o.add(getDeterminant(mx, 0, r, z + 1, kk));
		}
		return o;
	};

	Expression.expandDeterminant = function (matrix, byRow, number, printOptions) {

		var r = [];
		var k = Number(number.toString()) - 1;

		if (!matrix.isSquare()) {
			throw new RangeError("NonSquareMatrixException");
		}
		if (k >= matrix.rows() || k < 0 || k !== Math.floor(k)) {

			throw new RangeError("IntegerInputError" + ":" + (byRow ? "rowNumber" : "columnNumber"));
		}

		var result = null;
		if (byRow) {

			result = getDeterminant(matrix.transpose(), k, r, 1, Expression.ONE);
			var l = -1;
			while (++l < r.length) {
				r[l].m = r[l].m.transpose();
				r[l].minor = new Expression.Minor(new Expression.Matrix(r[l].minor.a.matrix.transpose()), r[l].minor.j, r[l].minor.i);
			}
		} else {
			result = getDeterminant(matrix, k, r, 1, Expression.ONE);
		}

		var html = "";
		html += "<math>";
		html += new Expression.Determinant(new Expression.Matrix(matrix)).toMathML(printOptions);
		html += "<mo>=</mo>";
		var z = matrix.cols() - 1;
		for (var i = 1; i < z; i += 1) {
			var e = "";
			for (var j = 0; j < r.length; j += 1) {
				if (r[j].z === i && !r[j].a.equals(Expression.ZERO)) {
					var det = new Expression.Determinant(new Expression.Matrix(r[j].m));
					var current = new Expression.Multiplication(new NonSimplifiedExpression(r[j].a), det);
					if (e !== "") {
						e += "<mo>+</mo>";
					}
					if (i !== 1) {
						e += current.toMathML(printOptions);
					} else {
						e += Expression.p("(-1)**(i+j)*e*A", {
							i: Expression.Integer.fromNumber(r[j].minor.i + 1),
							j: Expression.Integer.fromNumber(r[j].minor.j + 1),
							e: r[j].e,
							A: r[j].minor
						}, printOptions);
					}
				}
			}
			if (e != undefined) {

				html += "<mrow>";
				html += e;
				html += "</mrow>";
				html += "<mo>=</mo>";
			}
		}
		html += result.toMathML(printOptions);
		html += "</math>";
		return html;
	};

	Expression.Details.add({
		type: "eigenvectors",
		minRows: 2,
		callback: function (printOptions, matrix) {
			if (matrix.cols() <= 0) {
				return Expression.Details.getCallback("steps-to-find-eigenvectors")(printOptions, matrix);
			}
			if (!matrix.isSquare()) {
				throw new RangeError("NonSquareMatrixException");
			}
			var html = '';
			html += '<math>' + Expression.p('A=M', {
				M: new Expression.Matrix(matrix)
			}, printOptions) + '</math>';
			var title = i18n['eigen.vectors.forMatrixA'] || "";
			html += '<p>' + title.replaceAll('`A`', '<math>' + Expression.p('A') + '</math>') + '</p>';

			var eigenvalues = Expression.getEigenvalues(matrix);
			var eigenvectors = Expression.getEigenvectors(matrix, eigenvalues);
			var uniqueEigenvalues = Expression.unique(eigenvalues);

			for (var i = 0; i < eigenvectors.length; i += 1) {
				if (eigenvectors[i] != null) {
					var x = eigenvalues[i];
					var j = uniqueEigenvalues.indexOf(x);

					html += '<p>' +
						'<math>' + Expression.p('λ_' + (j + 1) + '=x', { x: x }, printOptions) + '</math>' +
						', ' +
						'<math>' + Expression.p('v=x', { v: new Expression.MatrixSymbol('v'), x: new Expression.Matrix(eigenvectors[i]) }, printOptions) + '</math>' +
						'</p>';
				}
			}

			var detailsHTML = createDetailsSummary(printOptions.idPrefix, [{
				type: 'steps-to-find-eigenvectors',
				matrix: matrix.toString(),
				second: undefined
			}]);
			html += detailsHTML;
			return html;
		}
	});

	Expression.Details.add({
		type: "steps-to-find-eigenvectors",
		minRows: 1,
		callback: function (printOptions, matrix) {
			if (!matrix.isSquare()) {
				throw new RangeError("NonSquareMatrixException");
			}
			var html = "";
			html += "<ol>";
			var tmp = Expression.getEigenvaluesWithSteps(printOptions, matrix);
			var eigenvalues = tmp.eigenvalues;
			html += "<li>";
			html += tmp.html;
			html += "</li>";
			if (eigenvalues.length > 0) {
				var tmp2 = Expression.getEigenvectorsWithSteps(printOptions, matrix, eigenvalues);
				html += "<li>";
				html += tmp2.html;
				html += "</li>";
			} else {
				html += "<li>";
				html += i18n['eigen.noRationalSolutions'];
				html += "</li>";
			}
			html += "</ol>";
			return html;
		}
	});

	Expression.Details.add({
		type: "eigenvalues",
		minRows: 2,
		callback: function (printOptions, matrix) {
			if (matrix.cols() <= 0) {
				return Expression.Details.getCallback("steps-to-find-eigenvalues")(printOptions, matrix);
			}
			if (!matrix.isSquare()) {
				throw new RangeError("NonSquareMatrixException");
			}
			var html = '';
			html += '<math>' + Expression.p('A=M', {
				M: new Expression.Matrix(matrix)
			}, printOptions) + '</math>';
			var title = i18n["index.datalist.eigenvaluesOfA"] || "";
			title = title.slice(0, 1).toLocaleUpperCase() + title.slice(1) + (title !== "" ? ":" : "");
			html += '<p>' + title.replaceAll('`A`', '<math>' + Expression.p('A') + '</math>') + '</p>';
			html += '<ul>';
			var eigenvalues = Expression.getEigenvalues(matrix);
			for (var i = 0; i < eigenvalues.length; i += 1) {

				var x = eigenvalues[i];
				html += '<li>';
				html += '<math>' + Expression.p('λ_' + (i + 1) + '=x', {
					x: x
				}, printOptions) + '</math>';
				html += '</li>';
			}
			html += '</ul>';
			var detailsHTML = createDetailsSummary(printOptions.idPrefix, [{
				type: 'steps-to-find-eigenvalues',
				matrix: matrix.toString(),
				second: undefined
			}]);
			html += detailsHTML;
			return html;
		}
	});

	Expression.Details.add({
		type: "steps-to-find-eigenvalues",
		minRows: 1,
		callback: function (printOptions, matrix) {
			if (!matrix.isSquare()) {
				throw new RangeError("NonSquareMatrixException");
			}
			var html = "";
			html += "<ol>";
			var tmp = Expression.getEigenvaluesWithSteps(printOptions, matrix);
			var eigenvalues = tmp.eigenvalues;
			html += "<li>";
			html += tmp.html;
			html += "</li>";
			if (eigenvalues.length > 0) {
				html += "<li>";
				html += i18n['eigen.noRationalSolutions'];
				html += "</li>";
			}
			html += "</ol>";
			return html;
		}
	});

	var determinant3x3 = function (printOptions, matrix, text) {
		var containerId = printOptions.idPrefix + "-" + Expression.id();
		if (matrix.cols() !== 3 || matrix.rows() !== 3) {
			throw new RangeError("NonSquareMatrixException:" + i18n['matrix.error.sarrusOnly3x3']);
		}

		var matrixId = containerId;
		var cellId = function (i, j) {
			return matrixId + "_" + i.toString() + "_" + j.toString();
		};
		var higlights = "";
		var html = "";

		html += "<div class=\"math-block\">" + text + "</div>";
		html += "<math>";
		html += new Expression.Determinant(new Expression.Matrix(matrix)).toMathML(Object.assign({}, printOptions, {
			cellIdGenerator: function (i, j) {
				return cellId(i, j);
			}
		}));
		html += "<mo>=</mo>";
		html += "<mrow>";

		var z = ["a_11*a_22*a_33", "a_12*a_23*a_31", "a_13*a_21*a_32", "a_31*a_22*a_13", "a_32*a_23*a_11", "a_33*a_21*a_12"];
		var context = new ExpressionParser.Context(function (id) {
			return matrix.e(Number(id.slice(2, 3)) - 1, Number(id.slice(3, 4)) - 1);
		});
		var determinant = undefined;
		for (var i = 0; i < z.length; i += 1) {
			var e = ExpressionParser.parse(z[i], context);
			if (i !== 0) {
				var sign = i < 3 ? "+" : "&minus;";
				html += "<mo>" + sign + "</mo>";
			}
			var highlight = z[i].replace(/a_(\d)(\d)\*?/g, function (x, si, sj) {
				var i = Number(si) - 1;
				var j = Number(sj) - 1;
				return "#" + cellId(i, j) + ", ";
			}).slice(0, -2);
			html += "<mrow id=\"" + (matrixId + "_x" + i.toString()) + "\">";
			html += e.toMathML(Object.assign({}, printOptions, {
				isTopLevel: false
			}));
			html += "</mrow>";
			higlights += "<span class=\"a-highlight\" data-for=\"" + (matrixId + "_x" + i.toString()) + "\" data-highlight=\"" + highlight + "\"></span>";
			determinant = i === 0 ? e : i < 3 ? determinant.add(e) : determinant.subtract(e);
		}
		html += "</mrow>";
		html += "<mo>=</mo>";
		html += determinant.simplify().toMathML(printOptions);
		html += "</math>";
		html += '<div hidden>' + higlights + '</div>';
		return html;
	};

	Expression.Details.add({
		type: "determinant-Sarrus",
		i18n: function () {
			return i18n['matrix.rule.sarrus'];
		},
		minRows: 3,
		maxRows: 3,
		priority: 2,
		callback: function (printOptions, matrix) {
			return determinant3x3(printOptions, matrix, Expression.getSomeDetails("determinantSarrus"));
		}
	});

	Expression.Details.add({
		type: "determinant-Triangle",
		i18n: function () {
			return i18n['matrix.rule.triangle'];
		},
		minRows: 3,
		maxRows: 3,
		priority: 3,
		callback: function (printOptions, matrix) {
			return determinant3x3(printOptions, matrix, Expression.getSomeDetails("determinantTriangle"));
		}
	});

	Matrix.trimRight = function (x) {
		var lastColumn = -1;
		x.map(function (e, i, j) {
			if (lastColumn < j && !e.equals(Expression.ZERO)) {
				lastColumn = j;
			}
			return e;
		});
		return x.slice(0, x.rows(), 0, lastColumn + 1);
	};

	var outSystem = function (printOptions, matrix, variableNames) {
		return new Expression.Matrix(matrix).toMathML(Object.assign({}, printOptions, {
			variableNames: variableNames,
			useBraces: ["{", " "]
		}));
	};

	var makeDefaultVariableNames = function (count) {
		var variableNames = new Array(count);
		for (var i = 0; i < count; i += 1) {
			variableNames[i] = "x_" + (i + 1).toString();
		}
		return variableNames;
	};

	Expression.rowReduceChangeToHTML = function (change, printOptions, containerId, k, stepCondition) {
		var multiplier = change.type === "reduce" ? change.oldMatrix.e(change.targetRow, change.pivotColumn).divide(change.oldMatrix.e(change.pivotRow, change.pivotColumn)) : undefined;
		var areBracketsRequired = change.type === "reduce" ? multiplier.getPrecedence(multiplier) !== Expression.ZERO.getPrecedence() : undefined;
		var jT = "<code>" + localeString(change.targetRow + 1) + "</code>";
		var iT = "<code>" + localeString(change.pivotRow + 1) + "</code>";
		var tooltip = (change.type === "swap-negate" ? i18n['elimination.rowSwapNegate'].replace(/\$\{\-1\}/g, "<math>" + "<mo>&minus;</mo>" + Expression.p(1) + "</math>").replace(/\$\{j\}/g, jT).replace(/\$\{i\}/g, iT) : "") + (change.type === "swap" ? i18n['elimination.rowSwap'].replace(/\$\{j\}/g, jT).replace(/\$\{i\}/g, iT) : "") + (change.type === "divide" ? i18n['elimination.rowDivision'].replace(/\$\{a\}/g, "<code>" + "<math>" + change.oldMatrix.e(change.pivotRow, change.pivotColumn).toMathML(printOptions) + "</math>" + "</code>").replace(/\$\{j\}/g, jT).replace(/\$\{i\}/g, iT) : "") + (change.type === "reduce" ? i18n['elimination.rowSubtraction'].replace(/\$\{a\}/g, "<code>" + "<math>" + (areBracketsRequired ? "<mrow><mo>(</mo>" : "") + multiplier.toMathML(printOptions) + (areBracketsRequired ? "<mo>)</mo></mrow>" : "") + "</math>" + "</code>").replace(/\$\{j\}/g, jT).replace(/\$\{i\}/g, iT) : "");
		var text = "";
		var cellId = function (k, i, j) {
			return containerId + "-" + k.toString() + "-" + i.toString() + "-" + j.toString();
		};
		var questionId = containerId + "-" + k.toString() + "-" + "question-mark";
		k += 1;
		for (var i = 0; i < change.oldMatrix.cols(); i += 1) {
			if (change.type === "reduce" || change.type === "divide") {
				var highlight = "<span class=\"a-highlight\" data-for=\"" + cellId(k, change.targetRow, i) + "\" data-highlight=\"" + "#" + cellId(k - 1, change.pivotRow, change.pivotColumn) + ", " + "#" + cellId(k - 1, change.targetRow, i) + ", " + (change.type === "reduce" ? "#" + cellId(k - 1, change.targetRow, change.pivotColumn) + ", " : "") + (change.type === "reduce" ? "#" + cellId(k - 1, change.pivotRow, i) + ", " : "") + "#" + cellId(k, change.targetRow, i) + "\"></span>";
				text += "<span class=\"a-tooltip\" data-for=\"" + cellId(k, change.targetRow, i) + "\" hidden>" + "<math>" + Expression.p("a_(" + (change.targetRow + 1) + "," + (i + 1) + ")=" + (change.type === "reduce" ? "(b-(c/a)*d)" : "(b*(1/a))") + "=r", {
					a: change.oldMatrix.e(change.pivotRow, change.pivotColumn),
					b: change.oldMatrix.e(change.targetRow, i),
					c: change.oldMatrix.e(change.targetRow, change.pivotColumn),
					d: change.oldMatrix.e(change.pivotRow, i),
					r: change.newMatrix.e(change.targetRow, i)
				}, printOptions) + "</math>" + "</span>" + highlight;
			} else if (change.type === "swap" || change.type === "swap-negate") {
				text += "<span class=\"a-highlight\" data-for=\"" + cellId(k, change.targetRow, i) + "\" data-highlight=\"" + "#" + cellId(k - 1, change.pivotRow, i) + ", " + "#" + cellId(k - 1, change.targetRow, i) + ", " + "#" + cellId(k, change.targetRow, i) + "\"></span>";
				text += "<span class=\"a-highlight\" data-for=\"" + cellId(k, change.pivotRow, i) + "\" data-highlight=\"" + "#" + cellId(k - 1, change.targetRow, i) + ", " + "#" + cellId(k - 1, change.pivotRow, i) + ", " + "#" + cellId(k, change.pivotRow, i) + "\"></span>";
			}
		}
		var M = new Expression.Matrix(change.oldMatrix);
		return "<span class=\"nowrap\">" + "<math>" + (printOptions._isDeterminant ? new Expression.Determinant(M) : M).toMathML(Object.assign({}, printOptions, {
			columnlines: printOptions.columnlines,
			cellIdGenerator: function (i, j) {
				return cellId(k - 1, i, j);
			},
			pivotCell: change.type === "swap" || change.type === "swap-negate" ? undefined : {
				i: change.pivotRow,
				j: change.pivotColumn
			}
		})) + "</math>" + "<span class=\"arrow-with-label\" data-custom-paint=\"arrow-with-label\" data-type=\"" + change.type + "\" data-start=\"" + change.pivotRow + "\" data-end=\"" + change.targetRow + "\">" + "<div role=\"img\" class=\"arrow\">" + (change.type === "swap" || change.type === "swap-negate" || change.pivotRow < change.targetRow ? "<div class=\"arrow-head-bottom\"></div>" : "") + (change.type === "swap" || change.type === "swap-negate" || change.pivotRow > change.targetRow ? "<div class=\"arrow-head-top\"></div>" : "") + (change.type !== "divide" ? "<div class=\"arrow-line\"></div>" : "") + "</div>" + "<div class=\"label\">" + (change.type === "swap" ? "" : change.type === "swap-negate" ? "" : "<math>" + (change.type === "divide" ? "<mo>&times;</mo>" + "<mrow><mo>(</mo>" + Expression.ONE.divide(change.oldMatrix.e(change.targetRow, change.pivotColumn)).toMathML(printOptions) + "<mo>)</mo></mrow>" : "<mo>&times;</mo>" + "<mrow><mo>(</mo>" + multiplier.negate().toMathML(printOptions) + "<mo>)</mo></mrow>") + "</math>") + "</div>" + "</span>" + "</span>" + "<math>" + '<mrow style="margin: 0 0.4em;">' + "<mover accent=\"true\">" + (printOptions._isDeterminant ? "<mo>=</mo>" : "<munder accentunder=\"true\">" + "<mo stretchy=\"false\">" + "~" + "</mo>" + (stepCondition.isTrue() ? "" : "<munder accentunder=\"true\">") + "<mrow>" + ((change.type === "swap-negate" ? "${i}<mo>&harr;</mo><mrow><mo>&minus;</mo>${j}</mrow>" : "") + (change.type === "swap" ? "${i}<mo>&harr;</mo>${j}" : "") + (change.type === "divide" ? "${j}<mo>&#x2215;</mo><mrow><mo>(</mo>${a}<mo>)</mo></mrow><mo>&rarr;</mo>${j}".replace(/\$\{a\}/g, change.oldMatrix.e(change.pivotRow, change.pivotColumn).toMathML(printOptions)) : "") + (change.type === "reduce" ? "<mrow>${j}<mo>&minus;</mo><mrow>${a}<mo>&sdot;</mo>${i}</mrow></mrow><mo>&rarr;</mo>${j}".replace(/\$\{a\}/g, (areBracketsRequired ? "<mrow><mo>(</mo>" : "") + (printOptions.isLUDecomposition != undefined ? '<mrow style="background-color: #80FF80; color: #3C78C2;">' : "") + multiplier.toMathML(printOptions) + (printOptions.isLUDecomposition != undefined ? "</mrow>" : "") + (areBracketsRequired ? "<mo>)</mo></mrow>" : "")) : "")).replace(/\$\{j\}/g, getMatrixRowDenotation(change.targetRow + 1)).replace(/\$\{i\}/g, getMatrixRowDenotation(change.pivotRow + 1)) + "</mrow>" + (stepCondition.isTrue() ? "" : stepCondition.toMathML(printOptions)) + (stepCondition.isTrue() ? "" : "</munder>") + "</munder>" + "") + "<mtext>" + (

			tooltip !== "" ? "<span class=\"question-icon-new\" id=\"" + questionId + "\">?</span><span class=\"a-tooltip\" data-for=\"" + questionId + "\" hidden>" + tooltip + "</span>" : "") + (text !== "" ? "<span hidden>" + text + "</span>" : "") + "</mtext>" + "</mover>" + "</mrow>" + "</math>";
	};

	Expression.rowReductionGaussJordanMontante = function (matrix, method, usage, printOptions, resultCallback, flag0) {
		flag0 = flag0 == undefined ? false : flag0;
		var containerId = printOptions.idPrefix + "-" + Expression.id();
		var html = "";
		var k = 0;
		html += "<div class=\"math-block\">";
		var outputTailMatrix = function (stoppedAtRow, matrix) {
			html += "<math>";
			html += new Expression.Matrix(matrix).toMathML(Object.assign({}, printOptions, {
				cellIdGenerator: function (i, j) {
					return containerId + "-" + k.toString() + "-" + i.toString() + "-" + j.toString();
				},
				highlightRow: stoppedAtRow
			}));
			html += "</math>";
			html += "</div>";
			k += 1;
		};

		var oldCondition = Condition.TRUE;

		var result = matrix.toRowEchelonXXX(method, usage, function (change) {

			var stepCondition = Condition.TRUE;
			if (usage !== "determinant" && usage !== "inverse") {

				var pivot = change.oldMatrix.e(change.pivotRow, change.pivotColumn);
				stepCondition = Condition.TRUE.andNotZero(pivot);
				if (!stepCondition.isTrue()) {

					oldCondition = oldCondition.andNotZero(pivot);
				}
			}

			var rowReduceChangeToHTML = method === Matrix.GaussMontante ? Expression.rowReduceChangeToHTMLMontante : Expression.rowReduceChangeToHTML;
			html += rowReduceChangeToHTML(change, printOptions, containerId, k, stepCondition);
			k += 1;
		}, usage !== "determinant" && usage !== "inverse" && !flag0 ? Condition.TRUE : undefined);
		var w = function (result) {
			if (result.c1 == undefined && result.c2 == undefined) {
				outputTailMatrix(result.stoppedAtRow, result.matrix);
				html += resultCallback({
					matrix: result.matrix,
					stoppedAtRow: result.stoppedAtRow,
					condition: flag0 ? oldCondition : result.condition
				});
			} else {
				outputTailMatrix(-1, result.matrix);
				html += "<ol>";
				html += "<li>";
				html += "<div>";
				html += "<math>";
				html += result.c1.toMathML(printOptions);
				html += "</math>";
				html += "</div>";
				html += "<div>";
				w(result.a1());
				html += "</li>";
				html += "<li>";
				html += "<div>";
				html += "<math>";
				html += result.c2.toMathML(printOptions);
				html += "</math>";
				html += "</div>";
				html += "<div>";
				w(result.a2());
				html += "</li>";
				html += "</ol>";
			}
		};
		w(result);
		return html;
	};

	Expression.solveByGaussNext = function (ms, printOptions, variableNames) {
		var condition = ms.condition;
		var m = ms.matrix;

		if (condition != undefined) {
			m = m.map(function (e, i, j) {

				return condition.updateExpression(e, {
					flag1: true
				});
			});
		}

		var noSolutions = ms.stoppedAtRow !== -1;

		if (variableNames == undefined) {
			variableNames = makeDefaultVariableNames(m.cols() - 1);
		}
		if (noSolutions) {
			return {
				html: "<div>" + "<math>" + outSystem(printOptions, m, variableNames) + "</math>" + "</div>" + "<div>" + i18n['system.noSolutions'] + "</div>"
			};
		}
		var isHomogeneous = function (m) {
			for (var i = 0; i < m.rows(); i += 1) {
				if (!m.e(i, m.cols() - 1).equals(Expression.ZERO)) {
					return false;
				}
			}
			return true;
		};

		var containerId = printOptions.idPrefix + "-" + Expression.id();
		var systemId = containerId + "-" + "system_1";
		var mstr = "";
		if (!m.eql(Matrix.Zero(m.rows(), m.cols()))) {
			mstr += "<div class=\"anchor\">" + "<table role=\"presentation\" class=\"system-table\">" + "<tr>" + "<td>" + "<math>" + outSystem(printOptions, m, variableNames) + "</math>" + "</td>" + "</tr>" + "</table>" + "</div>";
		}
		var isEquals = function (a, b) {
			if (a.length !== b.length) {
				return false;
			}
			for (var i = 0; i < a.length; i += 1) {
				if (!(a[i] instanceof NonSimplifiedExpression) || !(b[i] instanceof NonSimplifiedExpression)) {
					throw new TypeError();
				}
				if (!a[i].e.equals(b[i].e)) {

					return false;
				}
			}
			return true;
		};
		var nsVariableNames = new Array(m.cols() - 1);
		for (var i = 0; i < m.cols() - 1; i += 1) {
			nsVariableNames[i] = new NonSimplifiedExpression(new Expression.Symbol(variableNames[i]));
		}
		mstr += "<ul>";
		m = Matrix.solveByGaussNext(m, function (m, oldMatrix1, oldMatrix2, i, j) {

			mstr += "<li>";
			mstr += "<div>";
			mstr += i18n['system.findVariableFromEquation'].replace(/\$\{i\}/g, "<math>" + Expression.p(i + 1) + "</math>").replace(/\$\{x\}/g, "<math>" + new Expression.Symbol(variableNames[j]).toMathML(printOptions) + "</math>");
			mstr += "</div>";
			mstr += "<div>";

			var equationSymbols1 = new Array(m.cols() - 1);
			var equationSymbols2 = new Array(m.cols() - 1);
			for (var k = 0; k < m.cols() - 1; k += 1) {
				var v = new NonSimplifiedExpression(nsVariableNames[k].e);
				equationSymbols1[k] = v;
				equationSymbols2[k] = v;
				if (k > j && !oldMatrix1.e(i, k).equals(Expression.ZERO)) {
					var pivotRowK = Matrix.getPivotRow(oldMatrix1, k);
					var y = pivotRowK === -1 ? v : new NonSimplifiedExpression(polynomialToExpression3(oldMatrix1, pivotRowK, nsVariableNames));
					equationSymbols2[k] = y;
				}
			}
			mstr += "<math>";
			var leftPartCoefficient = oldMatrix1.e(i, j);
			var leftPartVariable = new Expression.Symbol(variableNames[j]);
			var leftPart = leftPartCoefficient.equals(Expression.ONE) ? leftPartVariable : new Expression.Multiplication(leftPartCoefficient, leftPartVariable);
			mstr += leftPart.toMathML(printOptions);
			mstr += "<mo>=</mo>";
			var beforeSubstitution = polynomialToExpression3(oldMatrix1, i, equationSymbols1).toMathML(Object.assign({}, printOptions, {
				printId: true
			}));
			mstr += beforeSubstitution;
			var afterSubstitution = polynomialToExpression3(oldMatrix1, i, equationSymbols2).toMathML(Object.assign({}, printOptions, {
				printId: true
			}));
			if (!isEquals(equationSymbols1, equationSymbols2)) {
				mstr += "<mo>=</mo>";
				mstr += afterSubstitution;
			}
			var afterSimplification = polynomialToExpression3(oldMatrix2, i, nsVariableNames).toMathML(printOptions);
			if (!isEquals(equationSymbols2, nsVariableNames)) {
				mstr += "<mo>=</mo>";
				mstr += afterSimplification;
			}
			mstr += "</math>";
			mstr += "<div hidden>";
			for (var k = 0; k < nsVariableNames.length; k += 1) {
				if (!equationSymbols2[k].e.equals(nsVariableNames[k].e)) {
					mstr += "<span class=\"a-highlight\" data-for=\"" + equationSymbols2[k].getId() + "\" data-highlight=\"" + equationSymbols1[k].getId() + "\"></span>";
				}
			}
			mstr += "</div>";
			var afterDivision = polynomialToExpression3(m, i, nsVariableNames).toMathML(printOptions);
			if (!oldMatrix2.e(i, j).equals(Expression.ONE)) {
				mstr += "<div>";

				mstr += "<math>";
				mstr += "<mrow style=\"font-weight: bolder\">";
				mstr += new Expression.Symbol(variableNames[j]).toMathML(printOptions);
				mstr += "<mo>=</mo>";
				mstr += afterDivision;
				mstr += "</mrow>";
				mstr += "</math>";

				mstr += "</div>";
			}
			mstr += "</div>";
			mstr += "</li>";
		});
		mstr += "</ul>";
		var solutionsExpressions = new Array(m.cols() - 1);
		for (var i = 0; i < m.cols() - 1; i += 1) {
			solutionsExpressions[i] = Matrix.getPivotRow(m, i) === -1 ? nsVariableNames[i] : new NonSimplifiedExpression(polynomialToExpression3(m, Matrix.getPivotRow(m, i), nsVariableNames));
		}
		var solutionsExpressionsData = new Array(1);
		solutionsExpressionsData[0] = solutionsExpressions;
		var solutionsExpressionsMatrix = new Matrix(solutionsExpressionsData).transpose();
		if (true) {
			mstr += "<div>" + i18n['system.answer'] + "</div>";
			if (condition != undefined && !condition.isTrue()) {
				mstr += "<div class=\"like-table\">";
				mstr += "<div>";
			}
			mstr += "<ul class=\"list-unstyled\">";
			for (var i = 0; i < m.cols() - 1; i += 1) {
				mstr += "<li>";
				mstr += "<math>";
				mstr += new Expression.Symbol(variableNames[i]).toMathML(printOptions) + "<mo>=</mo>" + solutionsExpressions[i].toMathML(printOptions);
				mstr += "</math>";
				mstr += "</li>";
			}
			mstr += "</ul>";

			if (condition != undefined && !condition.isTrue()) {
				mstr += "</div>";
				mstr += "<div>";
				mstr += "<math>";
				mstr += "<mrow><mo>(</mo>";
				mstr += condition.toMathML(printOptions);
				mstr += "<mo>)</mo></mrow>";
				mstr += "</math>";
				mstr += "</div>";
				if (typeof hit === "function") {
					hit({
						condition: condition.toString() + "::" + m.toString()
					});
				}
				mstr += "</div>";
			}

		}

		if (true) {

			mstr += "<div>" + i18n['system.generalSolution'] + " " + "<math>" + "<mi>X</mi><mo>=</mo>" + new Expression.Matrix(solutionsExpressionsMatrix).toMathML(printOptions) + "</math>" + "</div>";
		}
		if (isHomogeneous(m)) {
			var solutionSet = Matrix.getSolutionSet(m);

			if (solutionSet.basisVectors.length > 0) {
				var fundamentalSystemHTML = '';
				fundamentalSystemHTML += '<math>';
				fundamentalSystemHTML += '<mrow>';
				fundamentalSystemHTML += '<mo stretchy="false">{</mo>';
				fundamentalSystemHTML += solutionSet.basisVectors.length !== 1 ? '<mrow>' : '';
				for (var i = 0; i < solutionSet.basisVectors.length; i += 1) {
					var basisVector = new Expression.Matrix(solutionSet.basisVectors[i]);
					var freeVariable = nsVariableNames[solutionSet.variables[i]];
					fundamentalSystemHTML += i !== 0 ? '<mo>+</mo>' : '';
					fundamentalSystemHTML += '<mrow>' + freeVariable.toMathML(printOptions) + '<mo>&sdot;</mo>' + basisVector.toMathML(printOptions) + '</mrow>';
				}
				fundamentalSystemHTML += solutionSet.basisVectors.length !== 1 ? '</mrow>' : '';
				fundamentalSystemHTML += '<mo stretchy="false">}</mo>';
				fundamentalSystemHTML += '</mrow>';
				fundamentalSystemHTML += '</math>';
				mstr += '<div>' + i18n['system.fundamentalSolution'] + ' ' + fundamentalSystemHTML + '</div>';
			}
		}
		return {
			html: mstr
		};
	};

	Polynomial.toM1 = function (c, np, roots) {
		var e = undefined;
		if (!c.equals(Expression.ONE)) {
			if (!c.equals(Expression.ONE.negate())) {
				c = new NonSimplifiedExpression(c);
			}
			e = e != undefined ? new Expression.Multiplication(e, c) : c;
		}
		if (np.getDegree() === 0) {
			var x = np.getCoefficient(0);
			if (!x.equals(Expression.ONE)) {
				e = e != undefined ? new Expression.Multiplication(x, e) : x;
			}
		}

		var multiplicity = 1;
		for (var i = 0; i < roots.length; i += 1) {
			var next = i < roots.length ? roots[i + 1] : null;
			if (roots[i] !== next) {
				var p = Polynomial.of(roots[i].negate(), Expression.ONE);
				var w = new Expression.Polynomial(p);
				if (multiplicity !== 1) {
					w = new Expression.Exponentiation(w, Expression.Integer.fromNumber(multiplicity));
				}
				e = e != undefined ? new Expression.Multiplication(e, w) : w;
				multiplicity = 1;
			} else {
				multiplicity += 1;
			}
		}
		if (roots.length === 0 || np.getDegree() !== 0) {

			var w = new Expression.Polynomial(np);
			e = e != undefined ? new Expression.Multiplication(e, w) : w;

		}

		return e;
	};

	var polynomialRootsCallback = function (info, printOptions) {
		var result = "";

		if (info.type === "eliminationOfTheSubDominantTerm") {
			var tmp = Expression.p("x=t-b/(n*a)", {
				b: info.b,
				n: Expression.Integer.fromNumber(info.n),
				a: info.a
			}, printOptions);
			result = '<munder accentunder="true"><mo>=</mo><munder accentunder="true"><mrow>' + tmp + '</mrow><mtext></mtext></munder></munder>';
		}
		if (info.type === "realRootIsolationAndNewton'sMethod") {
			result = "<munder accentunder=\"true\"><mo>&asymp;</mo></munder>";
		}

		if (result === "") {
			if (info.type === "t = x^g" || (info.type === "applyDifferenceOfSquaresRule" || info.type === "applyDifferenceOfCubesRule" || info.type === "applyDifferenceOfNthPowersRule")) {
				var variableName = printOptions.polynomialVariable;
				result += "<munder accentunder=\"true\"><mo>=</mo><mrow><mi>t</mi><mo>=</mo><msup><mi>${x}</mi><mn>${g}</mn></msup></mrow></munder>".replace(/\$\{x\}/g, variableName).replace(/\$\{g\}/g, localeString(info.g));
			}
			else {
				result += "<mo>=</mo>";
			}
		}

		result += Polynomial.toM1(info.content, info.newPolynomial, info.roots).toMathML(Object.assign({}, printOptions, info.newPolynomialVariable != undefined ? { polynomialVariable: info.newPolynomialVariable } : {}));

		return result;
	};

	Expression.getEigenvaluesWithSteps = function (printOptions, matrix) {
		var variableName = "λ";
		var lambda = new Expression.Symbol(variableName);
		printOptions = Object.assign({}, printOptions, {
			polynomialVariable: lambda
		});
		var characteristicPolynomial = null;
		var steps = "";
		var eigenvalues = Expression.getEigenvalues(matrix, function (info) {
			if (characteristicPolynomial == null) {
				characteristicPolynomial = info;
			} else {
				steps += polynomialRootsCallback(info, printOptions);
			}
		});

		var html = "";

		var matrixWithLambdas = matrix.map(function (element, i, j) {
			return new NonSimplifiedExpression(i === j ? new Expression.Addition(new NonSimplifiedExpression(element), new Expression.Negation(lambda)) : element);
		});
		var args = {
			v: new Expression.MatrixSymbol('v'),
			A: new Expression.MatrixSymbol('A')
		};
		var mathml = function (s) {
			return s.replace(/\$\{([^\}]+)\}/g, function (p, s) {
				return '<math' + (/[\*\-]/.test(s) ? ' display="block"' : '') + '>' + Expression.p(s.replace(/I/g, i18n['matrix.identity.notation']), args, {}) + '</math>';
			});
		};
		html += "<div>";
		html += mathml(i18n['eigen.definition']);
		html += "</div>";
		html += "<div>";
		html += i18n['math.exponential.then'];
		html += mathml("${A*v-λ*v=(A-λI)*v=0}");
		html += "</div>";
		html += "<div>";
		html += mathml(i18n['eigen.nonZeroSolutionCondition']);
		html += "</div>";
		html += "<div>";
		html += "<math>";
		html += Expression.p("|(A-λI)|".replace(/I/g, i18n['matrix.identity.notation']), args, {});
		html += "<mo>=</mo>";
		html += new Expression.Determinant(new Expression.Matrix(matrixWithLambdas)).toMathML(printOptions) + "<mo>=</mo>" + characteristicPolynomial.toMathML(printOptions);
		html += steps;
		html += "<mo>=</mo>";
		html += Expression.p(0);
		html += "</math>";
		html += "</div>";

		html += createDetailsSummary(printOptions.idPrefix, [{
			type: "determinant",
			matrix: matrixWithLambdas.toString(),
			second: undefined
		}]);

		html += "<ol>";
		var n = -1;
		var uniqueEigenvalues = Expression.unique(eigenvalues);
		while (++n < uniqueEigenvalues.length) {
			var eigenvalue = uniqueEigenvalues[n];
			var equalsMathML = "<mo>" + (eigenvalue.isExact() ? "=" : "&asymp;") + "</mo>";

			html += "<li>";
			html += "<math>";
			html += Expression.p("λ_" + (n + 1));
			html += equalsMathML;
			html += eigenvalue.toMathML(printOptions);
			html += "</math>";
			html += "</li>";
		}
		html += "</ol>";
		return {
			eigenvalues: eigenvalues,
			html: html
		};
	};

	Expression.getEigenvectorsWithSteps = function (printOptions, matrix, eigenvalues) {
		var eigenvectors = [];
		var html = "";
		html += "<div>";
		html += i18n['eigen.findForEachValue'].replaceAll('${λ}', '<math>' + Expression.p('λ') + '</math>');
		html += "</div>";
		html += "<ol>";
		for (var i = 0; i < eigenvalues.length; i += 1) {
			html += "<li>";
			var mm = matrix.subtract(Matrix.I(matrix.cols()).scale(eigenvalues[i]));
			var fullMatrix = mm.augment(Matrix.Zero(mm.cols(), 1));
			var equalsMathML = "<mo>" + (eigenvalues[i].isExact() ? "=" : "&asymp;") + "</mo>";
			var args = {
				v: new Expression.MatrixSymbol('v'),
				A: new Expression.MatrixSymbol('A')
			};

			html += "<div class=\"anchor\" id=\"" + (printOptions.idPrefix + "-eigenvalue-" + (i + 1)) + "\">";
			html += "<math>";
			html += new Expression.Symbol('λ_' + (i + 1)).toMathML(printOptions);
			html += equalsMathML;
			html += eigenvalues[i].toMathML(printOptions);
			html += "</math>";
			html += "</div>";

			html += "<div>";
			html += "<math>";
			html += Expression.p("A-λ_i*I".replace(/i/g, (i + 1).toString()).replace(/I/g, i18n['matrix.identity.notation']), args, {}).replace(/&times;/g, '&sdot;');
			html += equalsMathML;
			html += new Expression.Matrix(mm).toMathML(printOptions);
			html += "</math>";
			html += "</div>";

			html += "<div>";
			html += "<math>" + Expression.p("A*v=λ*v", args, {}) + "</math>";
			html += " ";
			html += "";
			html += "</div>";

			html += "<div>";
			html += "<math>" + Expression.p("(A-λ*I)*v=0".replace(/I/g, i18n['matrix.identity.notation']), args, {}).replace(/&times;/g, '&sdot;') + "</math>";
			html += "</div>";
			html += "<div>";

			html += i18n['eigen.homogeneousSystem'];
			html += "</div>";

			var variableNames = makeDefaultVariableNames(fullMatrix.cols() - 1);
			var solutionSet = undefined;
			var solutionHTML = "";
			solutionHTML += Expression.rowReductionGaussJordanMontante(fullMatrix, Matrix.GaussJordan, "solving", Object.assign({}, printOptions, {
				columnlines: -1
			}), function (result) {
				var tmp = Expression.solveByGaussNext(result, printOptions, variableNames);
				solutionSet = Matrix.getSolutionSet(result.matrix);
				return tmp.html;
			}, true);
			html += "<div>" + solutionHTML + "</div>";
			html += "<div>";
			for (var j = 0; j < solutionSet.basisVectors.length; j += 1) {
				var eigenvector = solutionSet.basisVectors[j];
				eigenvectors.push(eigenvector);
				var index = eigenvectors.length;

				html += j !== 0 ? "; " : "";
				html += i18n['eigen.letAssumption'];
				html += " ";
				for (var k = 0; k < solutionSet.variables.length; k += 1) {
					html += k !== 0 ? ", " : "";
					html += "<math>";
					html += new Expression.Symbol(variableNames[solutionSet.variables[k]]).toMathML(printOptions) + "<mo>=</mo>" + Expression.p(k === j ? 1 : 0);
					html += "</math>";
				}
				html += ", ";
				html += "<span class=\"inline-block anchor\" id=\"" + (printOptions.idPrefix + "-eigenvector-" + index) + "\">";
				html += "<math>";
				html += "<mrow style=\"font-weight: bolder\">";
				html += Expression.p("v_0=V", {
					v_0: new Expression.MatrixSymbol('v_' + index),
					V: new Expression.Matrix(eigenvector)
				}, printOptions);
				html += "</mrow>";
				html += "</math>";
				html += "</span>";
			}
			html += "</div>";
			html += "</li>";
		}
		html += "</ol>";
		return {
			html: html,
			eigenvectors: eigenvectors
		};
	};

	ExpressionParser.getPositionInfo = function () {
		return {
			input: ExpressionParser.input,
			startPosition: ExpressionParser.startPosition,
			endPosition: ExpressionParser.endPosition,
			p: ExpressionParser.p
		};
	};

	ExpressionParser.getMatrix = function (s) {

		if (/[\t\n\r]/.test(s.trim().replace(/([\}\\])\s*[\r\n]+/g, '$1').replace(/[\r\n]+\s*([\\])/g, '$1'))) {

			var elements = Matrix.split(s.trim());
			try {
				var matrix = Matrix.toMatrix(elements);
				if (matrix.rows() === 1 && matrix.cols() === 1 && matrix.e(0, 0).unwrap() instanceof Expression.Matrix) {
					matrix = matrix.e(0, 0);
					elements = elements[0][0];
				}
			} catch (error) {
				console.error(error);
			}

			return {
				elements: elements,
				variableNames: undefined
			};
		}

		var table = getTableFromAsciiMathMatrix(s);
		if (table != null) {
			return {
				elements: table,
				variableNames: undefined
			};
		}

		if (/[&\\]/.test(s) && !/^\s*\\*begin|\s*■/.test(s)) {
			var elements = Matrix.split(s.replaceAll('&', ' ').replaceAll('\\', '\n'));
			return {
				elements: elements,
				variableNames: undefined
			};
		}

		var result = undefined;
		try {
			result = ExpressionParser.parse(s, new ExpressionParser.Context());

		} catch (error) {

			throw error;
		}

		var matrix = result instanceof Matrix ? result : result instanceof Expression.Matrix ? result.matrix : result instanceof NonSimplifiedExpression && result.e instanceof Expression.Matrix ? result.e.matrix : undefined;

		var elements = null;
		if (matrix != null) {
			elements = [];
			for (var i = 0; i < matrix.rows(); i += 1) {
				var row = [];
				for (var j = 0; j < matrix.cols(); j += 1) {
					row.push(matrix.e(i, j).toString());
				}
				elements.push(row);
			}
		}
		return {
			elements: elements,
			variableNames: undefined
		};
	};

	ExpressionParser.p = 0;

	ExpressionParser.checkExpressions = function (textareaValue, type) {
		var resultRows = undefined;

		if (resultRows == undefined) {
			resultRows = Matrix.split(textareaValue);
		}
		var elements = resultRows;
		ExpressionParser.p = 0;
		for (var i = 0; i < elements.length; i += 1) {
			for (var j = 0; j < elements[i].length; j += 1) {
				var value = elements[i][j];

				var isValid = ExpressionParser.checkExpression(value || "0");
				if (!isValid) {
					return false;
				}
				ExpressionParser.p += value.length;
			}
		}
		return true;
	};

	ExpressionParser.checkExpression = function (input) {

		return ExpressionParser.parse(input, new ExpressionParser.Context()) != undefined;
	};

	ExpressionParser.runExpression = function (input, kInputValue, kInputId, matrixTableStates, printOptions) {

		var details = [];
		var listener = function (e) {
			details.push({
				type: e.type,
				matrix: e.data.matrix.toString(),
				second: e.second == undefined ? undefined : e.second.matrix.toString()
			});
		};
		Expression.callback = listener;
		var x = undefined;

		var variableNames = undefined;
		var resultError = undefined;
		var expressionString = undefined;
		var resultHTML = undefined;
		var resultMatrix = undefined;
		try {

			var test = input.replace(/\s+/g, "");
			if (test === "A*X=B" || test === "AX=B" || test === "Ax=b") {
				test = "A*X=B";
			}
			if (test === "A*X=0" || test === "AX=0") {
				test = "A*X=0";
			}
			var matrixTableAState = matrixTableStates != undefined ? matrixTableStates["A"] : undefined;
			var matrixTableBState = matrixTableStates != undefined ? matrixTableStates["B"] : undefined;
			if (test === "A*X=B" && matrixTableAState != undefined && matrixTableBState != undefined || test === "A*X=0" && matrixTableAState != undefined) {

				var a0 = Matrix.toMatrix(ExpressionParser.getElementsArray(matrixTableAState).elements);
				var b0 = test !== "A*X=B" ? Matrix.Zero(a0.rows(), 1) : Matrix.toMatrix(ExpressionParser.getElementsArray(matrixTableBState).elements);

				if (b0.rows() === a0.rows() && b0.cols() === 1) {
					input = "solve-using-Montante-method(" + a0.augment(b0).toString() + ")";
				}
			}
			if (input.replace(/^\s+|\s+$/g, "") === "") {
				throw new RangeError("ValueMissingError:" + "expression");
			}
			x = ExpressionParser.parse(input, new ExpressionParser.Context(function (id) {
				if ((id === "k" || id === "K") && kInputValue != undefined) {
					var value = kInputValue;
					if (value.replace(/^\s+|\s+$/g, "") === "") {
						throw new RangeError("ValueMissingError:" + kInputId);
					}
					return ExpressionParser.parse(value, new ExpressionParser.Context());
				}
				if (id === "X" || id === "Y") {
					return new Expression.MatrixSymbol(id);
				}
				var matrixTableState = matrixTableStates != undefined && Object.prototype.hasOwnProperty.call(matrixTableStates, id) ? matrixTableStates[id] : undefined;
				if (matrixTableState == undefined) {
					return undefined;
				}
				var tmp = ExpressionParser.getElementsArray(matrixTableState);
				if (tmp.elements.length === 0) {
					throw new RangeError("ValueMissingError:" + matrixTableState.firstInputElementId);
				}
				var names = tmp.variableNames;
				var matrix = Matrix.toMatrix(tmp.elements);
				variableNames = names;
				return new Expression.Matrix(matrix);
			}));

			var tmp = getResultAndHTML(x, variableNames, x.simplify(), printOptions);
			var result = tmp.result;
			resultHTML = tmp.html;
			var matrix = undefined;
			if (result instanceof Matrix) {
				matrix = result;
			} else if (result instanceof Expression.Matrix) {
				matrix = result.matrix;
			} else if (result instanceof NonSimplifiedExpression && result.e instanceof Expression.Matrix) {
				matrix = result.e.matrix;
			} else if (result instanceof Expression.Equality && result.b instanceof Expression.Matrix) {

				matrix = result.b.matrix;
			}
			resultMatrix = matrix != undefined ? matrix.toString() : "";
			expressionString = x.toString();
		} catch (error) {
			resultError = error;
		}
		Expression.callback = undefined;
		var detailsHTML = createDetailsSummary(printOptions == null ? "g" : printOptions.idPrefix, details, details.length === 1 ? 100 : 1);
		return {
			resultError: resultError,
			details: details,
			expressionString: expressionString,
			resultHTML: resultHTML,
			resultMatrix: resultMatrix,
			detailsHTML: detailsHTML
		};
	};

	ExpressionParser.getDetails = function (data, printOptions) {
		var callback = Expression.Details.getCallback(data.type);
		if (callback == undefined) {
			throw new Error(data.type);
		}
		var matrix = ExpressionParser.parse(data.matrix).matrix;
		var second = data.second != undefined ? ExpressionParser.parse(data.second).matrix : undefined;
		var html = callback(printOptions, matrix, second);
		return html;
	};

	self.onmessage = function (event) {
		const { id, name, args } = event.data;

		if (id === undefined || !name || !args) {
			console.error("Worker received invalid message format:", event.data);
			if (id !== undefined) {
				self.postMessage({ id: id, result: undefined, error: { message: "Invalid message format" } });
			}
			return;
		}

		let result = undefined;
		let error = undefined;

		try {
			if (name === 'runExpression') {
				result = ExpressionParser.runExpression(...args);
			}
			else {
				console.warn(`Worker received unknown command: ${name}`);
				error = { message: `Unknown command: ${name}` };
			}
		} catch (e) {
			console.error(`Worker error executing ${name}:`, e);
			error = { message: e.message, name: e.name, stack: e.stack };
		}

		self.postMessage({ id: id, result: result, error: error });
	};

	console.log("Math Worker ready.");
}

function LinearSystems() {
	Expression.rowReduceChangeToHTMLMontante = function (args, printOptions, containerId, k, stepCondition) {
		var tooltipId = 'tooltip-' + containerId + '-' + k;
		var t = function (r, c, k) {
			var det = new Expression.Determinant(new Expression.Matrix(Matrix.I(2).map(function (e, i, j) {
				var matrix = [['a_(pivotRow,pivotColumn)', 'a_(pivotRow,j)'], ['a_(i,pivotColumn)', 'a_(i,j)']];
				return new Expression.Symbol(matrix[i][j].replaceAll('pivotRow', r + 1).replaceAll('pivotColumn', c + 1));
			}))).toMathML({
				useMatrixContainer: false
			});
			return "<mrow>" + "<mfrac>" + '<mrow id="' + tooltipId + '">' + det + '</mrow>' + new Expression.Symbol('p_${k}'.replaceAll('${k}', k + 1).replaceAll('p_0', '1')).toMathML() + "</mfrac>" + "<mo>&rarr;</mo>" + new Expression.Symbol('a_(i,j)').toMathML() + "</mrow>";
		};
		var cellId = function (matrixId, i, j) {
			return containerId + "-" + matrixId + "-" + i + "-" + j;
		};
		var html = "";
		if (true) {
			if (args.type === "swap" || args.type === "swap-negate") {
				html += Expression.rowReduceChangeToHTML(args, printOptions, containerId, k, stepCondition);
			} else if (args.type === "pivot") {
				var a0 = new Expression.Matrix(args.oldMatrix).toMathML(Object.assign({}, printOptions, {
					columnlines: printOptions.columnlines,
					cellIdGenerator: function (i, j) {
						return cellId(k, i, j);
					},
					pivotCell: {
						i: args.pivotRow,
						j: args.pivotColumn
					}
				}));
				var pivotElementText = '<mrow style="margin: 0 0.4em;">' + "<munder accentunder=\"true\">" + "<mo stretchy=\"false\">~</mo>" + "<munder accentunder=\"true\">" + "<mtext>" + i18n['elimination.pivotElement'] + "</mtext>" + "<munder accentunder=\"true\">" + "<mrow>" + new Expression.Symbol("p_" + (k + 1)).toMathML() + "<mo>=</mo>" + new Expression.Symbol("a_(" + (args.pivotRow + 1) + "," + (args.pivotColumn + 1) + ")").toMathML() + "<mo>=</mo>" + args.oldMatrix.e(args.pivotRow, args.pivotColumn).toMathML(printOptions) + "</mrow>" + (stepCondition.isTrue() ? "" : "<munder accentunder=\"true\">") + t(args.pivotRow, args.pivotColumn, k - 1) + (stepCondition.isTrue() ? "" : stepCondition.toMathML(printOptions)) + (stepCondition.isTrue() ? "" : "</munder>") + "</munder>" + "</munder>" + "</munder>" + "</mrow>";
				html += "<math>";
				html += a0 + pivotElementText;
				html += "</math>";
				k += 1;
				var text = "";
				var tooltip = '<span class="a-tooltip" data-for="' + tooltipId + '" hidden>' + "<math>" + Expression.p("(a_(pivotRow,pivotColumn)*a_(i,j)-a_(i,pivotColumn)*a_(pivotRow,j))".replaceAll('pivotRow', (args.pivotRow + 1).toString()).replaceAll('pivotColumn', (args.pivotColumn + 1).toString())) + "</math>" + '</span>';
				text += tooltip;
				for (var targetRow = 0; targetRow < args.oldMatrix.rows(); targetRow += 1) {
					if (targetRow !== args.pivotRow) {
						text += "<div>";
						for (var i = 0; i < args.oldMatrix.cols(); i += 1) {
							var highlight = "<span class=\"a-highlight\" data-for=\"" + cellId(k, targetRow, i) + "\" data-highlight=\"" + "#" + cellId(k - 1, args.pivotRow, args.pivotColumn) + ", " + "#" + cellId(k - 1, targetRow, i) + ", " + "#" + cellId(k - 1, targetRow, args.pivotColumn) + ", " + "#" + cellId(k - 1, args.pivotRow, i) + ", " + "#" + cellId(k, targetRow, i) + "\"></span>";
							text += "<span class=\"a-tooltip\" data-for=\"" + cellId(k, targetRow, i) + "\" hidden>" + "<math>" + Expression.p("a_(" + (targetRow + 1) + "," + (i + 1) + ")=(a*b-c*d)/p=r", {
								a: args.oldMatrix.e(args.pivotRow, args.pivotColumn),
								b: args.oldMatrix.e(targetRow, i),
								c: args.oldMatrix.e(targetRow, args.pivotColumn),
								d: args.oldMatrix.e(args.pivotRow, i),
								p: args.previousPivot,
								r: args.newMatrix.e(targetRow, i)
							}, printOptions) + "</math>" + "</span>" + highlight;
						}
						text += "</div>";
					}
				}
				html += "<span hidden>" + text + "</span>";
			} else {
				throw new TypeError(args.type);
			}
		}

		return html;
	};

	var getDeterminantDetails = function (printOptions, matrix, method, title, header) {
		if (!matrix.isSquare()) {
			throw new RangeError("NonSquareMatrixException");
		}
		var html = "";
		html += "<div>";
		html += "<math>";
		html += new Expression.Determinant(new Expression.Matrix(matrix)).toMathML(printOptions) + "<mo>=</mo><mi>?</mi>";
		html += "</math>";
		html += "</div>";

		if (header != undefined) {
			html += "<h4>";
			html += header;
			html += "</h4>";
		}
		html += "<p>" + title + "</p>";
		html += Expression.rowReductionGaussJordanMontante(matrix, method, "determinant", printOptions, function (tmp) {
			var rowEchelonMatrix = tmp.matrix;
			var html = "";
			html += "<div>";
			html += "<math>";
			html += new Expression.Determinant(new Expression.Matrix(matrix)).toMathML(printOptions);
			html += "<mo>=</mo>";
			if (method === Matrix.Gauss) {
				html += new Expression.Determinant(new Expression.Matrix(rowEchelonMatrix)).toMathML(printOptions);
				html += "<mo>=</mo>";
				var result = rowEchelonMatrix.determinant();
				if (!result.equals(Expression.ZERO)) {
					var det = rowEchelonMatrix.e(0, 0);
					det = new NonSimplifiedExpression(det);
					for (var j = 1; j < rowEchelonMatrix.rows(); j += 1) {
						det = new Expression.Multiplication(det, rowEchelonMatrix.e(j, j));
						det = new NonSimplifiedExpression(det);
					}
					html += det.toMathML(printOptions);
					html += "<mo>=</mo>";
				}
				html += result.toMathML(printOptions);
			} else {
				var result = tmp.stoppedAtRow !== -1 ? Expression.ZERO : rowEchelonMatrix.e(rowEchelonMatrix.rows() - 1, rowEchelonMatrix.cols() - 1);
				html += result.toMathML(printOptions);
			}
			html += "</math>";
			html += "</div>";
			return html;
		});
		return html;
	};

	Expression.Details.add({
		type: "determinant-Gauss",
		i18n: function () {
			return i18n['matrix.method.gauss'];
		},
		minRows: 3,
		callback: function (printOptions, matrix) {
			return getDeterminantDetails(printOptions, matrix, Matrix.Gauss, i18n['matrix.determinant.explanation'], undefined);
		}
	});

	Expression.Details.add({
		type: "determinant-Montante",
		i18n: function () {
			return i18n['matrix.method.montante'];
		},
		minRows: 3,
		priority: 1,

		callback: function (printOptions, matrix) {
			var title = i18n['matrix.method.montante.explanation'].replace(/\$\{someDetails3\}/g, Expression.getSomeDetails("someDetails3")).replace(/\$\{a_\(i,j\)\=\(a_\(r,c\)\*a_\(i,j\)\-a_\(i,c\)\*a_\(r,j\)\)\/p\}/g, "<math>" + Expression.p("a_(i,j)=(a_(r,c)*a_(i,j)-a_(i,c)*a_(r,j))/p") + "</math>").replace(/\$\{a_\(r,c\)\}/g, "<math>" + Expression.p("a_(r,c)") + "</math>").replace(/\$\{r\}/g, "<math>" + "<mi>r</mi>" + "</math>").replace(/\$\{c\}/g, "<math>" + "<mi>c</mi>" + "</math>").replace(/\$\{p\}/g, "<math>" + "<mi>p</mi>" + "</math>");
			return getDeterminantDetails(printOptions, matrix, Matrix.GaussMontante, title, i18n['matrix.method.montante.header']);
		}
	});
}